id	title	description	project_name	status_name	priority_id	type_id	assignee_id	labels
13353492	Calcite bug. Can`t access cache created on the server side from client node.	"table created from server node

{code:java}
        IgniteCache<Integer, Integer> devCache = grid(0).createCache(projCfg);

        assertFalse(grid(0).configuration().isClientMode());
{code}
and accessed from client :

{code:java}
node.context().query().querySqlFields(new SqlFieldsQuery(sql).setSchema(""PUBLIC""), true).getAll();
{code}

throws: 

{code:java}
java.lang.NullPointerException
	at org.apache.ignite.internal.processors.query.calcite.schema.TableDescriptorImpl.distribution(TableDescriptorImpl.java:197)
	at org.apache.ignite.internal.processors.query.calcite.schema.IgniteTableImpl.distribution(IgniteTableImpl.java:121)
	at org.apache.ignite.internal.processors.query.calcite.schema.IgniteTableImpl.toRel(IgniteTableImpl.java:89)
	at org.apache.ignite.internal.processors.query.calcite.schema.IgniteTable.toRel(IgniteTable.java:61)
	at org.apache.ignite.internal.processors.query.calcite.schema.IgniteTable.toRel(IgniteTable.java:40)
	at org.apache.calcite.prepare.RelOptTableImpl.toRel(RelOptTableImpl.java:285)
	at org.apache.calcite.sql2rel.SqlToRelConverter.toRel(SqlToRelConverter.java:3585)
	at org.apache.calcite.sql2rel.SqlToRelConverter.convertIdentifier(SqlToRelConverter.java:2507)
	at org.apache.calcite.sql2rel.SqlToRelConverter.convertFrom(SqlToRelConverter.java:2144)
	at org.apache.calcite.sql2rel.SqlToRelConverter.convertFrom(SqlToRelConverter.java:2093)
	at org.apache.calcite.sql2rel.SqlToRelConverter.convertFrom(SqlToRelConverter.java:2050)
	at org.apache.calcite.sql2rel.SqlToRelConverter.convertSelectImpl(SqlToRelConverter.java:663)
	at org.apache.calcite.sql2rel.SqlToRelConverter.convertSelect(SqlToRelConverter.java:644)
	at org.apache.calcite.sql2rel.SqlToRelConverter.convertQueryRecursive(SqlToRelConverter.java:3438)
	at org.apache.calcite.sql2rel.SqlToRelConverter.convertQuery(SqlToRelConverter.java:570)
	at org.apache.ignite.internal.processors.query.calcite.prepare.IgnitePlanner.rel(IgnitePlanner.java:211)
	at org.apache.ignite.internal.processors.query.calcite.exec.ExecutionServiceImpl.optimize(ExecutionServiceImpl.java:600)
	at org.apache.ignite.internal.processors.query.calcite.exec.ExecutionServiceImpl.prepareQuery(ExecutionServiceImpl.java:568)
	at org.apache.ignite.internal.processors.query.calcite.exec.ExecutionServiceImpl.prepareSingle(ExecutionServiceImpl.java:542)
	at org.apache.ignite.internal.processors.query.calcite.exec.ExecutionServiceImpl.prepareQuery(ExecutionServiceImpl.java:501)
	at org.apache.ignite.internal.processors.query.calcite.prepare.QueryPlanCacheImpl.queryPlan(QueryPlanCacheImpl.java:84)
	at org.apache.ignite.internal.processors.query.calcite.exec.ExecutionServiceImpl.executeQuery(ExecutionServiceImpl.java:378)
	at org.apache.ignite.internal.processors.query.calcite.CalciteQueryProcessor.query(CalciteQueryProcessor.java:241)
	at org.apache.ignite.internal.processors.query.GridQueryProcessor.querySqlFields(GridQueryProcessor.java:2841)
	at org.apache.ignite.internal.processors.query.GridQueryProcessor.querySqlFields(GridQueryProcessor.java:2766)
	at org.apache.ignite.internal.processors.query.GridQueryProcessor.querySqlFields(GridQueryProcessor.java:2739)
	at org.apache.ignite.internal.processors.query.calcite.SqlFieldsQueryUsageTest.execute(SqlFieldsQueryUsageTest.java:99)
	at org.apache.ignite.internal.processors.query.calcite.SqlFieldsQueryUsageTest.createCacheOnSrvCallOnCli(SqlFieldsQueryUsageTest.java:89)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.apache.ignite.testframework.junits.GridAbstractTest$7.run(GridAbstractTest.java:2375)
	at java.lang.Thread.run(Thread.java:748)
{code}

reproduser atached"	IGNITE	Resolved	3	4	1888	calcite
13595441	Calcite engine. Cached compiled expression for correlated variable can have different data type	"Reproducer:

{code:java}
    @Test
    public void testCorrelatesDifferentDataType() {
        for (String type : new String[] {""INTEGER"", ""TINYINT""}) {
            try {
                sql(""CREATE TABLE t1(v INTEGER)"");
                sql(""CREATE TABLE t2(v "" + type + "")"");
                sql(""INSERT INTO t1 VALUES (1)"");
                sql(""INSERT INTO t2 VALUES (1)"");

                assertQuery(""SELECT (SELECT t1.v + t2.v FROM t1) FROM t2"")
                    .returns(2)
                    .check();
            }
            finally {
                sql(""DROP TABLE t1"");
                sql(""DROP TABLE t2"");
            }
        }
    }
{code}
Fails with:

{noformat}
Caused by: java.lang.ClassCastException: class java.lang.Byte cannot be cast to class java.lang.Integer (java.lang.Byte and java.lang.Integer are in module java.base of loader 'bootstrap')
	at SC.execute(Unknown Source)
	at org.apache.ignite.internal.processors.query.calcite.exec.exp.ExpressionFactoryImpl$ProjectImpl.apply(ExpressionFactoryImpl.java:668)
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.ProjectNode.push(ProjectNode.java:63)
...
{noformat}
"	IGNITE	Resolved	3	1	1888	calcite, ise
13563166	Thin client: Avoid blocking of client-connector threads by transactional operations	Currently client-connector threads (workers for thin-client operations) can be blocked for a long time by cache operation within transaction. If there is not enough threads configured it can lead to deadlocks. For example, if we have {{n}} threads and {{n+1}} clients which start the pessimistic transaction and try to modify the same key, first client lock the key, other {{n}} clients wait on locked key and hold the whole thread put by blocking operations.  Commit/rollback from the first client can never be proceeded, since all threads are occupied, and threads can't be released, since they are waiting for commit/rollback from the first client.	IGNITE	Resolved	3	4	1888	ise
13589047	Calcite engine. Object dynamic parameters are not converted to binary objects	"Objects inside Ignite are stored in binary object format. When we pass dynamic parameters to the query, we left compound objects as is. These objects can't be compared with objects inside cache. For example:

{code:java}
        IgniteCache<Integer, Employer> emp = client.getOrCreateCache(
            new CacheConfiguration<Integer, Employer>(""emp"")
                .setSqlSchema(""PUBLIC"")
                .setQueryEntities(F.asList(new QueryEntity(Integer.class, Employer.class).setTableName(""emp"")))
        );

        emp.put(0, new Employer(""emp"", 0d));

        assertQuery(""SELECT _key FROM emp WHERE _val = ?"").withParams(new Employer(""emp"", 0d)).resultSize(1).check();
{code}
This query returns 0 rows.
"	IGNITE	Resolved	3	1	1888	calcite, ise
13388687	Wrong heartbeat update while waiting for a checkpoint by timeout	"This problem occurs under these conditions:
 * native persistence is turned on
 * failureDetectionTimeout < checkpointFrequency
 * checkpoints are sometimes skipped by timeout (more often, more probable the problem occurrence)

There is a race condition between a listener execution and finishing of a pending future (see CheckpointContextImpl#executor body [1]). In some cases future can finish before listener closure, therefore updating of a heartbeat in listener can occur after call of _blockingSectionBegin_ in Checkpointer#waitCheckpointEvent, i.e. after Checkpointer started to wait for next checkpoint (see [2]).


{code:java|title=CheckpointContextImpl#executor}
    @Override public Executor executor() {
        return asyncRunner == null ? null : cmd -> {
            try {
                GridFutureAdapter<?> res = new GridFutureAdapter<>();

                res.listen(fut -> heartbeatUpdater.updateHeartbeat()); // Listener is invoked concurrently with pending future finish

                asyncRunner.execute(U.wrapIgniteFuture(cmd, res));

                pendingTaskFuture.add(res);
            }
            catch (RejectedExecutionException e) {
                assert false : ""A task should never be rejected by async runner"";
            }
        };
    }
{code}
{code:java|title=Checkpointer#waitCheckpointEvent}
try {
    synchronized (this) {
        long remaining = U.nanosToMillis(scheduledCp.nextCpNanos - System.nanoTime());

        while (remaining > 0 && !isCancelled()) {
            blockingSectionBegin();

            try {
                wait(remaining); 
                // At this point and till blockingSectionEnd call heartbeat should be equal to Long.MAX_VALUE

                remaining = U.nanosToMillis(scheduledCp.nextCpNanos - System.nanoTime());
            }
            finally {
                blockingSectionEnd();
            }
        }
    }
}
{code}
 
If interval between checkpoints (_checkpointFrequency_) is greater than the _failureDetectionTimeout_, then update of heartbeat in _blockingSectionEnd_ may cause an error message in log, because a checkpoint thread is treated as blocked (but in fact it was not).

*Reproducer of problem:* [3]. Even if test was not failed you can see log message with incorrect heartbeat after waiting for checkpoint.
 
Links:
 # [CheckpointContextImpl#executor|https://github.com/apache/ignite/blob/master/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/checkpoint/CheckpointContextImpl.java#L104]
 # [Checkpointer#waitCheckpointEvent|https://github.com/apache/ignite/blob/master/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/checkpoint/Checkpointer.java#L816]
# Reproducer: [^Checkpointer_fake_block_master.patch]. "	IGNITE	Resolved	4	1	1888	ise
13574556	Don't remove entries one-by-one for in-memory node on shutdown	Currently, for in-memory node we remove each entry one-by-one on cluster deactivation or on node shutdown. If there are a lot of entries in cache it can take a long time. But it's a redundant action, since all page memory will be released after deactivation/shutdown.	IGNITE	Resolved	3	4	1888	ise
13334153	Calcite integration. CREATE/DROP INDEX support	We need to support DDL commands. The task about the support of CREATE/DROP INDEX. Potentially with syntaxis as we already have in the H2 engine.	IGNITE	Resolved	2	2	1888	calcite
13530411	Node failes on rebalance during deactivation	"Failure handler triggered if caches is stopped (for example, due to deactivation) and node is processing partitions supply message. Reproducer:
{code:java}
@Override protected FailureHandler getFailureHandler(String igniteInstanceName) {
    return new StopNodeFailureHandler();
}

@Test
public void testRebalanceOnDeactivate() throws Exception {
    IgniteEx ignite0 = startGrid(0);
    IgniteEx ignite1 = startGrid(1);
    ignite0.cluster().state(ClusterState.ACTIVE);
    ignite0.cluster().baselineAutoAdjustEnabled(false);

    for (int i = 0; i < 10; i++) {
        IgniteCache<Integer, Integer> cache = ignite0.getOrCreateCache(
            new CacheConfiguration<Integer, Integer>(DEFAULT_CACHE_NAME).setBackups(1)
                .setAffinity(new RendezvousAffinityFunction(false, 2)));

        cache.clear();

        stopGrid(0);

        try (IgniteDataStreamer<Integer, Integer> streamer = ignite1.dataStreamer(DEFAULT_CACHE_NAME)) {
            for (int j = 0; j < 100_000; j++)
                streamer.addData(j, j);
        }

        ignite0 = startGrid(0);

        ignite0.cluster().state(ClusterState.INACTIVE);

        ignite0.cluster().state(ClusterState.ACTIVE);
    }
}{code}
 Fails with:
{noformat}
 java.lang.AssertionError: stopping=false, groupName=null, caches=[]
    at org.apache.ignite.internal.processors.cache.CacheGroupContext.singleCacheContext(CacheGroupContext.java:447) ~[classes/:?]
    at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionDemander.handleSupplyMessage(GridDhtPartitionDemander.java:584) ~[classes/:?]
    at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPreloader.lambda$handleSupplyMessage$0(GridDhtPreloader.java:346) ~[classes/:?]{noformat}"	IGNITE	Resolved	3	1	1888	ise
13536528	SQL onheap cache stores row on per-cache basis, but access these rows on per-index basis	"If there are two indexes on the same cache and sqlOnHeapCache property is enabled there can be node failures such as:
{noformat}
org.apache.ignite.internal.processors.cache.persistence.tree.CorruptedTreeException: B+Tree is corrupted [groupId=-917681634, pageIds=[844420635164678], cacheId=-917681634, cacheName=..., indexName=_key_PK, msg=Runtime failure on row: Row@71aeb1b9[ ... ][  ]]
...
Caused by: org.apache.ignite.IgniteException: Failed to store new index row.
...
Caused by: java.lang.UnsupportedOperationException: 13 cannot be used for inline type 19
{noformat}
Root cause: {{IndexRowCache}} is created per cache group (see {{IndexRowCacheRegistry#onCacheRegistered}}), but stores {{IndexRowImpl}} binded to particular index (see {{InlineIndexTree#createIndexRow}}). In case, when another index requires the same data row, it gets row from the onheap cache with the wrong index row handler."	IGNITE	Resolved	3	1	1888	ise
13117600	Implement new JMX metrics for topology monitoring	"These additional metrics and methods should be implemented:
* Current topology version
* Total server nodes count
* Total client nodes count
* Method to count nodes filtered by some node attribute
* Method to count nodes grouped by some node attribute
 
There is already a ticket to implement first 2 metrics from this list (IGNITE-6844)
"	IGNITE	Resolved	3	2	1888	iep-6, jmx
13588865	Calcite engine. Refactor BaseQueryContext.Builder	Currently, there are several usages of BaseQueryContext.Builder#frameworkConfig in code, which build new FrameworkConfig instance only to provide default schema. These usages can be simplified.	IGNITE	Resolved	3	3	1888	calcite, ise
13411680	Calcite. Default charset could be unsupported by Calcite	"Currently the default charset is taken from JVM's defaults:
{code:java|title=IgniteTypeFactory}
    @Override
    public Charset getDefaultCharset() {
        // Use JVM default charset rather then Calcite default charset (ISO-8859-1).
        return Charset.defaultCharset();
    }
{code}
The problem occurs when someone tries to execute a query using calcite-based query engine on a specific platform which default charset in not supported (E.g Windows with its WINDOWS-1252). The list of supported charset is defined by this:
{code:java|title=org.apache.calcite.sql.SqlUtil}
  /**
   * Translates a character set name from a SQL-level name into a Java-level
   * name.
   *
   * @param name SQL-level name
   * @return Java-level name, or null if SQL-level name is unknown
   */
  public static @Nullable String translateCharacterSetName(String name) {
    switch (name) {
    case ""BIG5"":
      return ""Big5"";
    case ""LATIN1"":
      return ""ISO-8859-1"";
    case ""UTF8"":
      return ""UTF-8"";
    case ""UTF16"":
    case ""UTF-16"":
      return ConversionUtil.NATIVE_UTF16_CHARSET_NAME;
    case ""GB2312"":
    case ""GBK"":
    case ""UTF-16BE"":
    case ""UTF-16LE"":
    case ""ISO-8859-1"":
    case ""UTF-8"":
      return name;
    default:
      return null;
    }
  }
{code}

The possible solution is to fallback to the UTF-8 when default charset is not supported. Another option is to explicitly stick to UTF-8."	IGNITE	Resolved	3	1	1888	calcite
13402697	Calcite. CAST with Boolean operations is failed.	"SqlRunner tests are failed

{noformat}
/sql/test_boolean_cast.test_ignore
{noformat}


{noformat}
query T
SELECT CAST(CAST('1' AS float) AS BOOLEAN)
----
true
{noformat}



{noformat}
Not expected result at: (test_try_cast.test:150). [row=0, col=0, expected=true, actual=false]

	at org.apache.ignite.internal.processors.query.calcite.logical.SqlScriptRunner$Query.checkEquals(SqlScriptRunner.java:635)
	at org.apache.ignite.internal.processors.query.calcite.logical.SqlScriptRunner$Query.checkResultTuples(SqlScriptRunner.java:604)
	at org.apache.ignite.internal.processors.query.calcite.logical.SqlScriptRunner$Query.checkResult(SqlScriptRunner.java:583)
	at org.apache.ignite.internal.processors.query.calcite.logical.SqlScriptRunner$Query.execute(SqlScriptRunner.java:555)
	at org.apache.ignite.internal.processors.query.calcite.logical.SqlScriptRunner.run(SqlScriptRunner.java:115)
	at org.apache.ignite.internal.processors.query.calcite.logical.ScriptTestRunner$1.run(ScriptTestRunner.java:219)
{noformat}
"	IGNITE	Resolved	3	4	1888	calcite
13538000	Calcite engine. Hide sensitive information in diagnostic tools	We need to hide sensitive information in queries exposed to diagnostic tools for the Calcite-based SQL engine, if flag IGNITE_TO_STRING_INCLUDE_SENSITIVE is not set.	IGNITE	Resolved	3	7	1888	ise
13567035	Calcite engine. Tuple (row) comparison is not working	"Currentrly, row comparison fails with an error and don't use index.

Reproducer:
{code:java}
sql(""CREATE TABLE test (id INTEGER, val INTEGER)"");
sql(""CREATE INDEX test_idx ON test (id, val)"");
sql(""INSERT INTO test VALUES (0, 0), (0, 1), (1, 0), (1, 1)"");

assertQuery(""SELECT * FROM test WHERE (id, val) >= (?, ?)"")
    .withParams(0, 1)
    //.matches(QueryChecker.containsIndexScan(""PUBLIC"", ""TEST"", ""TEST_IDX""))
    .returns(0, 1)
    .returns(1, 0)
    .returns(1, 1)
    .check(); {code}
Exception:
{noformat}
Caused by: java.lang.RuntimeException: while resolving method 'ge[class [Ljava.lang.Object;, class [Ljava.lang.Object;]' in class class org.apache.calcite.runtime.SqlFunctions
    at org.apache.calcite.linq4j.tree.Types.lookupMethod(Types.java:318)
    at org.apache.calcite.linq4j.tree.Expressions.call(Expressions.java:449)
    at org.apache.ignite.internal.processors.query.calcite.exec.exp.RexImpTable$BinaryImplementor.implementSafe(RexImpTable.java:1233)
    at org.apache.ignite.internal.processors.query.calcite.exec.exp.RexImpTable$AbstractRexCallImplementor.genValueStatement(RexImpTable.java:1950)
    at org.apache.ignite.internal.processors.query.calcite.exec.exp.RexImpTable$AbstractRexCallImplementor.implement(RexImpTable.java:1911)
{noformat}"	IGNITE	Open	3	1	1888	ise
13372644	Calcite engine. Alias for function CHARACTER_LENGTH	"Currently the function to get the length of the string is named {{CHARACTER_LENGTH}}. It would be nice to have an alias {{LENGTH}} for this.
"	IGNITE	Resolved	4	4	1888	calcite
13537999	Calcite engine. Tracing	We need to support tracing for the Calcite-based SQL engine.	IGNITE	Open	3	7	1888	ise
13305872	Java thin client: Service invocation	"Provide an API to invoke Ignite Services from java thin client.

Protocol changes and all implementation details described in IEP-46."	IGNITE	Resolved	3	2	1888	iep-46, important
13166103	Error during writeCheckpointEntry is not passed to failure handler during checkpoint finish	"I observed the following failure in Cache 3 suite:
{code}
[13:10:55]W:		 [org.apache.ignite:ignite-core] [2018-06-14 10:10:55,509][ERROR][db-checkpoint-thread-#138910%paged.PageEvictionMultinodeMixedRegionsTest2%][GridCacheDatabaseSharedManager] Failed to create checkpoint.
[13:10:55]W:		 [org.apache.ignite:ignite-core] class org.apache.ignite.internal.processors.cache.persistence.file.PersistentStorageIOException: Failed to write checkpoint entry [ptr=FileWALPointer [idx=0, fileOff=219747, len=1947], cpTs=1528971054548, cpId=d8b42759-ca5e-4613-b091-ed0356b3915d, type=END]
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at org.apache.ignite.internal.processors.cache.persistence.GridCacheDatabaseSharedManager.writeCheckpointEntry(GridCacheDatabaseSharedManager.java:2757)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at org.apache.ignite.internal.processors.cache.persistence.GridCacheDatabaseSharedManager.access$8100(GridCacheDatabaseSharedManager.java:178)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at org.apache.ignite.internal.processors.cache.persistence.GridCacheDatabaseSharedManager$Checkpointer.markCheckpointEnd(GridCacheDatabaseSharedManager.java:3716)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at org.apache.ignite.internal.processors.cache.persistence.GridCacheDatabaseSharedManager$Checkpointer.doCheckpoint(GridCacheDatabaseSharedManager.java:3277)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at org.apache.ignite.internal.processors.cache.persistence.GridCacheDatabaseSharedManager$Checkpointer.body(GridCacheDatabaseSharedManager.java:3053)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:110)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at java.lang.Thread.run(Thread.java:748)
[13:10:55]W:		 [org.apache.ignite:ignite-core] Caused by: java.nio.file.NoSuchFileException: /data/teamcity/work/c182b70f2dfa6507/work/db/node03-c5dcc243-fc3c-4b2f-8002-81e88d8cff7d/cp/1528971054548-d8b42759-ca5e-4613-b091-ed0356b3915d-END.bin.tmp
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:86)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:102)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:107)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at sun.nio.fs.UnixCopyFile.move(UnixCopyFile.java:409)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at sun.nio.fs.UnixFileSystemProvider.move(UnixFileSystemProvider.java:262)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at java.nio.file.Files.move(Files.java:1395)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	at org.apache.ignite.internal.processors.cache.persistence.GridCacheDatabaseSharedManager.writeCheckpointEntry(GridCacheDatabaseSharedManager.java:2752)
[13:10:55]W:		 [org.apache.ignite:ignite-core] 	... 6 more
[13:10:55]W:		 [org.apache.ignite:ignite-core] [2018-06-14 10:10:55,509][ERROR][db-checkpoint-thread-#138914%paged.PageEvictionMultinodeMixedRegionsTest3%][GridCacheDatabaseSharedManager] Failed to create checkpoint.
{code}

I see two issues here:
1) Some concurrent process is removing the work folder which results in the exception above
2) The checkpoint exception is not passed to the failure handler. This is due to a catch {{// TODO-ignite-db how to handle exception?}} in {{Checkpointer}}, which yields an uncompleted checkpoint future."	IGNITE	Resolved	3	1	1888	MakeTeamcityGreenAgain
13358369	Flaky IgniteSpringBeanSpringResourceInjectionTest.testSpringResourceInjectedInService	"Test failing with exception:
{noformat}
Caused by: java.lang.NullPointerException
    at org.apache.ignite.spring.injection.IgniteSpringBeanSpringResourceInjectionTest$2.getInjectedBean(IgniteSpringBeanSpringResourceInjectionTest.java:216)
    at org.apache.ignite.spring.injection.IgniteSpringBeanSpringResourceInjectionTest$TestSpringResourceInjectedRunnable.run(IgniteSpringBeanSpringResourceInjectionTest.java:159){noformat}
Reason: after IGNITE-14112 Ignite node start faster and async service initialization sometimes can't be finished before user code start to use Ignite."	IGNITE	Resolved	3	1	1888	MakeTeamcityGreenAgain
13574666	[PerfStat] Report can skip properties/rows/reads records from remote nodes	"In IGNITE-21863 after processing ""query"" record, we store aggregated result, assuming that after this point there are no more records related to this query. But such records may exist in other files (from other nodes)."	IGNITE	Resolved	3	1	1888	ise
13189139	SQL system view for cache groups	"Implement SQL system view to show list of cache groups. 
View must contain information: cache group id, cache group name, caches count, and attributes related to cache group from CacheConfiguration (at least attributes checked in {{ClusterCachesInfo#validateCacheGroupConfiguration()}} method)"	IGNITE	Resolved	3	3	1888	iep-13
13385196	Calcite engine. Date interval arythmetic returns invalid results	"{{select date '1992-01-01' + interval (17) days}} - returns {{1992-01-18}} - valid
{{select date '1992-01-01' + interval (18) days}} - returns {{1992-01-18}} - invalid

Tests:
{{function/date/test_extract_month.test}}"	IGNITE	Resolved	3	1	1888	calcite
13537995	Calcite engine. Events	Currently, for Calcite-based SQL enginge only EVT_CACHE_QUERY_EXECUTED event is fired, but H2-based SQL engine fires also EVT_CACHE_QUERY_OBJECT_READ and EVT_SQL_QUERY_EXECUTION. Calcite engine should fire these events as well.	IGNITE	Resolved	3	7	1888	ise
13419550	Calcite engine. Upgrade Apache Calcite dependency to 1.29.0	New version of Apache Calcite is released, we should upgrade version in ignite-calcite module.	IGNITE	Resolved	3	3	1888	calcite
13576369	Fix contention on expiration for persistent caches	"We've fixed contention on expiration for in-memory caches by IGNITE-14341 and IGNITE-21929 tickets, but persistent caches use another method to expire entries and this method should be fixed too. Moreover, there are some other optimizations related to expiration we can made:
 # Use batch pending tree entries removal for persistent caches (already implemented for in-memory)
 # Randomize iteration over cache data stores during expiration to reduce contention
 # For each transaction, we try to expire entries for every cache in the cluster. At least we can limit the list of caches to caches related to transaction.   
 # On cache destroy batch removal from pending entries tree can be used (instead of one-by-one deletion). "	IGNITE	Resolved	3	4	1888	ise
13594104	Calcite engine. Correlated nested loop LEFT join failure	"Some combination of left/right inputs size can lead to failure of correlated nested loop LEFT join:
{noformat}
Caused by: java.lang.AssertionError: null
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.CorrelatedNestedLoopJoinNode.request(CorrelatedNestedLoopJoinNode.java:130)
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.FilterNode.filter(FilterNode.java:135)
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.FilterNode.push(FilterNode.java:82)
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.CorrelatedNestedLoopJoinNode.join(CorrelatedNestedLoopJoinNode.java:434)
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.CorrelatedNestedLoopJoinNode.onEndRight(CorrelatedNestedLoopJoinNode.java:372)
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.CorrelatedNestedLoopJoinNode.endRight(CorrelatedNestedLoopJoinNode.java:255)
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.CorrelatedNestedLoopJoinNode$2.end(CorrelatedNestedLoopJoinNode.java:182)
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.ScanNode.processNextBatch(ScanNode.java:185)
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.ScanNode.push(ScanNode.java:145)
{noformat}
Root cause is described at related IGNITE-21722 ticket for AI3"	IGNITE	Resolved	3	1	1888	calcite, ignite-2, ise
13521482	Java thin client: Connections balancing	"Since Ignite 2.12 java thin client always connects to the first address from the provided address list. In typical configuration this leads to overloading an one server node and underloading other server nodes. 

To improve workload distribution we can:
 # Choose random first channel from the range of addresses with the same (minimal) port.
 # If partition awareness is enabled use random open channel instead of default channel for operations which can't be mapped to a certain node. "	IGNITE	Resolved	3	4	1888	important, ise
13226313	Java thin client: Handle multiple async requests in parallel	In the current implementation {{ReliableChannel}} uses an exclusive lock to send a request and waits for response synchronously. In this implementation, there are no benefits of using multiple threads. To improve throughput and latency we can implement async request/response processing on the client side, since the server side is already async.	IGNITE	Resolved	3	4	1888	iep-34
13566133	"NPE on metric ""TransactionsHoldingLockNumber"" if tx is not initialized"	"Attempt to get metric ""TransactionsHoldingLockNumber"" via JMX for not initialized transaction failed with:
{noformat}
java.lang.NullPointerException
    at org.apache.ignite.internal.processors.cache.transactions.IgniteTxStateImpl.empty(IgniteTxStateImpl.java:448)
    at org.apache.ignite.internal.processors.cache.transactions.IgniteTxLocalAdapter.empty(IgniteTxLocalAdapter.java:244)
    at org.apache.ignite.internal.processors.cache.transactions.TransactionMetricsAdapter.txHoldingLockNum(TransactionMetricsAdapter.java:368)
    at org.apache.ignite.internal.processors.cache.transactions.TransactionMetricsAdapter.getTransactionsHoldingLockNumber(TransactionMetricsAdapter.java:188)
    at org.apache.ignite.internal.processors.cache.transactions.TransactionMetricsAdapter$TransactionMetricsSnapshot.getTransactionsHoldingLockNumber(TransactionMetricsAdapter.java:468)
    at org.apache.ignite.internal.TransactionMetricsMxBeanImpl.getTransactionsHoldingLockNumber(TransactionMetricsMxBeanImpl.java:102)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at sun.reflect.misc.Trampoline.invoke(MethodUtil.java:71)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at sun.reflect.misc.MethodUtil.invoke(MethodUtil.java:275)
{noformat}"	IGNITE	Resolved	3	1	1888	ise
13510084	Calcite engine. Introduce correlate based distribution	"To propagate hash/affinity distribution in relation node all distribution keys should be contained in the node. It's impossible to pass hash distribution through the node if node knows nothing about hash distribution keys. For example, hash distribution can't bypass aggregate if one or more of distribution keys is not contained in grouped columns.

Suppose, for example, we have two tables T1 and T2 colocated on fields T1.A and T2.A. The following query:
{code:java}
SELECT (SELECT sum(b) FROM t2 WHERE t2.a = t1.a) FROM t1 {code}
Hash distribution can't be used on the right side of the correlated nested loop join, since aggregate doesn't have required columns, and plan for such a query looks very ineffective:
{noformat}
IgniteProject(EXPR$0=[$3]), id = 219
  IgniteCorrelatedNestedLoopJoin(condition=[true], joinType=[left], variablesSet=[[$cor0]], correlationVariables=[[$cor0]]), id = 218
    IgniteExchange(distribution=[single]), id = 213
      IgniteTableScan(table=[[PUBLIC, T1]]), id = 84
    IgniteColocatedHashAggregate(group=[{}], SUM(B)=[SUM($0)]), id = 217
      IgniteProject(B=[$1]), id = 216
        IgniteHashIndexSpool(readType=[LAZY], writeType=[EAGER], searchRow=[[$cor0.A, null]], condition=[=($0, $cor0.A)], allowNulls=[false]), id = 215
          IgniteExchange(distribution=[single]), id = 214
            IgniteTableScan(table=[[PUBLIC, T2]], requiredColumns=[{0, 1}]), id = 112{noformat}
If we look closer to the query we can find that filter {{t2.a = t1.a}} makes this query colocated. If we run such a query on H2 engine with {{colocatedJoin=false}} flag it will return the correct result. 

To workaround such a problem I propose to introduce some kind of artificial ""correlated distribution"". This distribution will be produced on the right side of correlated nested loop join, if left side of the join has hash distribution (will contain reference to correlate and distribution of this correlate), than passed through set of nodes without modification and finally on filter node will be restored as hash distribution remaped to input operator fields (if filter contains equality conditions input operator fields and correlated variable fields).

After such a change plan should be looks like:
{noformat}
IgniteExchange(distribution=[single]), id = 283
  IgniteProject(EXPR$0=[$3]), id = 282
    IgniteCorrelatedNestedLoopJoin(condition=[true], joinType=[left], variablesSet=[[$cor0]], correlationVariables=[[$cor0]]), id = 281
      IgniteTableScan(table=[[PUBLIC, T1]]), id = 84
      IgniteColocatedHashAggregate(group=[{}], SUM(B)=[SUM($0)]), id = 280
        IgniteProject(B=[$1]), id = 279
          IgniteFilter(condition=[=($0, $cor0.A)]), id = 278
            IgniteTableScan(table=[[PUBLIC, T2]], requiredColumns=[{0, 1}]), id = 112
{noformat}
 

 "	IGNITE	Resolved	3	4	1888	calcite
13271381	Java thin client: implement API for activation/deactivation and WAL enabling/disabling	"Implement ClusterAPI methods already supported by protocol:

isActive()

setActive(active flag)

isWalEnabled(cacheName)

enableWal(cacheName)

disableWal(cacheName)"	IGNITE	Resolved	3	2	1888	thin
13341350	Add an ability to view count of hot and cold pages in page memory	"Currently, we can't determine how many hot (touched recently) and cold pages we have in the page-memory. This information can be helpful for data region size tuning and can show the effectiveness of the page replacement algorithm.
Such information can be represented as a histogram showing the count of pages last touched in each time interval."	IGNITE	Resolved	3	2	1888	IEP-35, iep-62, ise
13561793	Ignite Extensions: Excessive memory usage by performance statistics QueryHandler	When processing queryProperty or queryRows events new strings are generated and written to the maps (as keys or values). Most of strings are not unique and already contained in other maps as keys or values, but as different instance. GC can't collect doublicated strings and this leads to OOM in some cases. 	IGNITE	Resolved	3	1	1888	ise
13486098	Assertion on histogram update if currentTimeMillis decreases	"Histogram metric classes (\{{HistogramMetricImpl}}, \{{PeriodicHistogramMetricImpl}}) assume that timestamp is always increasing, but in some cases method {{U.currentTimeMillis()}} can return decreasing values (for example, if time was set manually or on NTP sync). In these cases assertion can be thrown on histogram update:
{noformat}
java.lang.AssertionError: null
at org.apache.ignite.internal.processors.metric.impl.HistogramMetricImpl.value(HistogramMetricImpl.java:61) ~[classes/:?]
at org.apache.ignite.internal.util.StripedExecutor$Stripe.body(StripedExecutor.java:643) [classes/:?]
at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125) [classes/:?]
at java.lang.Thread.run(Thread.java:750) [?:1.8.0_322]{noformat}
We should fix {{PeriodicHistogramMetricImpl#add}} and {{HistogramMetricImpl#value}} methods to work correctly with decreasing timestamps."	IGNITE	Resolved	3	1	1888	ise
13596440	Configure default values for distributed properties	"Distributed properties are widely used in Ignite for different subsystems. But we can change value of distributed property only by expicit interaction with the cluster (via control.sh, for example). 
In general, we can't configure default value for distributed property (some subsystems provide such an ability, but the approach is not unified).
Especially it's inconvinient for in-memory cluster. After each cluster restart, extra actions are required to set distributed properties. 
It's proposed to provide unified way to configure distributed properties default values (introduce new property in IgniteConfiguration). "	IGNITE	Resolved	3	2	1888	ise
13237928	Java Thin: Implement Best Effort Affinity	See linked IEP-23.	IGNITE	Resolved	3	2	1888	iep-23, important
13181873	Add transactions support to thin clients	"Currently only ODBC and JDBC drivers support transactions and in not very efficient way. We need to add transactional API to .NET, Java, CPP, NodeJS and Python clients.

Key pieces:
# Add API to relevant clients
# Review listener logic - currently we create separate threads. But is it really needed? 
## If there is an implicit operation and no ongoing transaction, then operation might be executed right away
## If cache operations are decoupled from threads, then we can resort to reactive approach, when multiple transactions could be executed from the same thread"	IGNITE	Resolved	3	4	1888	iep-34, important
13141245	Throw Exceptions instead of AssertionErrors when reading from corrupted persistence	"There are a few places in our code where we explicitly throw AssertionErrors due to inability to correctly read data from persistence and many more places where we make assertions based on read values.

Assertions are used to indicate problems in internal logic, while persistence might also get corrupted by various external reasons. It also makes uniform handling of such issues considerably harder, because exception handling logic in Ignite ignores Errors. If we want to improve stability and minimize consequenses of pesistence corruption, we should replace all those AssertionErrors and asserts with Exceptions, so that current exception handling mechanisms could be reduce. In a number of situations it means that instead of causing cluster-wide hang-up problematic node will be automatically killed."	IGNITE	Resolved	3	4	1888	iep-14
13537641	Calcite engine. Make sure all diagnostic tools work 	"Calcite-based SQL engine and H2-based SQL engine use different paths to run queries. For H2-based engine we have a lot of diagnostic tools, perhaps some of them are not working for Calcite-based SQL engine. 
We need to check (write tests) and fix (in case it's not working) such instruments as:
* Metrics
* Events
* Long running queries warnings in log messages
* Performance statistics
* Tracing
* Hiding of sensitive information in diagnostic tools"	IGNITE	In Progress	3	4	1888	calcite, ise
13419732	Calcite engine. SetOp execution node cannot be rewinded	"Reproducer:
{code:java}
executeSql(""CREATE TABLE test(i INTEGER)"");
executeSql(""INSERT INTO test VALUES (1), (2)"");
assertQuery(""SELECT (SELECT test.i EXCEPT SELECT 0) FROM test"")
    .returns(1)
    .returns(2)
    .check();{code}
Throws:
{noformat}
Caused by: java.lang.IndexOutOfBoundsException: Index: 2, Size: 2
    at java.util.ArrayList.rangeCheck(ArrayList.java:657)
    at java.util.ArrayList.get(ArrayList.java:433)
    at org.apache.ignite.internal.processors.query.calcite.exec.rel.AbstractSetOpNode.request(AbstractSetOpNode.java:76){noformat}"	IGNITE	Resolved	3	1	1888	calcite
13145012	Add metrics for remains to evict keys/partitions	Need to add some metrics for remains to evict keys/partitions to indicate total amount of evicting work. In some cases we have synchronous eviction and it's critically important to know how many keys need to be evicted before exchange process end and cluster became working again. In some other cases we just wanna know what happens in cluster now (background eviction without workload) and when cluster will became 100% healthy. 	IGNITE	Resolved	3	2	1888	jmx
13389141	Calcite engine. TIMESTAMPDIFF for MICROSECOND unit doesn't work	"The function TIMESTAMPDIFF for MICROSECOND unit return incorrect results for many cases. As the example below returns 0.
{code:sql}
SELECT TIMESTAMPDIFF(MICROSECOND, TIMESTAMP '2022-02-01 10:30:28.000', TIMESTAMP '2022-02-01 10:30:28.128'){code}
see src/test/sql/function/timestamp/test_timestampdiff.test_ignore"	IGNITE	Resolved	3	1	1888	calcite
13402655	Calcite engine. Operator MINUS_DATE for days, hours, and minutes returns wrong result	"For example, all queries:
{noformat}
SELECT (DATE '2021-01-02' - DATE '2021-01-01') DAYS
SELECT (DATE '2021-01-02' - DATE '2021-01-01') HOURS
SELECT (DATE '2021-01-02' - DATE '2021-01-01') MINUTES
SELECT (DATE '2021-01-02' - DATE '2021-01-01') SECONDS{noformat}
Returns {{86400000}} (the value in milliseconds)

For YEAR time unit return the same value as for MONTH."	IGNITE	Resolved	3	1	1888	calcite
13185824	Flaky failure of SqlSystemViewsSelfTest 	"SqlSystemViewsSelfTest fails sometimes with the following error:

{noformat}
[2018-09-18 08:23:56,275][ERROR][main][root] Test failed.
javax.cache.CacheException: class org.apache.ignite.IgniteCheckedException: Failed to register MBean for component: org.apache.ignite.internal.processors.cache.CacheLocalMetricsMXBeanImpl@58f7fe1b
    at org.apache.ignite.internal.processors.cache.GridCacheUtils.convertToCacheException(GridCacheUtils.java:1326)
    at org.apache.ignite.internal.IgniteKernal.getOrCreateCache(IgniteKernal.java:3161)
    at org.apache.ignite.internal.processors.query.SqlSystemViewsSelfTest.execSql(SqlSystemViewsSelfTest.java:76)
    at org.apache.ignite.internal.processors.query.SqlSystemViewsSelfTest.testNodesViews(SqlSystemViewsSelfTest.java:386)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at junit.framework.TestCase.runTest(TestCase.java:176)
    at org.apache.ignite.testframework.junits.GridAbstractTest.runTestInternal(GridAbstractTest.java:2177)
    at org.apache.ignite.testframework.junits.GridAbstractTest.access$000(GridAbstractTest.java:143)
    at org.apache.ignite.testframework.junits.GridAbstractTest$5.run(GridAbstractTest.java:2092)
    at java.lang.Thread.run(Thread.java:748)
Caused by: class org.apache.ignite.IgniteCheckedException: Failed to register MBean for component: org.apache.ignite.internal.processors.cache.CacheLocalMetricsMXBeanImpl@58f7fe1b
    at org.apache.ignite.internal.processors.cache.GridCacheProcessor.registerMbean(GridCacheProcessor.java:4312)
    at org.apache.ignite.internal.processors.cache.GridCacheProcessor.createCache(GridCacheProcessor.java:1727)
    at org.apache.ignite.internal.processors.cache.GridCacheProcessor.prepareCacheStart(GridCacheProcessor.java:1982)
    at org.apache.ignite.internal.processors.cache.CacheAffinitySharedManager.processClientCacheStartRequests(CacheAffinitySharedManager.java:439)
    at org.apache.ignite.internal.processors.cache.CacheAffinitySharedManager.processClientCachesChanges(CacheAffinitySharedManager.java:633)
    at org.apache.ignite.internal.processors.cache.GridCacheProcessor.processCustomExchangeTask(GridCacheProcessor.java:379)
    at org.apache.ignite.internal.processors.cache.GridCachePartitionExchangeManager$ExchangeWorker.processCustomTask(GridCachePartitionExchangeManager.java:2393)
    at org.apache.ignite.internal.processors.cache.GridCachePartitionExchangeManager$ExchangeWorker.body0(GridCachePartitionExchangeManager.java:2529)
    at org.apache.ignite.internal.processors.cache.GridCachePartitionExchangeManager$ExchangeWorker.body(GridCachePartitionExchangeManager.java:2457)
    at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:110)
    ... 1 more
Caused by: javax.management.InstanceAlreadyExistsException: org.apache:clsLdr=5c080ef3,igniteInstanceName=query.SqlSystemViewsSelfTest1,group=default,name=""org.apache.ignite.internal.processors.cache.CacheLocalMetricsMXBeanImpl""
    at com.sun.jmx.mbeanserver.Repository.addMBean(Repository.java:437)
    at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerWithRepository(DefaultMBeanServerInterceptor.java:1898)
    at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerDynamicMBean(DefaultMBeanServerInterceptor.java:966)
    at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerObject(DefaultMBeanServerInterceptor.java:900)
    at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerMBean(DefaultMBeanServerInterceptor.java:324)
    at com.sun.jmx.mbeanserver.JmxMBeanServer.registerMBean(JmxMBeanServer.java:522)
    at org.apache.ignite.internal.util.IgniteUtils.registerMBean(IgniteUtils.java:4614)
    at org.apache.ignite.internal.util.IgniteUtils.registerMBean(IgniteUtils.java:4585)
    at org.apache.ignite.internal.processors.cache.GridCacheProcessor.registerMbean(GridCacheProcessor.java:4308)
    ... 10 more
{noformat}
"	IGNITE	Resolved	3	3	1888	MakeTeamcityGreenAgain, iep-13
13537360	Metrics for operations on indexes	Currently, we don't have metrics about performance of operations on indexes. We have, {{io.statistics.sortedIndexes.*}} metrics about logical and physical page reads, but without operation types and without duration. It will be heplful to have metrics for different operations on indexes.  	IGNITE	Resolved	3	4	1888	ise
13204776	SQL implement system view for partition states	Implement SQL system view to partition states in the cluster for each cache group and each node.	IGNITE	Resolved	3	3	1888	IEP-35, iep-13
13118962	Thread Starvation monitoring	"Ignite Thread Pools Starvation

Description
This situation can occur if user submits tasks that recursively submit more tasks and synchronously wait for results. Jobs arrive to worker nodes and are queued forever since there are no free threads in public pool since all threads are waiting for job results.

Detection and Solution
Task timeout can be set for tasks, so task gets canceled automatically.
Web Console should provide ability to cancel any task and job from UI.

Report
Timed out tasks and jobs should be reported on Web Console and reported to logs. We need to introduce new config property to set timeout for reported jobs.
Log record and Web Console should include:
- Master node ID
- Start time"	IGNITE	Resolved	3	4	1888	iep-7
13180760	SQL: Remove NODES.IS_LOCAL attribute	We need to remove {{IS_LOCAL}} attribute from {{NODES}} system view. This attribute doesn't make sense: it depends on where SQL query is executed. When executed from JDBC/ODBC driver user will received strange result, when remote node is displayed as local.	IGNITE	Resolved	3	3	1888	iep-13
12778149	Cache manager should switch cache statisticsEnabled property globaly	"Also you should take care about new nodes that joining grid.
New node could have statisticsEnabled with opposite value that nodes in grid."	IGNITE	Closed	3	3	1888	iep-6
13577085	Performance drop for thin client requests	"After IGNITE-21183 there is performance drop for thin client transactional operations up to 38%:

!perf_drop.png|width=1083,height=168!"	IGNITE	Resolved	3	1	1888	ise
13385647	Calcite engine. Supports regexp operators	"Calcite engine implements {{SqlPosixRegexOperator}}.
Must be supported by current parser configuration & validator.


Test:
{{function/string/regex_filter_pushdown.test_ignore}}"	IGNITE	Resolved	3	1	1888	calcite
13471362	Move control utility index tasks to the core module	"There are some control utility tasks (indexes list, index validate, index rebuild), which are depended on H2 and located in indexing module. But instead of H2 module classes core module classes having almost the same functionality can be used.

We should rewrite these tasks to use core module classes to make tasks workable without H2. "	IGNITE	Resolved	3	4	1888	ignite-osgi, ise
13546860	Calcite engine. Dependency common-codec required for some functions	Some functions (md5, soundex) require common-codec dependency, but this dependency is not included explicitly to dependencies list and doesn't added to calcite library folder on build. Tests run with transitive dependencies and don't trigger the problem. Queries fail only when run on Ignite started from binary release package.	IGNITE	Resolved	3	1	1888	calcite, calcite3-required, ise
13470951	"Move ""metrics"" SQL system view to GridSystemViewManager"	"Currently we have dedicated adapter for ""metrics"" system view (\{{MetricRegistryLocalSystemView}}), this view doesn't registered in common view registry (via \{{GridSystemViewManager}}) and can't be used by any views exporter except H2 SQL engine (for example by Calcite SQL engine). "	IGNITE	Resolved	3	4	1888	ise
13417061	Calcite engine. Fallback to table scan if index is absent on some nodes	"Calcite-based SQL engine creates a plan on node initiator and uses only local node data for planning. The local node doesn't know about other nodes' indexes state, indexes on some nodes can be rebuilt during query execution, and fragments of the plan containing rebuilding indexes can't be executed on these nodes. In this case, we should provide some type of fallback. For example, if the status of the index is invalid and the plan contains an index scan, we should replace this index scan with the chain: sorted index spool -> sort -> table scan. 
As a target solution, perhaps we should maintain global indexes state and make plans using this information"	IGNITE	Resolved	3	4	1888	calcite
13417653	Calcite engine. RelJsonReader can't deserialize enums	If some remote fragment of plan contains nodes reading enums (for example {{IgniteTableSpool}} reads {{Spool.Type}} enum) deserialization fails on method {{getEnum}}. This method uses {{Util.enumVal}}, but not all type of enums registered here, the method {{relJson.toEnum(get(tag))}} should be used to read enums instead. 	IGNITE	Resolved	3	1	1888	calcite
13179836	SQL system view for list of baseline topology nodes	"Implement SQL system view to show list of baseline topology nodes. View must contain information about node consistentId and online/offline status.

"	IGNITE	Resolved	3	3	1888	iep-13
13138464	SQL system view for list of nodes	Implement SQL system view to show list of nodes in topology.	IGNITE	Resolved	3	3	1888	iep-13
13550000	Calcite engine. Convert one input of a join to the broadcast distribution	"Sometimes, if join inputs are not collocated it's worth to broadcast one of the inputs, for example, query:
{code:sql}
SELECT * FROM emps WHERE emps.salary = (SELECT AVG(emps.salary) FROM emps){code}
Currently has plan:
{noformat}
IgniteProject(ID=[$0], NAME=[$1], SALARY=[$2])
  IgniteNestedLoopJoin(condition=[=($2, $3)], joinType=[inner])
    IgniteExchange(distribution=[single])
      IgniteTableScan(table=[[PUBLIC, EMPS]])
    IgniteReduceHashAggregate(group=[{}], AVG(EMPS.SALARY)=[AVG($0)])
      IgniteExchange(distribution=[single])
        IgniteMapHashAggregate(group=[{}], AVG(EMPS.SALARY)=[AVG($0)])
          IgniteIndexScan(table=[[PUBLIC, EMPS]], index=[TST], requiredColumns=[{2}], collation=[[2 ASC-nulls-first]])
{noformat}
But this plan is not optimal, since we should send entire table EMP from all nodes to the single node. For such a query it's better to broadcast result of the aggregation, in this case plan will be something like:
{noformat}
IgniteExchange(distribution=[single])
  IgniteProject(...)
    IgniteCorrelatedNestedLoopJoin(...)
      IgniteExchange(distribution=[broadcast])
        IgniteReduceHashAggregate(group=[{}], AVG(EMPS.SALARY)=[AVG($0)])
          IgniteExchange(distribution=[single])
            IgniteMapHashAggregate(group=[{}], AVG(EMPS.SALARY)=[AVG($0)])
              IgniteIndexScan(table=[[PUBLIC, EMPS]], index=[SALARY_IDX])
      IgniteIndexScan(table=[[PUBLIC, EMPS]], index=[SALARY_IDX])
{noformat}
But currently we don't try to convert any of the join inputs to the broadcast distribution. We should try to do this."	IGNITE	In Progress	3	4	1888	calcite, calcite2-required, calcite3-required, ise
13511068	Calcite engine. Limit with offset can return negative estimated rows count	"Limit with offset can return negative estimated rows count, this will throw an assertion error if limit is used as input of another relational operator.

For example:
{code:java}
CREATE TABLE t(id INT);
INSERT INTO t VALUES (1), (2), (3);
SELECT (SELECT id FROM t ORDER BY id LIMIT 1 OFFSET 10); {code}
Throws:
{noformat}
java.lang.AssertionError: null
    at org.apache.calcite.rel.metadata.RelMdUtil.isNonNegative(RelMdUtil.java:988) ~[calcite-core-1.32.0.jar:1.32.0]
    at org.apache.calcite.rel.metadata.RelMdUtil.validateResult(RelMdUtil.java:977) ~[calcite-core-1.32.0.jar:1.32.0]
    at org.apache.calcite.rel.metadata.RelMetadataQuery.getRowCount(RelMetadataQuery.java:259) ~[calcite-core-1.32.0.jar:1.32.0]
    at org.apache.calcite.rel.metadata.RelMdRowCount.getRowCount(RelMdRowCount.java:73) ~[calcite-core-1.32.0.jar:1.32.0]
    at org.apache.calcite.rel.metadata.janino.GeneratedMetadata_RowCountHandler.getRowCount_$(Unknown Source) ~[?:?]
    at org.apache.calcite.rel.metadata.janino.GeneratedMetadata_RowCountHandler.getRowCount(Unknown Source) ~[?:?]
    at org.apache.calcite.rel.metadata.RelMetadataQuery.getRowCount(RelMetadataQuery.java:258) ~[calcite-core-1.32.0.jar:1.32.0]
    at org.apache.ignite.internal.processors.query.calcite.rel.IgniteAggregate.computeSelfCostHash(IgniteAggregate.java:94) ~[classes/:?]{noformat}
 "	IGNITE	Resolved	3	1	1888	calcite
13589041	Calcite engine. Multi-node index scan fails on index with binary object field	"Reproducer:

{code:java}
public class IndexScanMultiNodeIntegrationTest extends AbstractBasicIntegrationTest {
    /** */
    @Test
    public void testComplexKeyScan() {
        IgniteCache<EmployerKey, Employer> emp = client.getOrCreateCache(
            new CacheConfiguration<EmployerKey, Employer>(""emp"")
                .setSqlSchema(""PUBLIC"")
                .setQueryEntities(F.asList(new QueryEntity(EmployerKey.class, Employer.class).setTableName(""emp"")))
        );

        for (int i = 0; i < 100; i++)
            emp.put(new EmployerKey(i, i), new Employer(""emp"" + i, (double)i));

        assertQuery(""SELECT /*+ FORCE_INDEX(\""_key_PK\"") */ _key FROM emp"").resultSize(100).check();
    }

    /** */
    private static class EmployerKey {
        /** */
        @QuerySqlField
        private final int id0;

        /** */
        @QuerySqlField
        private final int id1;

        /** */
        private EmployerKey(int id0, int id1) {
            this.id0 = id0;
            this.id1 = id1;
        }
    }
}
{code}
Fails with:

{noformat}
...
Caused by: java.lang.ClassCastException: org.apache.ignite.internal.binary.BinaryObjectImpl cannot be cast to java.lang.Comparable
	at org.apache.ignite.internal.processors.query.calcite.exec.exp.ExpressionFactoryImpl.compare(ExpressionFactoryImpl.java:248)
	at org.apache.ignite.internal.processors.query.calcite.exec.exp.ExpressionFactoryImpl.access$300(ExpressionFactoryImpl.java:86)
	at org.apache.ignite.internal.processors.query.calcite.exec.exp.ExpressionFactoryImpl$1.compare(ExpressionFactoryImpl.java:182)
	at java.util.Map$Entry.lambda$comparingByKey$6d558cbf$1(Map.java:508)
	at java.util.PriorityQueue.siftUpUsingComparator(PriorityQueue.java:669)
	at java.util.PriorityQueue.siftUp(PriorityQueue.java:645)
	at java.util.PriorityQueue.offer(PriorityQueue.java:344)
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.Inbox.pushOrdered(Inbox.java:239)
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.Inbox.push(Inbox.java:201)
	at org.apache.ignite.internal.processors.query.calcite.exec.rel.Inbox.onBatchReceived(Inbox.java:177)
...
{noformat}

"	IGNITE	Resolved	3	1	1888	calcite, ise
13520231	Java thin client: Cluster discovery	"We already have cluster endpoints discovery in protocol and implementation for .NET thin client. 

Implementation for java thin client should be added too."	IGNITE	Resolved	3	2	1888	IEP-44, important, ise
13541045	Continuous qieries backup acknowledge message sending fails for expired entries	"Expire entry event has {{null}} in topology version field (see {{CacheContinuousQueryEntry}} constructor in the {{CacheContinuousQueryManager#onEntryExpired}} method). When Backup acknowledge is sending for such a message it silently (without warnings to log) fails with NPE on {{GridDiscoveryManager#cacheGroupAffinityNodes}} -> {{GridDiscoveryManager#resolveDiscoCache}} for {{null}} topology version (see {{CacheContinuousQueryHandler#sendBackupAcknowledge}}).
This can lead to leaks in query entries buffer ({{CacheContinuousQueryEventBuffer#backupQ}})."	IGNITE	Resolved	3	1	1888	ise
13276021	ReflectionFactory is essential thanks to PlatformDotNetSessionLockResult	"We currently treat ReflectionFactory as a nice-to-have thing, so we silently ignore failures of its reflection:
{code}
        try {
            Class<?> refFactoryCls = Class.forName(""sun.reflect.ReflectionFactory"");

            refFac = refFactoryCls.getMethod(""getReflectionFactory"").invoke(null);

            ctorFac = refFac.getClass().getMethod(""newConstructorForSerialization"", Class.class,
                Constructor.class);
        }
        catch (NoSuchMethodException | ClassNotFoundException | IllegalAccessException | InvocationTargetException ignored) {
            // No-op.
        }
{code}

However, it is now essential thanks to the class PlatformDotNetSessionLockResult, which is always registered during note start-up and which does not have empty constructor.

So not having access to ReflectionFactory (JBoss will hide it, for example) will lead to the following cryptic exception (courtesy stack overflow):
{code}
2019-12-19 09:11:39,355 SEVERE [org.apache.ignite.internal.IgniteKernal] (ServerService Thread Pool -- 81) Got exception while starting (will rollback startup routine).: class org.apache.ignite.binary.BinaryObjectException: Failed to find empty constructor for class: org.apache.ignite.internal.processors.platform.websession.PlatformDotNetSessionLockResult
    at deployment.StreamsApp.ear//org.apache.ignite.internal.binary.BinaryClassDescriptor.constructor(BinaryClassDescriptor.java:981)
    at deployment.StreamsApp.ear//org.apache.ignite.internal.binary.BinaryClassDescriptor.<init>(BinaryClassDescriptor.java:267)
    at deployment.StreamsApp.ear//org.apache.ignite.internal.binary.BinaryContext.registerPredefinedType(BinaryContext.java:1063)
    at deployment.StreamsApp.ear//org.apache.ignite.internal.binary.BinaryContext.registerPredefinedType(BinaryContext.java:1048)
    at deployment.StreamsApp.ear//org.apache.ignite.internal.binary.BinaryContext.<init>(BinaryContext.java:350)
    at deployment.StreamsApp.ear//org.apache.ignite.internal.processors.cache.binary.CacheObjectBinaryProcessorImpl.start(CacheObjectBinaryProcessorImpl.java:208)
    at deployment.StreamsApp.ear//org.apache.ignite.internal.IgniteKernal.startProcessor(IgniteKernal.java:1700)
    at deployment.StreamsApp.ear//org.apache.ignite.internal.IgniteKernal.start(IgniteKernal.java:1013)
    at deployment.StreamsApp.ear//org.apache.ignite.internal.IgnitionEx$IgniteNamedInstance.start0(IgnitionEx.java:2038)
    at org.jboss.as.ee@18.0.1.Final//org.jboss.as.ee.component.BasicComponent.createInstance(BasicComponent.java:88)
{code}

My suggestions are the following:
- Introduce a warning when ReflectionFactory not found instead of ignoring exception.
- Add empty constructor to PlatformDotNetSessionLockResult and make sure no other classes need reflection during start-up.
- (optionally) instead, introduce an error when ReflectionFactory not found."	IGNITE	Resolved	3	1	1888	ise, usability
13586670	Refactor Index heirarchy	"Currently, ClientInlineIndex implements InlineIndex interface, which extends SortedSegmentedIndex, but all methods of ClientInlineIndex inherited from SortedSegmentedIndex throw ""Unsupported"" exception. Client index actually has nothing in common with SortedSegmentedIndex and should be inherited from Index. Inline size method of ClientInlineIndex actually required only to show inline size in system view. And I think, configured inline size will be enough on non-affinity node. "	IGNITE	Resolved	3	3	1888	ise
13242521	Yardstick benchmarks for WAL page snapshot compression	"WAL page snapshots compression (implemented by IGNITE-11336) can be enabled by modifying config.xml file. It will be better to configure benchmarks by command line options.

Also, some new probes (WAL size for example) can be added."	IGNITE	Resolved	3	4	1888	iep-20, yardstick
13513528	Sql. Different behavior of float cost approach leads to failed test. 	" 

Test like:
{code:java}
query IIIII
SELECT 127::DECIMAL(3,0)::FLOAT, -17014118346046923173168730371588410572::DECIMAL(38,0)::FLOAT, -7::DECIMAL(9,1)::FLOAT, 27::DECIMAL(18,1)::FLOAT, 33::DECIMAL(38,1)::FLOAT
----
127  -1.7014119E37  -7 27 33 

[row=0, col=1, expected=-1.7014119E37, actual=-1.701412E37]{code}
failed in ai-3 and passed in ai-2 cause in ai-2 in case of one fragment it always plans into local node _without_ any serialization\deserialization usage against ai-3 approach: through serialization, thus we obtain in ai-2 approach only 
ExpressionFactoryImpl#compile {-}{{-}}> ConstantExpression#write (case FLOAT) branch, while  in ai\{-}3: float was trimmed a bit in org.apache.calcite.rex.RexBuilder#clean and after goes into ExpressionFactoryImpl and so on .. 

Need further investigation.

 "	IGNITE	Resolved	3	1	1888	calcite, ignite-3
13580969	Inefficient serialization of UUIDs in communication messages	We serialize {{long}} and {{int}} data types in communication messages as {{varint}} to safe the space. UUID contains two {{long}} components {{LeastSignificantBits}} and {{MostSignificantBits}}, which currently serialized as {{varint}} too. But usually UUIDs are generated randomly and in most cases there is no any space optimization for random {{long}} values. To store {{long}} as 7 bytes or less in {{varint}} format (instead of 8 bytes to store {{long}} as is) it's required top 15 bits of {{long}} to be 0. Probability of such outcame for random long: 1/32768. 	IGNITE	Resolved	3	1	1888	ise
13353929	Calcite integration. IndexCondition refactoring	"Currently IndexCondition is quite cumbersome and hard to understand. The difference between bounds and conditions is unclear as well as unclear what should be used to estimate a selectivity and what should be used to estimate a self cost.

Thus I suggest to change it in a follow way:
 * remove [lower|upper]Cond
 * bounds remains as is
 * self cost estimation of an AbstractIndex should be calculated with regard to bounds
 * selectivity should be calculated with regards to whole condition that is member of ProjectableFilterableTableScan"	IGNITE	Resolved	3	4	1888	calcite
13386079	Add SystemView for baseline attributes stored in metastorage	"The BaselineTopology entry in the Metastorage SystemView [1] does not show a baseline node attributes. We could add additional system view for the stored attributes of baseline nodes.

1. https://ignite.apache.org/docs/2.10.0/monitoring-metrics/system-views#metastorage"	IGNITE	Resolved	3	2	1888	important, ise
13583927	Calcite engine. Distribution by affinity function for columns with null values fails	"If one side of the join converted to distribution of another side by affinity function there can be an errors like:
{noformat}
Caused by: java.lang.IllegalArgumentException: Null key is passed for a partition calculation. Make sure that an affinity key that is used is initialized properly.
    at org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction.partition(RendezvousAffinityFunction.java:506)
    at org.apache.ignite.internal.processors.query.calcite.trait.AffinityAdapter.applyAsInt(AffinityAdapter.java:46)
    at org.apache.ignite.internal.processors.query.calcite.trait.Partitioned.targets(Partitioned.java:42)
    at org.apache.ignite.internal.processors.query.calcite.exec.rel.Outbox.flush(Outbox.java:233)
    at org.apache.ignite.internal.processors.query.calcite.exec.rel.Outbox.push(Outbox.java:141)
{noformat}
If input to rehash contains null values."	IGNITE	Resolved	3	1	1888	calcite, ise
13526891	Add an ability to extend control-utility without modification of Ignite code	"Currently, control.sh utility can't be extended with the new commands without modification of Ignite code.

It's required sometimes to have an additional tools for cluster management. It will be useful if user has an ability to extend control-utility with the new commands instead of creating own tools with boilerplate code."	IGNITE	Resolved	3	4	1888	ise
13417308	Calcite engine. Support BINARY/VARBINARY data types	Currently, BINARY/VARBINARY data types have {{ByteString}} internal representation in Calcite, but {{byte[]}} expected by Ignite. We should add conversation from internal and to internal representation (see {{TypeUtils}} class).	IGNITE	Resolved	3	4	1888	calcite
13415210	Calcite. Some kind of CROSS JOIN based queries can`t be parsed.	"Queries like attached can`t be planned. 
/modules/calcite/src/test/sql/sqlite/aggregates/agg1.test_ignored
{noformat}
statement ok
CREATE TABLE tab0(col0 INTEGER, col1 INTEGER, col2 INTEGER)

statement ok
CREATE TABLE tab1(col0 INTEGER, col1 INTEGER, col2 INTEGER)

statement ok
CREATE TABLE tab2(col0 INTEGER, col1 INTEGER, col2 INTEGER)

statement ok
INSERT INTO tab0 VALUES(97,1,99)

query I rowsort
SELECT - 92 AS col1 FROM ( tab1 AS cor0 CROSS JOIN tab2 AS cor1 )
----
9 values hashing to 1af709a79a3e56281ffdce4d931d5965

query I rowsort
SELECT - 13 FROM ( tab2 cor0 CROSS JOIN tab2 AS cor1 )
----
9 values hashing to e95f5f4bd0f480397cced5f5e8a23792

query I rowsort
SELECT ALL + - 37 AS col0 FROM tab0 AS cor0 CROSS JOIN tab1 AS cor1
----
9 values hashing to ed4644af7729c2425ea6cc3d84c6504f
{noformat}


{noformat}
Caused by: class org.apache.ignite.internal.processors.query.IgniteSQLException: Failed to parse query.
	at org.apache.ignite.internal.processors.query.calcite.util.Commons.parse(Commons.java:207)
	at org.apache.ignite.internal.processors.query.calcite.CalciteQueryProcessor.query(CalciteQueryProcessor.java:339)
	at org.apache.ignite.internal.processors.query.calcite.logical.SqlScriptRunner.sql(SqlScriptRunner.java:149)
	at org.apache.ignite.internal.processors.query.calcite.logical.SqlScriptRunner.access$600(SqlScriptRunner.java:58)
	at org.apache.ignite.internal.processors.query.calcite.logical.SqlScriptRunner$Query.execute(SqlScriptRunner.java:570)
	... 3 more
Caused by: org.apache.calcite.sql.parser.SqlParseException: Non-query expression encountered in illegal context
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.convertException(IgniteSqlParserImpl.java:397)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.normalizeException(IgniteSqlParserImpl.java:161)
	at org.apache.calcite.sql.parser.SqlParser.handleException(SqlParser.java:145)
	at org.apache.calcite.sql.parser.SqlParser.parseStmtList(SqlParser.java:200)
	at org.apache.ignite.internal.processors.query.calcite.util.Commons.parse(Commons.java:222)
	at org.apache.ignite.internal.processors.query.calcite.util.Commons.parse(Commons.java:204)
	... 7 more
Caused by: org.apache.calcite.runtime.CalciteException: Non-query expression encountered in illegal context
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at org.apache.calcite.runtime.Resources$ExInstWithCause.ex(Resources.java:505)
	at org.apache.calcite.runtime.Resources$ExInst.ex(Resources.java:599)
	at org.apache.calcite.sql.SqlUtil.newContextException(SqlUtil.java:932)
	at org.apache.calcite.sql.SqlUtil.newContextException(SqlUtil.java:917)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.checkNonQueryExpression(IgniteSqlParserImpl.java:320)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.Expression3(IgniteSqlParserImpl.java:4471)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.Expression2b(IgniteSqlParserImpl.java:4163)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.Expression2(IgniteSqlParserImpl.java:4204)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.Expression(IgniteSqlParserImpl.java:4134)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.LeafQueryOrExpr(IgniteSqlParserImpl.java:4116)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.QueryOrExpr(IgniteSqlParserImpl.java:4038)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.OrderedQueryOrExpr(IgniteSqlParserImpl.java:513)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.ParenthesizedExpression(IgniteSqlParserImpl.java:632)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.TableRef2(IgniteSqlParserImpl.java:2700)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.TableRef(IgniteSqlParserImpl.java:2641)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.FromClause(IgniteSqlParserImpl.java:2542)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.SqlSelect(IgniteSqlParserImpl.java:1783)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.LeafQuery(IgniteSqlParserImpl.java:601)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.LeafQueryOrExpr(IgniteSqlParserImpl.java:4119)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.QueryOrExpr(IgniteSqlParserImpl.java:4038)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.OrderedQueryOrExpr(IgniteSqlParserImpl.java:513)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.SqlStmt(IgniteSqlParserImpl.java:956)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.SqlStmtList(IgniteSqlParserImpl.java:906)
	at org.apache.ignite.internal.processors.query.calcite.sql.IgniteSqlParserImpl.parseSqlStmtList(IgniteSqlParserImpl.java:213)
	at org.apache.calcite.sql.parser.SqlParser.parseStmtList(SqlParser.java:198)
	... 9 more


{noformat}

"	IGNITE	Resolved	3	1	1888	calcite
13338405	Don't print warning if unordered map used for bulk update operation on atomic cache	Since IGNITE-12451 is resolved there no more deadlock possible for atomic caches and it's safe to use HashMap and other unordered maps as argument of putAll/removeAll/invokeAll operations on atomic caches. Warning, introduced by IGNITE-6804, is not required anymore.	IGNITE	Resolved	3	4	1888	2.9.1-rc
13386741	Calcite engine. Parser fails on REPLACE function	"The {{REPLACE}} function is declared at the calcite engine ({{SqlStdOperatorTable#REPLACE}})
but parser fails on the query:
{{SELECT REPLACE('A', 'B' 'C')}}
with error: {{Encountered """" at line 1, column 8.}}

Tests:
{{function/string/test_replace.test_ignore}}"	IGNITE	Resolved	3	1	1888	calcite
13446574	 Incorrect result of the DML delete operation, in some environment	"Description of the case, in some environment, the DML operation does not delete all data (this DML delete operation is an example). To reproduce the problem, you must:
# Create a table with a varchar field.
# Create an index on the given field.
# Fill the table with data, use int as the value.
# Delete data by specifying in the DML operation, as a condition, an indexed value, without String.valueOf(intValue)

The reproducer( [^IndexSetArgsAndCastTest.patch] ) shows this behavior in indexOnAutocastOff() test.

The result of all tests should be the same, specifically in this example (DML delete) - the number of entries in the cache, according to the result of each test, should be equal to zero."	IGNITE	Resolved	4	1	1888	ise
13466577	Move RunningQueryManager to the core module	Currently, {{RunningQueryManager}} class already declared in the core module, but still initiated inside {{{}IgniteH2Indexing{}}}. We should move running query manager initiation to the core module, to be able to use it without {{{}ignite-indexing{}}}.	IGNITE	Resolved	3	4	1888	ise
13575474	Thin client: Implement invoke/invokeAll operations	"We must implement invoke/invokeAll methods for thin client.

Dev. list thread and IEP should be started to discuss protocol and implementation details. "	IGNITE	Resolved	3	2	1888	IEP-122, ise
13425208	Error: Could not create the Java Virtual Machine.	" 
{code:java}
prom1se@prom1se-PC276:~/GG/apache/ignite-3/modules/cli/target$ ./ignite init
Creating directories... Done!
+--------------------+-------------------------------------------------------------------+
| Binaries Directory | /home/prom1se/GG/apache/ignite-3/modules/cli/target/ignite-bin    |
+--------------------+-------------------------------------------------------------------+
| Work Directory     | /home/prom1se/GG/apache/ignite-3/modules/cli/target/ignite-work   |
+--------------------+-------------------------------------------------------------------+
| Config Directory   | /home/prom1se/GG/apache/ignite-3/modules/cli/target/ignite-config |
+--------------------+-------------------------------------------------------------------+
| Log Directory      | /home/prom1se/GG/apache/ignite-3/modules/cli/target/ignite-log    |
+--------------------+-------------------------------------------------------------------+
Installing org.apache.ignite:ignite-runner:3.0.0-SNAPSHOT...
|==============================================================================================|Done!
Apache Ignite is successfully initialized. Use the ignite node start command to start a new local node.
prom1se@prom1se-PC276:~/GG/apache/ignite-3/modules/cli/target$ ./ignite node start my-first-node --config=/home/prom1se/GG/apache/ignite-3/examples/config/ignite-config.json
Starting a new Ignite node...
Can't start the node. Read logs for details: /home/prom1se/GG/apache/ignite-3/modules/cli/target/ignite-log/my-first-node.log
prom1se@prom1se-PC276:~/GG/apache/ignite-3/modules/cli/target$ cat /home/prom1se/GG/apache/ignite-3/modules/cli/target/ignite-log/my-first-node.log
Unrecognized option: --add-opens java.base/jdk.internal.misc=ALL-UNNAMED
Error: Could not create the Java Virtual Machine.
Error: A fatal exception has occurred. Program will exit.
{code}
 "	IGNITE	Resolved	1	1	2231	ignite-3
13572698	NextRowIdToBuild does not get cleared on rebalance	During a rebalance, partition storages and their indexes get cleaned up. However, {{nextRowIdToBuild}}-related logic used by all index implementations does not take this into account and does not remove the current value as well as doesn't reset the cached field. In addition, Page Memory-based index storages don't reset their index meta trees and can access destroyed trees after a rebalance.	IGNITE	Resolved	3	1	2231	ignite-3
13510090	Use Auto Service library to generate SPI files	We have a lot of Java SPI providers which have to manually be added to the META-INF folder. I think this is inconvenient and could be automated using the [Auto Service|https://github.com/google/auto/tree/main/service] library.	IGNITE	Resolved	3	3	2231	ignite-3
13482742	RocksDbSortedIndexStorageTest.testBoundsAndOrder is flaky	{{RocksDbSortedIndexStorageTest.testBoundsAndOrder}} test is flaky. The probable reason is that the internal comparator incorrectly compares tuple prefixes and regular tuples: a prefix can never be equal to a tuple, it must always be treated as a smaller value.	IGNITE	Resolved	2	1	2231	ignite-3
13389189	Design and implement the process of a node joining a cluster	The target of this epic is to design and implement a protocol for a node to join a cluster and exchange some information before being either allowed or prohibited from entering the topology.	IGNITE	Resolved	3	15	2231	ignite-3
13567716	PriorityQueueExecutorTest#testChangePriorityInTheMiddleExecution is flaky	"This test is flaky because of the following race. It tests the following scenario:

# Task 1 is submitted with priority 10;
# Task 2 is submitted with priority 5;
# Task 3 is submitted with priority 1;
# Task 4 is submitted with priority 5;
# Task 3 priority is changed to 20;
# The following execution order is expected: 1 - 3 - 2 - 4. 

The main caveat here that Task 1 will always be executed first, because it is the first task in the pool and will be dispatched on the first thread immediately, bypassing the queue. Therefore, with the current implementation there's the following race:
# Task 1 finishes executing;
# After that either Task 3 changes its priority and gets taken for execution, or
# Task 2 gets taken for execution, because Task 3 hasn't yet changed its priority."	IGNITE	Resolved	3	1	2231	ignite-3
13578559	ItClusterManagerTest#testJoinInvalidTag is flaky	Looks like there's a race in this test: after the cluster is restarted, the second node (which does not host the CMG) may be able to connect to the CMG leader and send a join request after the CMG group is started, but before the Cluster State is saved (which is done in a separate request).	IGNITE	Resolved	3	1	2231	ignite-3
13413224	Improve network processor error message	"When generation Network Message implementations, we use a special per-module class called a Message Group. When this class is not present, a corresponding error is thrown. However, when using IDEA, it is possible to get this error during the incremental compilation, because the Message Group class might not be passed to the annotation processor amongst the Network Message classes.

Current error message is not very descriptive and does not indicate, which package or module failed to compile. It is proposed to at least add package names of the processed elements. "	IGNITE	Resolved	5	3	2231	ignite-3
13548057	ClusterTimeTest#testSchedulerProlongation is flaky on TC	"{{org.apache.ignite.internal.metastorage.server.time.ClusterTimeTest.testSchedulerProlongation(MetaStorageConfiguration)}} fails sometimes on TC with the following error:

{noformat}
org.mockito.exceptions.verification.MoreThanAllowedActualInvocations:
Wanted at most 0 times but was 1
  at app//org.apache.ignite.internal.metastorage.server.time.ClusterTimeTest.testSchedulerProlongation(ClusterTimeTest.java:124)
{noformat}

I'm pretty sure that the problem is that the test relies on some tight timings (e.g. that no idle safe time has been propagated in 20 ms), which may be offset some events, such as GC pauses. This test should be refactored to avoid such timings."	IGNITE	Resolved	3	1	2231	ignite-3
13470143	Revisit SortedIndexMvStorage interface	"Currently, SortedIndexMvStorage is a very weird mixture of many things. Its contract is far from obvious and it's only used in tests as a part of ""reference implementation"".

Originally, it was implemented when the vision of MV store wasn't fully solidified.
h3. API changes
 * {{IndexRowEx}} should disappear. It was a quick and dirty solution. It should be replaced with {{{}InternalTuple{}}}, with the requirement that every internal tuple can be converted into a IEP-92 format.
 * {{scan}} should not return rows, but only indexed rows and RowId instances. Index scan should NOT by itself filter-out invalid rows, this will be performed outside of scan.
 * TxId / Timestamp parameters are no longer applicable, given that index does not perform rows validation.
 * Partition filter should be removed as well. To simplify things, every partition will be indexed {+}independently{+}.
 * {{supportsBackwardsScan}} and {{supportsIndexOnlyScan}} can be removed for now. Former can be brought back in the future, while latter makes no sense considering that indexes are not multiversioned.
 * new methods, like {{update}} and {{remove}} should be added to API.

h3. New API for removed functions
 * There should be a new entity on top of partition and index store. It updates indexes and filters scan queries. There's no point in fully designing it right now, all we need is working tests for now. Porting current tests to new API is up to a developer.

h3. Other

I would say that effective InternalTuple comparison is out of scope. We could just adapt current test code somehow."	IGNITE	Resolved	3	4	2231	ignite-3
13548787	Possible memory leak in StreamerBuffer	"I was running a stress test that simply inserted a lot of rows using {{RecordView#streamData}} method with the following options:

{code:java}
var options = DataStreamerOptions.builder()
        .perNodeParallelOperations(1)
        .batchSize(10_000)
        .autoFlushFrequency(100_000)
        .build();
{code}

After about 30 minutes I started getting Java OOM errors. Having inspected the heap dump, I found that all memory has been consumed by the Tuple instances that I have been inserting. The reason for that is the following:
# {{StreamerBuffer}} accumulates batches of data and then sends them to the server. If the server is slow for any reason, batch sending is placed into a ""queue"" by chaining {{flushFut}} one after another.
# {{StreamerSubscriber}} is the class that controls back-pressure. It uses two variables for this purpose: {{pendingItemCount}} which represents that amount of items, requested by the Subscriber, and {{inFlightItemCount}} which represents the amount of items being sent to the server. However, {{StreamerSubscriber}} does not know about the ""queue"" present in the {{StreamerBuffer}} and it increases the {{inFlightItemCount}} only when a particular flush future is being executed. This means that futures sitting in the ""queue"" do not contribute to the overall {{inFlightItemCount}} and {{StreamerSubscriber}} keeps requesting more items even though a lot of items are simply stuck in a different place."	IGNITE	Resolved	3	1	2231	ignite-3
13588606	CriticalWorkerWatchdog prints two stacktraces	"{{CriticalWorkerWatchdog}} monitors ""critical"" threads for being blocked and prints an error, if it finds a blocked thread. This error includes the current stacktrace of this thread. However, this error is then converted into an exception and is passed to the {{FailureHandler}}, which prints this error again, with the same stacktrace. This duplication must be removed. "	IGNITE	Resolved	3	1	2231	ignite-3
13505921	Add PeerId index support	JRaft has a planned support for running multiple peers on the same machine (on the same IP address): {{PeerID}} class has an {{idx}} field, which is not used anywhere, though. We need to update the code so that multiple peers running on the same node will have a different index and use this index to distinguish them internally.	IGNITE	Resolved	3	3	2231	ignite-3
13486336	Extract REST, Client and Compute configuration into corresponding modules	"This is part of the work related to removing configuration from the {{ignite-api}} module. The following configurations should be moved:

* Rest configuration to {{ignite-rest}}
* Client configuration to {{ignite-client-handler}}
* Compute configuration to {{ignite-compute}}"	IGNITE	Resolved	3	3	2231	ignite-3
13427130	Make RestModule handlers asynchronous	Request handlers in the RestModule are executed in a Netty thread, which may be an issue for long-running request handlers. It should be possible to execute these handlers on other threads.	IGNITE	Resolved	3	3	2231	ignite-3
13355203	IP Finder API	Create a service interface that provides the initial set of addresses of cluster members to a joining node. This service should provide an abstraction over multiple possible configuration mechanisms, like manual static configuration, Kubernetes service discovery, cloud environment, etc.	IGNITE	Resolved	3	3	2231	ignite-3
13511027	Move test messages interfaces back to proper directory	"org.apache.ignite.raft.server.counter.IncrementAndGetCommand and org.apache.ignite.raft.server.counter.GetValueCommand should belong to integration test directory, but that would break a compilation of Maven project.

Let's wait until Maven project is deleted and them move them."	IGNITE	Resolved	3	4	2231	ignite-3
13586782	Add the STORAGE_BROKEN error code	We need to have a public error code (in the STORAGE group) that would be used, at least, when we throw a CorruptedTreeException.	IGNITE	Resolved	3	4	2231	error-codes, ignite-3
13528423	Fix TODO mentioning IGNITE-16526	"ItClusterCommandTest#initClusterWithNodesOfDifferentRoles has the following TODO:

{code:java}
// TODO: when IGNITE-16526 is implemented, also check that the logical topology contains all 4 nodes
{code}

Since IGNITE-1652 is already closed, this TODO must be resolved."	IGNITE	Resolved	3	3	2231	ignite-3
13384140	Fix packet structure in network and network-processor modules	"{{network}} and {{network-processor}} modules violate the packet structure, defined in the Ignite project.

Expected: {{org.apache.ignite.internal.<bla-bla-bla>}}
Actual: {{org.apache.ignite.<bla-bla-bla>.internal}}"	IGNITE	Resolved	3	3	2231	ignite-3
13412026	Remove redundant property in maven-checkstyle-plugin configuration	"maven-checkstyle-plugin configuration in root {{pom.xml}} contains the following lines:

{code}
<execution>
    <id>fail-if-error</id>
    <phase>validate</phase>
    <configuration>
        <failsOnError>true</failsOnError>
        <consoleOutput>true</consoleOutput>
        <logViolationsToConsole>true</logViolationsToConsole>
    </configuration>
    <goals>
        <goal>checkstyle-aggregate</goal>
    </goals>
</execution>
{code}

However, {{logViolationsToConsole}} option is only applicable to the {{check}} goal, the {{checkstyle-aggregate}} goal does not have this property. It should be removed
"	IGNITE	Resolved	5	3	2231	ignite-3
13520936	ItJdbcJoinsSelfTest#testJoin is flaky	"ItJdbcJoinsSelfTest#testJoin sometimes failes with the following exception:

{noformat}
java.sql.SQLException: Exception while executing query [query=CREATE TABLE PUBLIC.BLOOD_GROUP_INFO_PJ (ID INT, BLOOD_GROUP VARCHAR(64), UNIVERSAL_DONOR VARCHAR(64), PRIMARY KEY (ID));]. Error message:IGN-CMN-65535 TraceId:59081ebb-c327-440b-9ddb-90cb61568f35 IGN-CMN-65535 TraceId:59081ebb-c327-440b-9ddb-90cb61568f35 Should not be called
{noformat}

For some reason, PK configuration gets updated twice, even though the data inside the configuration updates is the same."	IGNITE	Resolved	2	1	2231	ignite-3
13416569	Store all RocksDB partitions in a single column family.	"Current storage implementation puts each partition in its own column family. This effectively means that every partition lives in it's own database, sharing only WAL and some in-memory resources. Given that each column family has multiple files for LSM trees, the amount of opened file descriptors is bigger than it needs to be.

Now, the idea is to have a single column family for partitions within a table. And we should think of possibility of storing several tables in the same RocksDB instance, for similar reasons. You can think about is as of cache groups in Ignite 2.x.

There's also an ""optimization"" to be implemented that is missing in code - using key hashes as prefixes.
h3. What should be implemented:

First of all, code will be heavily refactored. This will lead to simplifications in many places.

Otherwise, I see the following list of goals to achieve:
 * current implementation allows to derive the list of partitions from the list of column families. This won't be possible, I suggest storing this list explicitly in ""meta"" CF, in any format that'll be convenient during the implementation
 * there should be a way of having compact ""tableId"" representation. IgniteUUID or even UUID is too much I think, but it might work as a basis. This problem should be discussed
 * binary representation for keys should now include following information:
 ** tableId - fixed-length set of bytes to be used as a prefix
 ** partitionId - 2 bytes that will follow the tableId. This layout will allow making range queries for specific partitions of specific tables
 ** key hash - 4 bytes. This one is required to optimize comparison time for keys. Generally speaking, it's safe to assume that hashes will be mostly different for different keys, meaning that hashes will be enough to determine keys inequality
 ** actual key payload goes after all these prefixes"	IGNITE	Resolved	3	4	2231	iep-74, ignite-3
13486376	Extract Table and Storage configuration into corresponding modules	"This is part of the work related to removing configuration from the ignite-api module. The following configurations should be moved:

* Table configuration to {{ignite-schema}}.
* Storage configuration to {{ignite-storage-api}}. However, this may currently be impossible, because Table configuration depends on the storage configuration, {{ignite-storage-api}} already depends on the {{ignite-schema}} module."	IGNITE	Resolved	3	3	2231	ignite-3
13414856	NamedListChange#createAfter should fail if called on a deleted key	"Given the following situation:
# There exists a {{NamedList x = [""foo"" -> ""bar"", ""baz"" -> ""quux""]}}
# Execute something like the following {{x.change(c -> c.delete(""foo"").insertAfter(""foo"", ...))}}. I.e. we are calling {{insertAfter}} on a key that has been deleted in the same change closure. 

Currently this code works without errors (effectively inserting a key before {{baz}}), which is inconsistent with all other methods of this class that will throw an exception instead. It is proposed to make this method fail as well"	IGNITE	Resolved	4	3	2231	ignite-3
13534660	Reduce write amplification for RocksDB partition storage	"Currently, the ""commit"" operation in rocksdb storage looks like this:
{code:java}
val data = db.read(writeIntentKey);
db.remove(writeIntentKey);
db.write(committedKey, data);{code}
This is wasteful, we end up writing everything twice. There's another solution, we may add a level of indirection to the data:
{code:java}
// RowId index.
[ TableId?? | PartId | RowId | Timestamp ] -> [ DataId ]
[ TableId?? | PartId | RowId ] -> [ DataId | TxId | CommitTableId | CommitPartId ]

// Data.
[ DataId ] -> [ Payload ]{code}
{{DataId}} must be unique. I don't like the idea of auto-incrementing key (we should always persist latest value), there must be another way.

The main idea is that DataId doesn't change while committing the data, meaning that it can be generated using RowId and TxId.

For example, {{RowId ++ beginTimestamp(TxId)}} seems like a unique value (with mandatory partition ID prefix and probably a table ID prefix)"	IGNITE	Resolved	3	4	2231	ignite-3
13555295	Move ClusterPerTestIntegrationTest and ClusterPerClassIntegrationTest to Test Fixtures	"We have two classes that are used to write integration tests that can start an Ignite cluster. I would propose two improvements regarding these classes:

# They are located in different packages (ClusterPerClassIntegrationTest is in the {{sql}} package for some reason). I suggest to move these classes together and unify their API.
# They are not part of the test API and other modules cannot access them. I suggest to move these two classes to Test Fixtures."	IGNITE	Resolved	3	4	2231	ignite-3
13426481	Incorporate the CMG manager into the node lifecycle	"After the CMG manager is introduced, the code around it should also be updated:
 # Node startup order should be altered in order for the CMG manager to work correctly.
 # All components after the CMG Manager should be started after the join procedure has finished successfully."	IGNITE	Resolved	3	3	2231	ignite-3
13380762	Support byte[] configuration values	"Right now ""smallest"" array type that we have is int[], it may not be convenient for some use-cases."	IGNITE	Resolved	3	7	2231	iep-55, ignite-3
13424362	Investigate possibility to remove sending by address in messaging service	ATM MessagingService can send messages not only using ClusterNode, but NetworkAddress. This allows RAFT to send messages to the nodes that are not in the cluster yet. Although it's convenient for RAFT server, the API is not very clean and this effectively separates raft from the cluster topology. We need to investigate the possibility to glue raft and cluster together	IGNITE	Resolved	3	3	2231	ignite-3
13410810	Make TableIndexConfigurationSchema polymorphic 	After introducing polymorphic configuration, it is now possible to split {{TableIndexConfigurationSchema}} into different sub-schemas based on the index type	IGNITE	Resolved	3	3	2231	ignite-3
13494314	Design the process of having a single storage for a follower and a learner on the same node	"Secondary Storage consistency is going to be implemented through the Raft Learners. However, there exists a challenge: what if a partition's Primary Storage will be assigned to the same node as its Secondary Storage? This means that both a follower and learner for the same partition will be hosted on a single node with the same consistent ID. Currently JRaft is not able to distinguish two nodes with the same consistent ID. There are two ways to solve this problem:

# Use {{PeerId#idx}} functionality. This is a built-in JRaft mechanism to have multiple Raft nodes on a single physical nodes.
# Use a single Raft node that will write into multiple storages. 

While option 1 is easy and straightforward to implement, this ticket focuses on investigation of the option 2. The second option has a priority because it is potentially more effective: since there will be less Raft nodes, there will be less network traffic. The main problem with this approach is when a learner or a follower hosted on such physical node gets moved to a different physical node (or two nodes get merged into one). We should check if this is technically possible to implement."	IGNITE	Resolved	3	3	2231	ignite-3
13545296	Ensure mockito resources cleaned after tests. 	"Tests must clean up inline mocks on tear-down.
Otherwise it may lead to OOM, see IGNITE-20065.

Let's add an arch-test to be sure all the test, which use mocks, inherits BaseIgniteAbstractTest class.
"	IGNITE	Resolved	3	6	2231	ignite-3, stability
13523779	Parallel Meta Storage Watch processing	"Currently Meta Storage Watches follow the given contract:

# All listeners are processed sequentially in the order that they have been registered;
# All listeners are processed in the same thread;
# All notifications are grouped by a particular revision. After all events for a particular revision get processed, all modified keys are persisted into the Vault.

Some components may rely on this to ensure that dependent components can observe the most recent component state, because they registered their Meta Storage listeners after the  component they depend on, therefore it is guaranteed that that component has already processed current Meta Storage revision. 

This approach can be improved in terms of performance by enabling concurrent Watch processing in multiple threads. In order to do that, we need to check and fix the following places:

# If a component depends on another component's state, this state must be extracted into a Versioned Value;
# If a component updates its state, relying on the fact, that this state is always updated in a single thread, concurrent primitives must be introduced to ensure thread safety;
# Check if it is possible to persist updated keys in the Vault individually, thus making it possible not to wait for all Watches for a particular revision to complete before starting to process updates belonging to the next revision. "	IGNITE	Resolved	3	3	2231	ignite-3
13484377	JRaft API should operate with Peers based on consistent ID 	When starting a Raft service, a list of peers is required, which are identified by host-port pairs. However, Ignite nodes are identified by their consistent IDs, which requires an intermediate step of resolving consistent IDs into addresses. This is problematic, because a particular node may be offline and, therefore, impossible to resolve. It is proposed to use peers that are based on consistent IDs instead and move the handling of offline nodes into the Raft infrastructure.	IGNITE	Resolved	1	3	2231	ignite-3
13569214	Unmute tests after index removal API is implemented	I've disabled some tests with a link pointing to this ticket. These tests must be unmuted after IGNITE-21574 and IGNITE-21583 are fixed	IGNITE	Resolved	3	4	2231	ignite-3
13573495	Remove RocksDB cache type support	{{RocksDbDataRegionConfigurationSchema}} allows to choose between two RocksDB cache types: {{LRU}} and {{Clock}}. However, {{Clock}} cache implementation has actually been removed from RocksDB and the new implementation, called {{HyperClock}} is still experimental. I suggest to remove the cache type feature for now, it serves no purpose and complicates the code.	IGNITE	Resolved	3	4	2231	ignite-3
13519723	Remove Meta Storage learner nodes when they leave Logical Topology	When a node joins the physical topology, it is automatically added as a Learner to the Meta Storage Raft group. We should also implement removing a node from the Raft group when it leaves. It is suggested to use Logical topology events for that to avoid event reordering and handle possible node re-connection more effectively.	IGNITE	Resolved	3	3	2231	ignite-3
13507233	Distribute CMG state using RAFT, not network messages	Currently, {{ClusterManagementGroupManager}} distributes cluster state in the cluster by sending it to each node in the cluster using {{{}MessagingService{}}}. After IGNITE-18261 it will become possible to distribute this state using normal RAFT mechanism.	IGNITE	Resolved	3	4	2231	ignite-3
13563433	Proper fix for IGNITE-21178	IGNITE-21178 was fixed in a sub optimal way: we need to use the node's clock instead of the latest catalog version, which will account for the delay duration on its own. Since some tests already do that, the current solution simply slowed them down by a 100 ms.	IGNITE	Resolved	3	4	2231	ignite-3
13530258	Remove parallel Watch processing	"Current implementation of Parallel Meta Storage Watches works as following:
# Every Watch has an associated unique ID and is processed independently from other Watches.
# After a Watch has finished processing an event, the processed revision and the Watch ID gets saved in the Vault.
# During recovery, a minimum processed revision is computed among all Watches and events are replayed, starting from that revision. If a Watch has already processed an event, it discards it.
 
This approach leads to a problem which can happen during recovery when interacting with the Configuration component:

# Imagine two Watches, one being the Watch registered by the Configuration component.
# One Watch has processed a revision 5, and the Configuration Watch has processed a revision 6. After that the node is stopped.
# When the node is started again, the recovery process kicks in and the Configuration component notifies its listeners about its current state as of revision 6. It means that components that are dependent on the Configuration component have indirectly observed the 6th revision and may have completed their Versioned Values, for example.
# After that, Meta Storage recovery starts and events get replayed. Events will start from revision 5 as it's the lowest processed revision. Now imagine that, during the replay, the first Watch needs to access a component's Versioned Value and will try to do that using revision 5. However, this Versioned Value will never have a value for this revision, since it has already been completed by the Configuration component with the revision 6.
 
Since I don't see viable solution to this problem, it is proposed to disable fully parallel Watch processing and require so that no Watches can process a new revision until all Watches have finished processing events from the previous revision. "	IGNITE	Resolved	3	3	2231	ignite-3
13502679	Update changePeersAsync method to support learners configuration	"Update {{RaftGroupService#changePeersAsync}} method to support changing learners configuration. It should work the same way, we simply need to update internal Raft configuration for learners as well as for peers. The new signature will look like the following: 

{code:java}
/**
 * @param peers New peers.
 * @param learners New leaners.
 * @param term Current known leader term.
 *             If real raft group term will be different - changePeers will be skipped.
 * @return A future.
 */
CompletableFuture<Void> changePeersAsync(List<Peer> peers, List<Peer> learners, long term);
{code}

This also implies changing the signature of {{RaftGroupEventsListener#onNewPeersConfigurationApplied}}:

{code:java}
/**
 * Invoked on the leader, when new peers' configuration applied to raft group.
 *
 * @param peers list of peers, which was applied by raft group membership configuration.
 * @param learners list of learners, which was applied by raft group membership configuration.
 */
void onNewPeersConfigurationApplied(List<PeerId> peers, List<PeerId> learners);
{code}
"	IGNITE	Resolved	3	3	2231	ignite-3
13596600	PartitionScanPublisher can reorder requests	"{{PartitionScanPublisher}} has several problems:

# Since every {{Subscription#request}} and {{Subscription#cancel}} requests are remote requests, there's no guarantee that the order of execution on the remote node will be the same. This can lead to peculiar situations like a Cursor being cancelled before it is registered (if ""cancel"" arrives faster than ""request""), or a Cursor being closed while still being iterated (if ""cancel"" and ""request"" are executed simultaneously).
# It is expected that all {{Subscriber}} callbacks are going to be strictly ordered. This is not true, because multiple {{request}} calls can get executed on different threads without HB relation.
# Some minute Flow contract details are not obeyed: {{onComplete}} and {{onError}} can be called even if the subscription was cancelled. {{onComplete}} can also be called after {{onError}}."	IGNITE	Resolved	3	1	2231	ignite-3
13580983	RestAPI get logical topology freeze if 1 node was replaced in 3 nodes cluster	"*Steps to reproduce:*
 # Create zone with replication equals to amount of nodes (2 or 3 corresponding)
 # Create 10 tables inside the zone.
 # Insert 100 rows in every table.
 # Await all tables*partitions*nodes local state is ""HEALTHY""
 # Await all tables*partitions*nodes global state is ""AVAILABLE""
 # Kill first node with kill -9.
 # Create new node and attach it to cluster instead of killed one.
 # Using REST API check physical topology until only 3 alive nodes will be in topology.
 # Using REST API check *logical* topology until only 3 alive nodes will be in topology.

*Expected:*

Data is returned.

*Actual:*
On the step 9 the request freeze and throws :
{code:java}
org.gridgain.ai3tests.core.generated.restapi.invoker.ApiException: Message: java.net.SocketTimeoutException: timeout
HTTP response code: 0
HTTP response body: null
HTTP response headers: null
    at org.gridgain.ai3tests.core.generated.restapi.invoker.ApiClient.execute(ApiClient.java:1047)
    at org.gridgain.ai3tests.core.generated.restapi.api.TopologyApi.logicalWithHttpInfo(TopologyApi.java:174)
    at org.gridgain.ai3tests.core.generated.restapi.api.TopologyApi.logical(TopologyApi.java:154)
    at org.gridgain.ai3tests.core.ignite.topology.TopologyUtils.getTopology(TopologyUtils.java:121)
    at org.gridgain.ai3tests.core.ignite.topology.TopologyUtils.lambda$waitForTopology$0(TopologyUtils.java:74)
    at org.gridgain.ai3tests.core.utils.RetryUtils.retryOnAllowedException(RetryUtils.java:40)
    at org.gridgain.ai3tests.core.ignite.topology.TopologyUtils.waitForTopology(TopologyUtils.java:72)
    at org.gridgain.ai3tests.core.ignite.topology.TopologyUtils.waitForLogicalTopology(TopologyUtils.java:56)
    at org.gridgain.ai3tests.tests.failover.ClusterFailover3NodesTest.killNodeAndReplaceWithNewEmptyOne(ClusterFailover3NodesTest.java:155)
    at java.base/java.lang.reflect.Method.invoke(Method.java:566)
    at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
    at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.net.SocketTimeoutException: timeout
    at okio.SocketAsyncTimeout.newTimeoutException(JvmOkio.kt:146)
    at okio.AsyncTimeout.access$newTimeoutException(AsyncTimeout.kt:161)
    at okio.AsyncTimeout$source$1.read(AsyncTimeout.kt:339)
    at okio.RealBufferedSource.indexOf(RealBufferedSource.kt:430)
    at okio.RealBufferedSource.readUtf8LineStrict(RealBufferedSource.kt:323)
    at okhttp3.internal.http1.HeadersReader.readLine(HeadersReader.kt:29)
    at okhttp3.internal.http1.Http1ExchangeCodec.readResponseHeaders(Http1ExchangeCodec.kt:180)
    at okhttp3.internal.connection.Exchange.readResponseHeaders(Exchange.kt:110)
    at okhttp3.internal.http.CallServerInterceptor.intercept(CallServerInterceptor.kt:93)
    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.kt:109)
    at org.gridgain.ai3tests.core.generated.restapi.invoker.ApiClient$2.intercept(ApiClient.java:1457)
    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.kt:109)
    at okhttp3.internal.connection.ConnectInterceptor.intercept(ConnectInterceptor.kt:34)
    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.kt:109)
    at okhttp3.internal.cache.CacheInterceptor.intercept(CacheInterceptor.kt:95)
    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.kt:109)
    at okhttp3.internal.http.BridgeInterceptor.intercept(BridgeInterceptor.kt:83)
    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.kt:109)
    at okhttp3.internal.http.RetryAndFollowUpInterceptor.intercept(RetryAndFollowUpInterceptor.kt:76)
    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.kt:109)
    at okhttp3.internal.connection.RealCall.getResponseWithInterceptorChain$okhttp(RealCall.kt:201)
    at okhttp3.internal.connection.RealCall.execute(RealCall.kt:154)
    at org.gridgain.ai3tests.core.generated.restapi.invoker.ApiClient.execute(ApiClient.java:1043)
    ... 13 more
Caused by: java.net.SocketTimeoutException: Read timed out
    at java.base/java.net.SocketInputStream.socketRead0(Native Method)
    at java.base/java.net.SocketInputStream.socketRead(SocketInputStream.java:115)
    at java.base/java.net.SocketInputStream.read(SocketInputStream.java:168)
    at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
    at okio.InputStreamSource.read(JvmOkio.kt:93)
    at okio.AsyncTimeout$source$1.read(AsyncTimeout.kt:128)
    ... 33 more
{code}
In the server logs continuous errors:
{code:java}
2024-05-30 10:51:37:069 +0200 [ERROR][%ClusterFailover3NodesTest_cluster_1%JRaft-StepDownTimer-9][AbstractClientService] Fail to connect ClusterFailover3NodesTest_cluster_0, exception: java.net.ConnectException.
2024-05-30 10:51:37:069 +0200 [ERROR][%ClusterFailover3NodesTest_cluster_1%JRaft-StepDownTimer-9][ReplicatorGroupImpl] Fail to check replicator connection to peer=ClusterFailover3NodesTest_cluster_0, replicatorType=Follower.
2024-05-30 10:51:37:069 +0200 [ERROR][%ClusterFailover3NodesTest_cluster_1%JRaft-StepDownTimer-15][AbstractClientService] Fail to connect ClusterFailover3NodesTest_cluster_0, exception: java.net.ConnectException.
2024-05-30 10:51:37:069 +0200 [ERROR][%ClusterFailover3NodesTest_cluster_1%JRaft-StepDownTimer-15][ReplicatorGroupImpl] Fail to check replicator connection to peer=ClusterFailover3NodesTest_cluster_0, replicatorType=Follower.
2024-05-30 10:51:37:069 +0200 [WARNING][%ClusterFailover3NodesTest_cluster_1%Raft-Group-Client-6][RaftGroupServiceImpl] Recoverable error during the request occurred (will be retried on the randomly selected node) [request=ReadActionRequestImpl [command=GetCommandImpl [key=[97, 115, 115, 105, 103, 110, 109, 101, 110, 116, 115, 46, 112, 101, 110, 100, 105, 110, 103, 46, 50, 54, 95, 112, 97, 114, 116, 95, 56], revision=-1], groupId=metastorage_group, readOnlySafe=true], peer=Peer [consistentId=ClusterFailover3NodesTest_cluster_0, idx=0], newPeer=Peer [consistentId=ClusterFailover3NodesTest_cluster_0, idx=0]].
java.util.concurrent.CompletionException: java.net.ConnectException: Peer ClusterFailover3NodesTest_cluster_0 is unavailable
  at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
  at java.base/java.util.concurrent.CompletableFuture.uniComposeStage(CompletableFuture.java:1099)
  at java.base/java.util.concurrent.CompletableFuture.thenCompose(CompletableFuture.java:2235)
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.sendWithRetry(RaftGroupServiceImpl.java:558)
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.lambda$handleThrowable$41(RaftGroupServiceImpl.java:605)
  at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
  at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
  at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
  at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
  at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
  at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.net.ConnectException: Peer ClusterFailover3NodesTest_cluster_0 is unavailable
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.resolvePeer(RaftGroupServiceImpl.java:806)
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.sendWithRetry(RaftGroupServiceImpl.java:557)
  ... 7 more
2024-05-30 10:51:37:069 +0200 [WARNING][%ClusterFailover3NodesTest_cluster_1%Raft-Group-Client-11][RaftGroupServiceImpl] Recoverable error during the request occurred (will be retried on the randomly selected node) [request=ReadActionRequestImpl [command=GetCommandImpl [key=[97, 115, 115, 105, 103, 110, 109, 101, 110, 116, 115, 46, 112, 101, 110, 100, 105, 110, 103, 46, 49, 56, 95, 112, 97, 114, 116, 95, 49, 48], revision=-1], groupId=metastorage_group, readOnlySafe=true], peer=Peer [consistentId=ClusterFailover3NodesTest_cluster_0, idx=0], newPeer=Peer [consistentId=ClusterFailover3NodesTest_cluster_0, idx=0]].
java.util.concurrent.CompletionException: java.net.ConnectException: Peer ClusterFailover3NodesTest_cluster_0 is unavailable
  at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
  at java.base/java.util.concurrent.CompletableFuture.uniComposeStage(CompletableFuture.java:1099)
  at java.base/java.util.concurrent.CompletableFuture.thenCompose(CompletableFuture.java:2235)
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.sendWithRetry(RaftGroupServiceImpl.java:558)
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.lambda$handleThrowable$41(RaftGroupServiceImpl.java:605)
  at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
  at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
  at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
  at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
  at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
  at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.net.ConnectException: Peer ClusterFailover3NodesTest_cluster_0 is unavailable
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.resolvePeer(RaftGroupServiceImpl.java:806)
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.sendWithRetry(RaftGroupServiceImpl.java:557)
  ... 7 more
{code}"	IGNITE	Resolved	3	1	2231	ignite-3
13398980	Improve network annotation processor error messages	"We should print a useful error message if there are multiple message groups in a single compilation unit. This is currently not the case, because we first verify the integrity of network messages, which can fail due to the same reason but with a less helpful message, for example:

{{apache-ignite-3/modules/network/src/test/java/org/apache/ignite/internal/network/AllTypesMessage.java:[30,8] Conflicting message types in a group, message with type 1 already exists}}"	IGNITE	Resolved	3	3	2231	ignite-3
13555936	Create a module for standalone utilities	"I think that we may need some place, where we could put standalone Java applications that can be useful during development and testing. An example of such utility can be an application that loads a given amount of random data into an Ignite node.

I propose to create a Gradle module called {{ignite-utilities}} and use it to store such applications."	IGNITE	Resolved	3	4	2231	ignite-3
13588689	Add message throttling to CriticalWorkerWatchdog	"{{CriticalWorkerWatchdog}} is responsible for monitoring some threads that are not intended to be blocked for long periods of time. However, if the system is in a bad state for some reason (e.g. memory is being consumed by other processes), this watchdog starts spamming with a lot of messages, which pollutes the log and makes later investigation more difficult. 

I propose to add an exponential throttling policy: if a thread has been blocked more than a configured amount of time and the message has been printed, the next check must be performed in an increased time interval comparing to the previous check. If no threads are blocked, then the check interval can be reset to its default value."	IGNITE	Open	3	4	2231	ignite-3
13594919	Properly handle EHOSTDOWN in RaftGroupServiceImpl	{{RaftGroupServiceImpl}} has a cached {{leader}} field. There can be a situation when the node which hosts the leader is being stopped and may return an error with the {{EHOSTDOWN}} code when a request is sent to it. This code is not handled correctly: we fail the original request, while instead we should retrieve the new leader and retry the request.	IGNITE	Resolved	3	4	2231	ignite-3
13578418	Nodes can miss ClusterStateMessages on start	"ClusterManagementGroupManager registers a message handler for ClusterStateMessages in its {{startAsync}} method. This approach can result in a race, when a ClusterStateMessage is missed, because it was received before the handler was registered. 

As a solution, we can register the handler in the constructor, but this handler should also wait for the ClusterManagementGroupManager to start before being able to process new messages."	IGNITE	Resolved	3	1	2231	ignite-3
13545228	Reduce the number threads used by Raft in tests	"After Kubernetes-based agents were enabled on TC, unit test builds started to fail with OOM errors. After having inspected the heap dump, we've discovered that Kubernetes agents report to have 64 cores in their processors. Since the number of cores influences the number of threads the Raft component creates, we ended up with having more than 500 Raft-related threads, which consumed all available memory.

As a quick solution to this problem, I propose to reduce the number of threads used by the Raft component, at least in tests."	IGNITE	Resolved	1	3	2231	ignite-3
13541040	Don't store BinaryRow as a single array	"Right now, binary row manipulations lead to garbage byte[] instances, because schema version is prepended as 4 bytes in the beginning of the array. This is absolutely unnecessary and there are no benefits to such approach.

Methods `org.apache.ignite.internal.schema.BinaryRow#bytes` / `org.apache.ignite.internal.schema.BinaryRow#byteBuffer` are a part of a very old design, we should revisit them, and hopefully remove them. This will affect serialization, but it's worth it imo."	IGNITE	Resolved	3	4	2231	ignite-3
13577161	Add busy lock to ClusterStateStorage	{{ClusterStateStorage}} is a full-blown IgniteComponent, but doesn't have a busy lock that will signal the users that the component has been stopped. 	IGNITE	Resolved	3	4	2231	ignite-3
13434850	Implement node validation	When a node joins a cluster, it should be both self-validated and fully validated on the CMG leader. This includes checking the protocol version, the Ignite product version and the cluster tag.	IGNITE	Resolved	3	3	2231	ignite-3
13392116	Null seems to be an unexpected result for  ScaleCubeMessagingService#invoke() on node stopping	"In case of node stop it's possible to get null as a result of an invoke operation.
{code:java}
return cluster
    .requestResponse(fromNetworkAddress(addr), message)
    .timeout(Duration.ofMillis(timeout))
    .toFuture()
    .thenApply(m -> m == null ? null : m.data()); // The result can be null on node stopping.
{code}
It's a rather confusing behavior that produces NPE. See IGNITE-15195 for more details. In order not not fail with NPE I've updated null handling in a following way
{code:java}
return cluster
    .requestResponse(fromNetworkAddress(addr), message)
    .timeout(Duration.ofMillis(timeout))
    .toFuture()
    .thenApply(m -> {
        if (m == null)
            throw new CompletionException(new NodeStoppingCheckedException());
        else
            return m.data();
    }); // The result can be null on node stopping.{code}
within IGNITE-15148 

In order to reproduce given issue restore original
{code:java}
.thenApply(m -> m == null ? null : m.data());
{code}
and run
{code:java}
 org.apache.ignite.internal.runner.app.IgnitionTest#testNodeStartWithoutBootstrapConfiguration{code}
several times.

As a result NPE will be logged on node stop:
{code:java}
SEVERE: Unexpected exception
class org.apache.ignite.lang.IgniteInternalException: java.lang.NullPointerException
	at org.apache.ignite.internal.metastorage.client.CursorImpl$InnerIterator.hasNext(CursorImpl.java:109)
	at org.apache.ignite.internal.metastorage.client.MetaStorageServiceImpl$WatchProcessor$Watcher.run(MetaStorageServiceImpl.java:446)
Caused by: java.util.concurrent.ExecutionException: java.lang.NullPointerException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1999)
	at org.apache.ignite.internal.metastorage.client.CursorImpl$InnerIterator.hasNext(CursorImpl.java:101)
	... 1 more
Caused by: java.lang.NullPointerException
	at org.apache.ignite.raft.client.service.impl.RaftGroupServiceImpl.lambda$run$15(RaftGroupServiceImpl.java:323)
	at java.base/java.util.concurrent.CompletableFuture$UniApply.tryFire(CompletableFuture.java:642)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
	at org.apache.ignite.raft.client.service.impl.RaftGroupServiceImpl$1.accept(RaftGroupServiceImpl.java:406)
	at org.apache.ignite.raft.client.service.impl.RaftGroupServiceImpl$1.accept(RaftGroupServiceImpl.java:360)
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
	at reactor.core.publisher.MonoToCompletableFuture.onComplete(MonoToCompletableFuture.java:83)
	at reactor.core.publisher.SerializedSubscriber.onComplete(SerializedSubscriber.java:146)
	at reactor.core.publisher.FluxTimeout$TimeoutMainSubscriber.onComplete(FluxTimeout.java:228)
	at reactor.core.publisher.MonoCreate$DefaultMonoSink.success(MonoCreate.java:129)
	at reactor.core.publisher.LambdaSubscriber.onComplete(LambdaSubscriber.java:132)
	at reactor.core.publisher.FluxTake$TakeFuseableSubscriber.onComplete(FluxTake.java:423)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.onComplete(FluxFilterFuseable.java:165)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onComplete(FluxFilterFuseable.java:384)
	at reactor.core.publisher.FluxOnBackpressureBuffer$BackpressureBufferSubscriber.checkTerminated(FluxOnBackpressureBuffer.java:416)
	at reactor.core.publisher.FluxOnBackpressureBuffer$BackpressureBufferSubscriber.drainRegular(FluxOnBackpressureBuffer.java:253)
	at reactor.core.publisher.FluxOnBackpressureBuffer$BackpressureBufferSubscriber.drain(FluxOnBackpressureBuffer.java:225)
	at reactor.core.publisher.FluxOnBackpressureBuffer$BackpressureBufferSubscriber.onComplete(FluxOnBackpressureBuffer.java:204)
	at reactor.core.publisher.DirectProcessor$DirectInner.onComplete(DirectProcessor.java:349)
	at reactor.core.publisher.DirectProcessor.onComplete(DirectProcessor.java:166)
	at reactor.core.publisher.FluxCreate$BaseSink.complete(FluxCreate.java:438)
	at reactor.core.publisher.FluxCreate$SerializedSink.drainLoop(FluxCreate.java:239)
	at reactor.core.publisher.FluxCreate$SerializedSink.drain(FluxCreate.java:205)
	at reactor.core.publisher.FluxCreate$SerializedSink.complete(FluxCreate.java:196)
	at org.apache.ignite.network.scalecube.ScaleCubeDirectMarshallerTransport.lambda$doStop$2(ScaleCubeDirectMarshallerTransport.java:134)
	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:44)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4219)
	at reactor.core.publisher.FluxConcatArray$ConcatArrayDelayErrorSubscriber.onComplete(FluxConcatArray.java:303)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:81)
	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:292)
	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:292)
	at reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber.onComplete(FluxPeekFuseable.java:931)
	at reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.onComplete(MonoSubscribeOn.java:160)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:81)
	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:292)
	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1783)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoCreate$DefaultMonoSink.success(MonoCreate.java:156)
	at io.scalecube.cluster.gossip.GossipProtocolImpl.doSpreadGossip(GossipProtocolImpl.java:177)
	at reactor.core.scheduler.PeriodicSchedulerTask.call(PeriodicSchedulerTask.java:49)
	at reactor.core.scheduler.PeriodicSchedulerTask.run(PeriodicSchedulerTask.java:63)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.runAndReset(FutureTask.java:305)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:305)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)

{code}"	IGNITE	Resolved	3	1	2231	iep-67, ignite-3
13562193	Tests involving Storage functionality fail on Volatile Storage Engine	"When IGNITE-21048 was implemented two more PRs (one for [Volatile Storage|https://github.com/apache/ignite-3/pull/2953], one for [RocksDB-based|https://github.com/apache/ignite-3/pull/2952]) were open to run existing tests against different Storage Engines.

Both of them hung.

In the first run for Volatile Storage at least two tests were identified that hang with AssertionError:
 * ItBuildIndexTest;
 * 
ItInternalTableTest.

Both tests have this assertion in logs:
{code:java}
    Caused by: java.lang.AssertionError
    at org.apache.ignite.internal.pagememory.tree.BplusTree$InitRoot.run(BplusTree.java:916) ~[main/:?]
    at org.apache.ignite.internal.pagememory.tree.BplusTree$InitRoot.run(BplusTree.java:896) ~[main/:?]
    at org.apache.ignite.internal.pagememory.util.PageHandler.writePage(PageHandler.java:298) ~[main/:?]
    at org.apache.ignite.internal.pagememory.datastructure.DataStructure.write(DataStructure.java:369) ~[main/:?]
    at org.apache.ignite.internal.pagememory.tree.BplusTree.initTree(BplusTree.java:1045) ~[main/:?]
    at org.apache.ignite.internal.storage.pagememory.mv.VersionChainTree.<init>(VersionChainTree.java:76) ~[main/:?]
    at org.apache.ignite.internal.storage.pagememory.VolatilePageMemoryTableStorage.createVersionChainTree(VolatilePageMemoryTableStorage.java:156) ~[main/:?]
    at org.apache.ignite.internal.storage.pagememory.VolatilePageMemoryTableStorage.createMvPartitionStorage(VolatilePageMemoryTableStorage.java:72) ~[main/:?]
    at org.apache.ignite.internal.storage.pagememory.VolatilePageMemoryTableStorage.createMvPartitionStorage(VolatilePageMemoryTableStorage.java:40) ~[main/:?]
    at org.apache.ignite.internal.storage.pagememory.AbstractPageMemoryTableStorage.lambda$createMvPartition$4(AbstractPageMemoryTableStorage.java:164) ~[main/:?]
    at org.apache.ignite.internal.storage.util.MvPartitionStorages.lambda$create$1(MvPartitionStorages.java:121) ~[main/:?]
    at java.util.concurrent.CompletableFuture.uniApplyNow(CompletableFuture.java:680) ~[?:?]
    ... 39 more {code}
This behavior can be reproduced locally with 100% fail rate.

 "	IGNITE	Resolved	1	1	2231	ignite-3
13571281	Extract volatile state in AbstractPageMemoryMvPartitionStorage into a separate class	"{{AbstractPageMemoryMvPartitionStorage}} contains a bunch of volatile fields that get replaced during a rebalance cleanup. I propose to wrap this fields in a single class in order to make the code a little bit more maintainable. I see the following benefits:

# It will become easy to understand, what components of the storage may be updated;
# It will be easier to add more volatile components and not forget to update them;
# It will become easier to avoid unnecessary volatile reads, because the whole state can be fetched using a single read.
 
The only downside I can see is that the code may become a little bit more verbose, because you will need to access the state class first."	IGNITE	Resolved	4	4	2231	ignite-3
13484445	AbstractSortedIndexStorage test is flaky	AbstractSortedIndexStorage uses a random string as a name for the test sorted index storage. This can lead to unsupported index names being generated.	IGNITE	Resolved	5	3	2231	ignite-3
13578591	ItClusterManagerTest refactoring	This test and code around it is old and can be updated to be shorter and more concise.	IGNITE	Resolved	3	4	2231	ignite-3
13569364	Implement API for dropping PageMemory indexes	This task is identical to IGNITE-21574, but this time it should be implemented on the Page Memory's side.	IGNITE	Resolved	3	4	2231	ignite-3
13556708	ItConnectionManagerTest#testShutdown is flaky	"Sometimes this test fails with the following exception:

{code:java}
java.util.concurrent.ExecutionException: org.apache.ignite.internal.network.handshake.ChannelAlreadyExistsException

	at org.apache.ignite.internal.future.OrderingFuture.exceptionForThrowingFromGet(OrderingFuture.java:450)
	at org.apache.ignite.internal.future.OrderingFuture.get(OrderingFuture.java:437)
	at org.apache.ignite.internal.network.netty.ItConnectionManagerTest.testShutdown(ItConnectionManagerTest.java:190)
	at jdk.internal.reflect.GeneratedMethodAccessor14.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:727)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:156)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:147)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:86)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(InterceptingExecutableInvoker.java:103)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.lambda$invoke$0(InterceptingExecutableInvoker.java:93)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:92)
	at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:86)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:217)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:213)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:138)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:147)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:127)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:90)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:55)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:102)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:54)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86)
	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86)
	at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53)
	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:57)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38)
	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:30)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:232)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)
Caused by: org.apache.ignite.internal.network.handshake.ChannelAlreadyExistsException
	at org.apache.ignite.internal.network.recovery.RecoveryClientHandshakeManager.onHandshakeStartMessage(RecoveryClientHandshakeManager.java:254)
	at org.apache.ignite.internal.network.recovery.RecoveryClientHandshakeManager.onMessage(RecoveryClientHandshakeManager.java:156)
	at org.apache.ignite.internal.network.netty.HandshakeHandler.channelRead(HandshakeHandler.java:92)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:840)
{code}
"	IGNITE	Resolved	1	1	2231	ignite-3
13513227	Remove RaftManager#prepareRaftGroup method	{{RaftManager#prepareRaftGroup}} method does two things: starts a Raft service and, optionally, starts a Raft node. We already have two separate methods that do these things: {{startRaftNode}} and {{startRaftService}}. We should remove {{prepareRaftGroup}} method and replace it with these two methods.	IGNITE	Resolved	4	4	2231	ignite-3
13399550	Integrate RocksDBKeyValueStorage into the production code	Persistent storage for the MetaStorage has been introduced in IGNITE-14982, but it hasn't been integrated into the production code, SimpleInMemoryKeyValueStorage is still used instead and should be replaced.	IGNITE	Resolved	3	3	2231	ignite-3
13542705	NodeStoppingException upon stopping an embedded Ignite node	"See the attached reproducer.

Steps:
 - Start an embedded Ignite node.
 - Create a table via key-vaue: 11 columns of type VARCHAR
 - Insert 10 sample rows
 - Stop the node via {{IgnitionManager#stop}}

Expected result:
No exceptions in the node's log

Actual result:
The following exception is seen:
{noformat}
Caused by: org.apache.ignite.lang.NodeStoppingException: IGN-CMN-1 TraceId:65d933f8-94bd-41e6-928d-7defcf52744c Operation has been cancelled (node is stopping).
        at org.apache.ignite.network.DefaultMessagingService.invoke0(DefaultMessagingService.java:227)
        at org.apache.ignite.network.DefaultMessagingService.invoke(DefaultMessagingService.java:159)
        at org.apache.ignite.network.MessagingService.invoke(MessagingService.java:145)
        at org.apache.ignite.internal.raft.client.TopologyAwareRaftGroupService.sendWithRetry(TopologyAwareRaftGroupService.java:211)
        at org.apache.ignite.internal.raft.client.TopologyAwareRaftGroupService.sendSubscribeMessage(TopologyAwareRaftGroupService.java:197)
        at org.apache.ignite.internal.raft.client.TopologyAwareRaftGroupService.unsubscribeLeader(TopologyAwareRaftGroupService.java:329)
        at org.apache.ignite.internal.replicator.Replica.shutdown(Replica.java:278)
        at java.base/java.util.concurrent.CompletableFuture.uniComposeStage(CompletableFuture.java:1106)
        at java.base/java.util.concurrent.CompletableFuture.thenCompose(CompletableFuture.java:2235)
        at org.apache.ignite.internal.replicator.ReplicaManager.stopReplicaInternal(ReplicaManager.java:410)
        at org.apache.ignite.internal.replicator.ReplicaManager.stopReplica(ReplicaManager.java:385)
        at org.apache.ignite.internal.table.distributed.TableManager.lambda$cleanUpTablesResources$30(TableManager.java:1093)
        at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
        at org.apache.ignite.internal.table.distributed.TableManager.cleanUpTablesResources(TableManager.java:1119)
        at org.apache.ignite.internal.table.distributed.TableManager.stop(TableManager.java:1045)
        at org.apache.ignite.internal.app.LifecycleManager.lambda$stopAllComponents$1(LifecycleManager.java:133)
        at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
        at org.apache.ignite.internal.app.LifecycleManager.stopAllComponents(LifecycleManager.java:131)
        at org.apache.ignite.internal.app.LifecycleManager.stopNode(LifecycleManager.java:115)
        at org.apache.ignite.internal.app.IgniteImpl.stop(IgniteImpl.java:807)
        at org.apache.ignite.internal.app.IgnitionImpl.lambda$stop$0(IgnitionImpl.java:109)
        at java.base/java.util.concurrent.ConcurrentHashMap.computeIfPresent(ConcurrentHashMap.java:1822)
        at org.apache.ignite.internal.app.IgnitionImpl.stop(IgnitionImpl.java:108)
        at org.apache.ignite.IgnitionManager.stop(IgnitionManager.java:96)
        at org.apache.ignite.IgnitionManager.stop(IgnitionManager.java:82)
        at org.apache.ignite.example.AbstractExamplesTest.stopNode(AbstractExamplesTest.java:76)
{noformat}
{{git bisect}} says that the following commit introduced the bug (belongs to IGNITE-19199):
{noformat}
b6004047b3c3e9cd91b5ccf28c26ee206c1e3a7f is the first bad commit
{noformat}"	IGNITE	Resolved	3	1	2231	ignite-3
13562316	Wait for completion of transactions started before an index drop	"When an index switches to the STOPPING state, a waiter (IGNITE-21112) should be started (analogously to the waiter used when waiting in the REGISTERED state, see IGNITE-21115).

After it finishes waiting, the index should be switched to the READ_ONLY state."	IGNITE	Resolved	3	4	2231	ignite-3
13567698	"Cannot run tests JDK 17 due to missing ""add-opens"" flags"	IGNITE-21446 introduced a {{jvmArgs}} variable to the {{build.gradle}} file. However, this variable hides the {{jvmArgs}} property of the {{Test}} Gradle task, which makes it impossible to propagate the value of this variable to the tests run by Gradle.	IGNITE	Resolved	1	1	2231	ignite-3
13482935	Race condition in the CMG Manager	CMG Manager's {{clusterState}} method is incorrect: {{raftService}} access must always be wrapped in the associated lock. 	IGNITE	Resolved	3	1	2231	ignite-3
13570803	Remove destroyed PageMemory indexes on recovery	"When {{AbstractPageMemoryMvPartitionStorage}} is started, we need to perform the following recovery actions:

# Scan the index meta tree;
# Check the observable Catalog history (i.e. up to the LWM value);
# If an index is present in the meta tree, but not in the Catalog - destroy it. "	IGNITE	Resolved	3	4	2231	ignite-3
13573709	SharedRocksDbInstance#sortedIndexes method is not thread-safe	It is possible to obtain a {{ConcurrentModificationException}} when calling {{SharedRocksDbInstance#sortedIndexes}}, because it performs a scan over a non-concurrent map that can actually be concurrently modified.	IGNITE	Resolved	1	1	2231	ignite-3
13383121	Define a mechanism for exchanging discovery metadata	"When a node joins a cluster it needs to send and receive some discovery metadata, for example:
 # A node might need to provide some credentials and/or some of its configuration values in order to be validated against the state of the cluster.
 # A node might need to obtain some information about the cluster when accepted into the topology, e.g. addresses of the nodes that host the metastorage.

We should develop a mechanism for both sending and receiving some data before a node is accepted into the topology. As a proof of concept it will be enough to receive information about the nodes hosting the metastorage.

As part of the task an IEP-77 was prepared, linked to the ticket below."	IGNITE	Resolved	3	3	2231	ignite-3
13560358	Enhance CompletableFutureExceptionMatcher API	It would be nice if {{CompletableFutureExceptionMatcher}} accepted a {{Matcher}} for inspecting the error messages of exceptions. 	IGNITE	Resolved	3	4	2231	ignite-3
13522935	Make Meta Storage Entry serializable	Meta Storage server methods can return {{Entry}} instances as well as {{List<Entry>}} collections. Currently these responses are wrapped into {{SingleEntryResponse}} and {{MultipleEntryResponse}} which simply copy the provided entries. This step can be avoided if we make {{Entry}} serializable directly.	IGNITE	Resolved	4	4	2231	ignite-3
13547677	Introduce a Matcher for BinaryRows	"In tests we often need to compare two given BinaryRows. Unfortunately, we cannot use {{equals}} and, as a consequence, {{assertEquals}}, because {{BinaryRow}} has two implemenations: {{Row}} and {{BinaryRowImpl}} which are used interchangeably. 

To solve this problem, it is proposed to add a Hamcrest Matcher, that will allow to compare two {{BinaryRows}} regardless of their implementation."	IGNITE	Resolved	4	3	2231	ignite-3
13535736	Blacklist for non-marshallable classes	"Following IGNITE-19451, we should ban classes like BinaryTuple, BinaryTuplePrefix, from being declared as marshallable. Blacklist mechanism is proposed.

We could also include classes like List/Collection into it, or even Object. Natively marshallable classes like UUID must be banned as well.

I'd go as far as banning boxed primitives, but they lack native support, so it's up to a developer."	IGNITE	Resolved	3	4	2231	ignite-3
13372746	Fix javadoc in Network module.	"After IGNITE-13751 had been merged, Javadoc suite failed on TC due to lack of javadocs.
 Let's fix ""warnings"" that is related to Network module.

Startpoint is to run javadoc goal for the apache-ignite project:
{code:java}
mvn javadoc:javadoc
{code}"	IGNITE	Resolved	3	1	2231	ignite-3
13428279	Update IDEA settings	"# Remove obsolete files;
 # Update code style (e.g. remove indents on empty lines);
 # Update inspections to the latest settings."	IGNITE	Resolved	5	3	2231	ignite-3
13513230	ItIgniteInMemoryNodeRestartTest does not start an in-memory nodes	For some reason {{ItIgniteInMemoryNodeRestartTest}} does not provide an in-memory configuration for its storage, so this test does not test what it should.	IGNITE	Resolved	4	3	2231	ignite-3
13505710	Use a class instead of IgniteBiTuple as a response to TxStateReplicaRequest	A lot of responses in {{PartitionReplicaListener}} are expressed as {{IgniteBiTuple}}. This makes the code hard to read, hard to modify and inconvenient to use. This ticket focuses on replacing one of these tuples (sent in response to a {{TxStateReplicaRequest}}) with a named class, let's call it {{LeaderOrTxState}}.	IGNITE	Resolved	3	3	2231	ignite-3
13378309	Create an annotation processor for generating network message implementations	"Currently all {{NetworkMessage}} implementations are created by hand which is inconvenient (e.g. one needs to declare constructors and getters). It is proposed to automatically generate these implementations using an annotation processor.

h3. Implementation details

 * Custom messages should be declared as interfaces extending {{NetworkMessage}}. Methods in these interfaces should correspond to the message fields, for example:

{code:java}
@Message(type = ACTION_REQUEST)
public interface ActionRequest extends NetworkMessage {
    String groupId();
    Command command();
}
{code}

* Every message interface should be annotated with the {{@Message}} interface, with a *message type* parameter of type {{short}}, unique across a *module*. All message types should be manually listed in an interface marked with the {{@MessageTypes}} annotation with a *module identifier*. For example:

{code:java}
@MessageTypes(moduleType = 10)
class RaftMessageTypes {
    public final short ACTION_REQUEST = 1;
}
{code}

 * Message implementations should have a generated {{Builder}} interface for creating new messages:

{code:java}
public interface Builder {
    Builder command(Command cmd);
    Builder groupId(String groupId);
    ActionRequest build();
}
{code}

* {{Builder}} instances should be obtained using a generated factory, based on the current module type:

{code:java}
public interface RaftClientMessageFactory {
    ActionRequestBuilder actionRequest();
    ActionResponseBuilder actionResponse();
// ...
}
{code}


"	IGNITE	Resolved	4	7	2231	ignite-3
13487254	Fix basic Learners functionality	"We need to investigate the current state of the Learners functionality. I propose a simple test to verify that they work correctly:

1. Start a raft group on one node.
2. Start a learner on the second node.
3. Issue a write command to the leader.
4. Check that the command has been replicated to the learner."	IGNITE	Resolved	3	3	2231	ignite-3
13438618	Use unsigned byte comparison in test storages	Ignite 3 uses `ByteArray` class as keys for its test storages (like `InMemoryVaultService`). This is inconsistent with RocksDB-based storages since RocksDB uses unsigned byte comparison, while `ByteArray` uses signed byte comparison.	IGNITE	Open	4	1	2231	ignite-3
13547521	Get rid of configurations in PlacementDriverManager	"During the implementation of IGNITE-20114, it was found that the *org.apache.ignite.internal.placementdriver.PlacementDriverManager* does not use the configuration that is passed to it, you need to get rid of it.

We can also improve the code next to it and the tests associated with it."	IGNITE	Resolved	3	4	6308	ignite-3
13589739	Get rid of CatalogTableDescriptor#creationToken	Found an unused field *org.apache.ignite.internal.catalog.descriptors.CatalogTableDescriptor#creationToken* that needs to be removed to implement the metastorage compaction trigger.	IGNITE	Resolved	3	4	6308	ignite-3
13468800	Get rid of the index partition	"Since indexes will be stored in partition files, index partitions should be disposed of in the current codebase.

See:
* *org.apache.ignite.internal.pagememory.persistence.store.PageStore#TYPE_IDX*
* *org.apache.ignite.internal.pagememory.PageIdAllocator#INDEX_PARTITION*
* *org.apache.ignite.internal.pagememory.persistence.store.GroupPageStoreHolder*
* *org.apache.ignite.internal.pagememory.persistence.store.FilePageStoreManager#INDEX_FILE_NAME*

It will also be useful to correct the flaky [FilePageStoreManagerTest#testStopAllGroupFilePageStores|https://ci.ignite.apache.org/test/6999203413272911470?currentProjectId=ignite3_Test&branch=%3Cdefault%3E]."	IGNITE	Resolved	3	4	6308	ignite-3
13592025	Write retry pages by multiple threads at checkpoint	"I found that in *org.apache.ignite.internal.pagememory.persistence.checkpoint.CheckpointPagesWriter* we write the retry pages with one thread (which filled them), which may be a bit inefficient. 
We can write these pages in parallel with several threads, for example, put them in some concurrent queue in pairs <PersistentPageMemery, List<FullPageId>> and each thread would write the pages in parallel."	IGNITE	Open	3	4	6308	ignite-3
13519924	Modify getOrCreateMvPartition and getMvPartition of MvTableStorage to return the future	"We need to make *MvTableStorage#getOrCreateMvPartition* and *MvTableStorage#getMvPartition* return the *CompletableFuture<MvPartitionStorage>*.

Since, for example, we need to wait for the partition to be deleted before creating / recreating it."	IGNITE	Resolved	3	3	6308	ignite-3
13327029	Fixing some unrecorded issues command warm-up control.sh	"Unrecorded problems:
* When parsing arguments for the warm-up command, subsequent arguments may be skipped, such as auto-confirmation ""--yes"";
* Processing requests for jetty;
* Authorization."	IGNITE	Resolved	3	1	6308	2.9.1-rc, IEP-40
13590135	Fix flaky ItIndexNodeFinishedRwTransactionsCheckerTest#testOnePhaseCommitViaKeyValue	"Need to fix flaky *org.apache.ignite.internal.index.ItIndexNodeFinishedRwTransactionsCheckerTest#testOnePhaseCommitViaKeyValue*, [here|https://ci.ignite.apache.org/viewLog.html?buildId=8425127&buildTypeId=ApacheIgnite3xGradle_Test_RunAllTests&fromSakuraUI=true] is its first fail.

Reason for fail: waiting for *org.apache.ignite.internal.table.distributed.raft.PartitionListener#handleUpdateCommand* to be executed but *org.apache.ignite.internal.table.distributed.raft.PartitionListener#handlePrimaryReplicaChangeCommand* was called."	IGNITE	Resolved	3	1	6308	ignite-3
13548367	Check and slightly refactor the validation of tables in the catalog	"We need to make sure that all validation for tables is present in the catalog.

Slightly refactor the code related to validation, for example, move validation methods to *CatalogParamsValidationUtils* and tests related to it in *CatalogManagerValidationTest*."	IGNITE	Resolved	3	4	6308	ignite-3
13583270	Synchronous message handling on local node	"{{org.apache.ignite.internal.network.DefaultMessagingService#isSelf}} - if we detect that we send a message to the local node, we handle it immediately in the same thread, which could be very bad for throughput of the system.

""send""/""invoke"" themselves appear to be slow as well, we should benchmark them. We should remove instantiation of InetSocketAddress for sure, if it's possible, it takes time to resolve it. Maybe we should create it unresolved or just cache it like in Ignite 2."	IGNITE	Resolved	3	1	6308	ignite-3, ignite3_performance
13325866	NPE in logSupplierDone(UUID nodeId)	"NPE in logSupplierDone(UUID nodeId)

{noformat}
[2020-08-30 18:06:52,360][ERROR][rebalance-#5033%new-version-node%][root] Critical system error detected. Will be handled accordingly to configured handler [hnd=StopNodeOrHaltFailureHandler [tryStop=false, timeout=0, super=AbstractFailureHandler [ignoredFailureTypes=UnmodifiableSet [SYSTEM_WORKER_BLOCKED, SYSTEM_CRITICAL_OPERATION_TIMEOUT]]], failureCtx=FailureContext [type=CRITICAL_ERROR, err=java.lang.NullPointerException]]
 java.lang.NullPointerException
 	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionDemander$RebalanceFuture.logSupplierDone(GridDhtPartitionDemander.java:2009)
 	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionDemander$RebalanceFuture.partitionDone(GridDhtPartitionDemander.java:1730)
 	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionDemander$RebalanceFuture.access$1200(GridDhtPartitionDemander.java:1142)
 	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionDemander.ownPartition(GridDhtPartitionDemander.java:751)
 	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionDemander.handleSupplyMessage(GridDhtPartitionDemander.java:649)
 	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPreloader.lambda$handleSupplyMessage$0(GridDhtPreloader.java:356)
 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
 	at java.lang.Thread.run(Thread.java:748)
{noformat}"	IGNITE	Resolved	3	1	6308	2.9.1-rc
13387088	Support internal/private properties in configuration framework	"In order to provide consistent update of configuration and metastorage metadata  we should have configuration values that are hidden form the user.

Requirements are:
 * these configuration values should be available from internal code only
 * they should not be accessible in JSON or any other configuration view representation
 * they can't be updated via CLI's HOCON update requests or any other public API calls

One possible solution is to have configuration schema extensions, registered in ""internal"" modules - they'll lead to generation of extended VIEW and CHANGE interfaces. All extra fields from these schemas will be marked as internal by configuration framework, technically it is possible.
h3. API notes

I think it would be convenient to have explicit internal configuration extensions like these:
{code:java}
@InternalConfigurationExtension
public class ExtendedConfigurationSchema extends PublicConfigurationSchema {
    // fields
}{code}
 There has to be some ""extension descriptor"", like a ""RootKey"", that should be passed into configuration manager constructor (or registered in it by some other means before component's start). It should have at least the information about the schema that it extends.

Following restriction has to be applied:
 * There cannot be multiple extensions for the same schema. It is possible to avoid this restriction but it would lead to unnecessary complications (like in polymorphic schemas, that would probably complicate such approach even more: IGNITE-14645).

There's also no point in having extension in the same module. Maybe we should validate this fact.

Every {{FooConfiguration}} object must in fact be an instance of {{InternalFooConfiguration}} as well. Same applies to {{*View}} and {{*Change}} interfaces. There's no way that it's possible to design API where its user won't have to perform explicit type casts, so this solution looks fine.
h3. Implementation notes

First of all, annotation processor will be expanded. I suppose that {{@InternalConfigurationExtension}} will be the only addition to public configuration-api module, everything else will be hidden in implementation packages.

Traversal / construction API will be expanded as well. I guess that adding a {{internal}} flag to a bunch of method will be enough. Having two sets of methods for {{all}} and {{public}} would just be too much.

After these methods are changed, {{ConfigurationAsmGenerator}} and a lot of their usages will have to be fixed. I suspect that most changes will be here and in tests."	IGNITE	Resolved	3	3	6308	iep-55, ignite-3
13537324	Switch distribution zone IDs from UUID to int	"Currently, as zones are stored as named list items in the Configuration, they are internally (to the configuration) identified by UUIDs. The same UUIDs are also used to identify zones in the whole system.

We need to change the latter: that is, in addition to the internal IDs (needed only for configuration), we need to generate integer IDs and use them in the rest of the system to identify zones.

For now, zone IDs should be generated using same global counter that will be used to generate table and index IDs.

Internal IDs will remain until we switch from storing tables/indices/zones in the Configuration to storing them in the Catalog (this is out of scope of this task)."	IGNITE	Resolved	3	4	6308	ignite-3
13410563	Fix the code style javadocs issues for the modules #1	"Fix the code style javadocs issues for the modules:
* modules/configuration
* modules/network-api
* modules/network-annotation-processor
* modules/network
* modules/rocksdb-common
* modules/storage-api
* modules/storage-rocksdb
* modules/storage-table
* modules/core
* modules/client
* modules/api
* examples

How to reproduce:
* Uncomment everything in *check-rules/checkstyle-rules.xml*;
* Run: *mvn validate -Pcheckstyle -Dmaven.all-checks.skip*."	IGNITE	Resolved	3	4	6308	ignite-3
13438540	Deal with some TODOs	It is necessary to fix the TODOs with the indicated closes tickets IGNITE-16548 and IGNITE-16280.	IGNITE	Resolved	3	1	6308	ignite-3
13595827	Add an asynchronous compaction method to the KeyValueStorage	"We need to add a method to *org.apache.ignite.internal.metastorage.server.KeyValueStorage* that will perform steps 4.1 - 4.7 from IGNITE-23293.

Algorithm:
# If the storage is in the recovery state, then we set a new compaction revision (*KeyValueStorage#setCompactionRevision*) and complete the method.
2. Otherwise, adds a new task (A) to the WatcheEvent queue and complete the method.
3. Task (A) sets a new compaction revision (*KeyValueStorage#setCompactionRevision*) and adds a new task (B) to the compaction thread pool and completes.
4. Task (B) collects all read operations for a revision less than the new one and asynchronously begins to wait for their completion and starts a local compaction (*KeyValueStorage#compact*).
5. After the compaction is complete, notifies about its completion."	IGNITE	Resolved	3	4	6308	ignite-3
13527217	Possible race between updating a low watermark and processing the last batch for storage in a background GC	"After some analysis of the background garbage collector code, a possible race was found between updating the low watermark and processing the last batch of storage.
Needs to be fixed."	IGNITE	Resolved	3	1	6308	ignite-3
13545727	Write to writable indices when writing to partition	"*{color:#DE350B}See comments{color}*

For each operation that is writing, the operation’s timestamp (which is NOT the same as the operation’s command’s SafeTime timestamp) T~op~ is used to get the schema corresponding to the operation. When it’s obtained, all writable indices at T~op~ are taken, and the current operation writes to them all.

An index is writable for an RW transaction started at T~begin~ if the index exists in a writable state (REGISTERED, BACKFILLING, AVAILABLE, STOPPING) in the schema corresponding to T~begin~, but writability is lost once the index transitions to the READ_ONLY state (in the CURRENT schema).

If an index does not exist anymore at T~op~, the write to it is just ignored, the transaction is not aborted.
"	IGNITE	Resolved	3	4	6308	ignite-3
13593618	Add interface MetaStorageCompactionManager	Currently, methods related to metastorage compaction are added to *org.apache.ignite.internal.metastorage.MetaStorageManager*, which looks wrong since this interface is used to read and update metastorage and clients of this interface do not need to see methods related to compaction, so I propose to introduce a new *org.apache.ignite.internal.metastorage.MetaStorageCompactionManager* and add methods there.	IGNITE	Resolved	3	4	6308	ignite-3
13492388	Download RAFT snapshot without deleting original partition data	"h3. Note

This is an umbrella issue. It's split into several smaller issues.
{color:red}See the first comment, it indicates how we end up doing a full rebalancing.{color}
h3. Description

In first design, full rebalance is implemented this way:
 * we drop partition data
 * we download partition data from the leader
 * we're done

There's a problem with this approach - if download part failed, we lost one follower. This is bad, because technically new leader may have more data in the log and it could have uploaded it the follower, but now it makes no sense.

Not only can it lead to hard-to-catch errors and introducing custom work-around code to JRaft, it's also an unconditional data deletion without neither explicit  user approval nor a copy of the data preserved durably.

Such implementation is fine for POC and some tests, but it cannot be allowed in the release version of the product.
h3. New proposed solution

As trivial as it may seem, new solution is to _not deleting data_ before snapshot is fully downloaded and ready for swap. Why is it trivial? Because this is literally what RAFT demands to be done.

Of course, there's a {*}but{*}. Snapshot application, when it's downloaded, should be {{O(1)}} when it comes to the number of rows in the partition and a number of transactions in a tx state store. This may not be fully achievable, depending on the implementation that we chose, more on that later.

Following sections will describe all my concerns and possible implementations. Some sections can be skipped while reading. For example, if you're not interested in a specific storage engine, but want to read everything else.
h3. TX state storage

There's one really good thing about TX state storage. It has no storage engine, there's only a single RocksDB-based implementation. This makes possible the following approach:
 * when we stream data, we can write it into a SST file, almost like in snapshots of meta-storage and CMG storages
 * once snapshot is downloaded, we ingest it into a storage

What I like about this solution is that it's very simple. But, there are concerns:
 * ingesting leads to additional implicit data flush. Maybe it can be avoided, more on that later
 * it's not clear whether RocksDB creates a copy of SST file or not. I would assume that it does, because the file might be in other folder or on another device, for example. Although copying files is fast, it still takes time. Add to this a time required for the flush and we see a problem - operation may become unnecessarily long

For these reasons, I don't think that such solution should be implemented. The point of this description was to show, that I thought about this alternative and consciously decided to use another one.

I believe that TX state storage should use the same approach as a RocksDB-based partition storage. Its description can be found later in this issue.
h3. MV storage - Test engine

Test uses concurrent skip-list map for MV data and a bunch of other maps for indexes. While snapshots is being downloaded, we should insert all data into new maps, that have the same structure. In the end, we should have two versions of the partition: old and new.

{{onSnapshotLoad}} should just swap all objects. After that, old partition data can be cleaned by the garbage collector.

This is a good place to start implementation. I assume that some new API will be introduced. I have thoughts about it as well, they are described later in *API* section.
h3. MV storage - RocksDB engine

SST-based approach is described in a *TX state storage* section. There I describe why I don't think that this is a good solution. Same reasoning can be applied here just as effectively. This means that we should write data in the same RocksDB instance. This is a little bit tricky.

The reason is that all stored data is merged together, and Columns Families are shared between different partitions. This makes it harder to find a place to write partition data while old partition data persists. As a reminder and an example, let's take a look at how data is stored in row storage:
{code:java}
+-------------------+-----+-------------------+
|    Partition 0    | ... |   Partition MAX   |
+-------------------+-----+-------------------+
| Row1 | ... | RowN | ... | Row1 | ... | RowN |
+-------------------+-----+-------------------+{code}
Logically, CF is split into a different ""blocks"", and each block represents a partition. Currently, each partition block is associated with an 2-bytes identifier that matches a partition number in Big Endian.

 

We could add new CF with similar structure and write snapshot data in it, but then the snapshot load operation would require us to move data from one CF to another. The only option that I know of, that can do this, is SST ingestion. And I already explained why I don't like it.

This leaves us with the necessity to write data into the same column family. Naturally occurring solution is to assign a new identifier to the ""new"" version of partition. This way replacing ""old"" partition with ""new"" would be implemented by replacing ""oldPartId"" to ""newPartId"" in table storage metadata.

Sounds good. No flush is required, snapshot loading becomes pretty fast.

The only thing to keep in mind is that there are multiple column families in each partition - row data, hash indexes and a CF for every sorted index.

When ""old"" partition is deleted, we should probably somehow hint that RocksDB should merge some layers and remove a substantial amount of data from disk. But such optimization also relates to general partition eviction and is out of scope of the discussion.

Last point: what is ""oldPartId"" and ""newPartId""?

Logically, partition id now becomes a tuple of partition number and its generation. Physically it should be represented as an integer, where lower bits are generation and higher bits are partition number. It it 2 or 3 bytes? Good question, I'll answer it later.
{code:java}
| Partition Number | Generation |{code}
Every time we need a rebalance, we increase the generation of the current partition. Generation counter overflows without affecting the partition number.

 

There are alternatives - we either have N possible generations (rotating, of course) or only 2 (0 and 1). Why is this important?
Every time a partition is ""started"", it should, technically, perform a cleanup. Imagine (for example) we have partition {{{}(23,g){}}}. Then we would have to cleanup following ranges (lower bound inclusive, upper bound exclusive):
 * for 256 generations - ranges {{(23,0):(23,g)}} and {{(23,g+1):(24,0)}}
 * for 2 generations - range {{(23,1-g):(23,2-g)}}

This should be done for all indexes as well. Something tells me that recovery will be somewhat faster in the second case, but is it more convenient? I don't know.

Lastly, random thought on the prefix size. Don't we increase a footprint by storing it in every key? Yes and no. Right now the engine is not yet properly tuned, but in the future, we may set it up in such a way that RocksDB trims prefixes from the keys, so the prefix is kind of irrelevant. Will we configure a prefix to be a partition id or a pair (partId, rowId) - I don't know yet. Both options look good, but second may be better. We'll should do both and benchmark them.
h3. MV storage - Persistent Page Memory

This engine is way less complicated, but there are tricky parts as well. First of all, we can't have new partition ids like in RocksDB engine. It's 2 bytes, period. Too much code depends on this size to be exactly two bytes. There's a possibility of reducing a maximum number of partitions to a 32 thousands or so, leaving us with a single ""free"" bit to store generation, like in proposed RocksDB implementation. 

Second, unlike RocksDB, each partition is stored in its own set of files. Or, in other words, partitions are completely independent, which greatly simplifies the swapping procedure. I propose the following algorithm:
 * create new partition generation and upload data into it
 * checkpoint everything
 * invalidate all partition pages in page memory (this is {{{}O(1){}}}) for the old generation and close all file descriptors (page-stores)
 * drop new partition files

Local storage recovery should be implemented carefully. I propose having a rebalance marker, that shows that rebalance is in progress. On recovery:
 * if marker is present, delete ""new"" partition files
 * if marker is absent, do nothing

Marker should contain the generation information, otherwise there might be a confusion. Real generation must be easy to determine.
h3. MV storage - Volatile Page Memory

In case of a volatile storage, there are no files to work with and there's even no need to partition generations. Instead, we can preserve old partition ""meta"" - pointers to all trees, free lists or anything else useful. After that, we start writing data into a new partition with a new meta. Pretty much like in Test storage engine, but offheap.

When we're done, we can start deleting old partition data, using the same mechanism that's used in partition eviction (IGNITE-17833, not implemented yet).

If snapshot downloading is interrupted, we delete everything that we already downloaded asynchronously, again, reusing the partition eviction code. No memory leaks should be left from it.
h3. Atomic snapshot load in case of multiple storages

On every step, every operation may fail. But data consistency should be preserved no matter what. Here, in particular, we need to call two {{onSnapshotLoad}} methods atomically. Their implementations may be very different.

On high level, operation may look like this:
 * write operation marker somewhere (table folder, vault, doesn't matter). Before doing so, we need to make sure that data is persisted on disk for both storages. Once marker is created, there's no way back. Old partition data will be destroyed
 * call both methods
 * remove marker when load is completed

Pretty simple. Just do the same thing on recovery, if marker is present. One thing to keep in mind - {{onSnapshotLoad}} should be idempotent for this to work. If new partition is already loaded, nothing should break. Loading should effectively become a no-op in such case.
h3. API

I realize that MvPartitionStorage interface slowly becomes a mess. There's not much that we can do with it. But, rebalance is a good exception to the rule.

Basically, we can implement something like this:
{code:java}
void performLocalRecovery();

MvRebalanceDataWriter startDataRebalancing();

interface MvRebalanceDataWriter {
    CompletableFuture<?> beforeWritingData();

    void addCommitted(...);

    void addUncommitted(...); // Doesn't return the old value, because that's actually pointless during rebalancing

    // lastAppliedIndex, runConsistently, etc.

    CompletableFuture<?> afterWritingData();

    void close();
}{code}
What exactly do we do in {{onSnapshotLoad}} and which interfaces it uses, I'm not sure at the moment. I just hope that this brief description gives you a gist of what I would like to see in the code. I do believe that it will simplify the API at least a little bit.

What about indexes? That's a good question. I would expect that old objects, created with {{{}getOrCreate*Index{}}}, should still be functional. It may be a pain in the rear, we may have to introduce default implementation with changeable delegates. It's hard to predict exactly, but this is definitely a part that also requires attention. Same applies to partitions, actually.
h3. Read Access

One of the last things to discuss is a possibility to read data while rebalance is in the process. As we know, ""full rebalance"" can theoretically be performed on a live follower. RAFT works around this fact by allowing reading data from leader only. We don't have such limitation. Instead we have problems.

Technically, it's very easy to allow reads until the {{onSnapshotLoad}} happens. Everything's simple when it's completed also. Any read operation during onSnapshotLoad should wait for its completion.

That's good for ""fast"" read operations. But we also have scans. There are two options:
 * we cancel them
 * we allow them continue working seamlessly

I think the second option is better. When cursor is notified that the ""switch"" is happening, it opens a new underlying cursor from the position that it previously stopped on. It feels like each storage will have its own version, they may have small differences.
h3. Conclusion

I know that this is a pretty big task. I don't expect it to be done in one sitting. It should be split to 3 issues at least. Probably more.

This is fine, just don't forget the link to this particular issue, because it has the overall description of what's going on."	IGNITE	Resolved	3	4	6308	ignite-3
13426557	"Deal with all ""TODO"" on resolved tickets"	"In the project, there were references to resolved tickets in the *TODO*, it needs to be corrected:
* https://issues.apache.org/jira/browse/IGNITE-14645
* https://issues.apache.org/jira/browse/IGNITE-15409
* https://issues.apache.org/jira/browse/IGNITE-15721"	IGNITE	Resolved	4	3	6308	ignite-3, tech-debt
13468551	Fix flaky ItBplusTreePageMemoryImplTest#testPutSizeLivelock	It is necessary to investigate and fix the falling flaky  [ItBplusTreePageMemoryImplTest#testPutSizeLivelock|https://ci.ignite.apache.org/buildConfiguration/ignite3_Test_RunAllTests/6647751?logFilter=debug] test.	IGNITE	Resolved	3	1	6308	ignite-3
13593484	Add local tracking of completion of readings from metastorage to the required revision	"We need to add local tracking of read operations completion from metastorage.
We will be interested in all operations that will be less than or equal to the requested revision.

Operations of interest:
* Getting a single value.
* Getting multiple values.
* Cursors.
* Publishers."	IGNITE	Resolved	3	4	6308	ignite-3
13583642	Processing messages to yourself in a thread pool	"As a result of code analysis, it was discovered that if in *org.apache.ignite.internal.network.DefaultMessagingService* a message is sent to itself, then processing of the response will be performed in the same thread as the message is sent (without transferring threads to the pool). Which can affect system throughput.
We need to fix this."	IGNITE	Open	3	4	6308	ignite-3, ignite3_performance
13447178	[Native Persistence 3.0] End-to-end test for in-memory PageMemory	"In-memory PageMemory storage was ported and fully integrated into ignite-3, though only unit tests were written covering this piece of functionality.

We need to write an end-to-end integration test for PageMemory-based in-memory storage. The test should include:
* New storage creation with necessary configuration;
* Simple store/retrieve operations showing that storage actually performs its tasks."	IGNITE	Resolved	3	3	6308	ignite-3
13545037	Temporary fix for StackOverflowError in Replica#waitForActualState when a peer leaves	"It has been found that when a peer leaves, *org.apache.ignite.internal.replicator.Replica#waitForActualState* can generate  *StackOverflowError* that can lead to unpleasant consequences.

For example, as a result of an *StackOverflowError*, we will not be able to execute *busyLock.leaveBusy();* in *org.apache.ignite.internal.raft.RaftGroupServiceImpl#sendWithRetry(org.apache.ignite.internal.raft.Peer, java.util.function.Function<org.apache.ignite.internal.raft.Peer,? extends org.apache.ignite.network.NetworkMessage>, long, java.util.concurrent.CompletableFuture<R>)*, because the stack is full and when entering to *leaveBusy*, *StackOverflowError* will be thrown again, which will lead to freezing at the node stop.

At the moment I don't know how to fix this properly, while a temporary solution comes to mind - add thread pool and use it instead of *Runnable::run* in *Replica#waitForActualState*, you need to properly fix it in IGNITE-20063."	IGNITE	Resolved	3	1	6308	ignite-3
13593621	Stop local Metastore Compaction on node stop	"I found that *org.apache.ignite.internal.metastorage.server.KeyValueStorage#compact* does not respond to node stop, so we can conditionally suspend node stop for a long time if we have a lot of keys that need to be scanned.
We need to fix this."	IGNITE	Resolved	3	4	6308	ignite-3
13582824	Rename CompletableFutures#allOf to CompletableFutures#allOfToList	As a result of reflection and internal discussions, the name of *org.apache.ignite.internal.util.CompletableFutures#allOf* is not entirely appropriate, because the result will not be *CompletableFuture<Void>* but *CompletableFuture<List<T>>*, which can be confusing. It is proposed to rename it to *allOfToList* And also add a new “sugar” method *CompletableFuture<Void> allOf(List<CompletableFuture<?>> futures)*.	IGNITE	Resolved	4	4	6308	ignite-3
13550322	Correct implementation of PartitionReplicaListener#resolvePk	It was discovered that *org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener#resolvePk* was not implemented quite correctly, in theory it should not know how to resolve the PK index, but should delegate this to someone, I’ll try to fix it.	IGNITE	Resolved	3	4	6308	ignite-3
13586672	Add partition ID to BplusTree names to make debugging easier	"It was discovered that we do not add the partition ID to the *org.apache.ignite.internal.pagememory.tree.BplusTree* names, which makes it difficult to understand the problem when analyzing errors from logs.

It might be useful to add information to some of the *BplusTree* related things."	IGNITE	Resolved	3	4	6308	ignite-3
13476997	Implement a meta B+Tree of indexes	In order for us to work with many index B+Tree, we need to store their roots somewhere, a separate B+Tree is suitable for this, as done in 2.0, but instead of a key in the form of an index name, we need to use something more unique, for example, UUID.	IGNITE	Resolved	3	3	6308	ignite-3
13559019	Add tests for parallel building of a new index and table updates	"I discovered that we do not have tests when building an index, we make some changes to the table, such as insertions or updates, we need to add such integration tests.

It would also be good to move the integration tests associated with building indexes into the index module."	IGNITE	Resolved	3	4	6308	ignite-3
13529500	Fix NullPointerException on building indexes if the number of replicas is more than one	"Fix NullPointerException on building indexes if the number of replicas is more than one. Fall is not stable.
{noformat}
Caused by: java.lang.NullPointerException
	at org.apache.ignite.internal.sql.engine.schema.IgniteTableImpl.lambda$insertAll$2(IgniteTableImpl.java:417)
	at java.base/java.util.concurrent.CompletableFuture$UniApply.tryFire(CompletableFuture.java:642)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
	at org.apache.ignite.internal.replicator.ReplicaService.lambda$sendToReplica$2(ReplicaService.java:147)
	at java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:930)
	at java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:907)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
	at org.apache.ignite.network.DefaultMessagingService.onInvokeResponse(DefaultMessagingService.java:363)
	at org.apache.ignite.network.DefaultMessagingService.onMessage(DefaultMessagingService.java:328)
	at org.apache.ignite.network.DefaultMessagingService.lambda$onMessage$3(DefaultMessagingService.java:306)
	... 3 more
{noformat}
"	IGNITE	Resolved	3	1	6308	ignite-3
13596472	Move system properties configuration to new module ignite-configuration-system	"I found that the configuration of system properties *org.apache.ignite.internal.configuration.SystemDistributedConfigurationSchema* and *org.apache.ignite.internal.configuration.SystemLocalSchema* are located in module *ignite-runner*, which makes it impossible to use in other modules due to cyclic dependencies of models. For example, this appears when trying to add system properties for the metastore module.

It is proposed to fix this with a new *ignite-configuration-system* like *ignite-configuration-root* and transfer the corresponding configurations to it."	IGNITE	Resolved	3	1	6308	ignite-3
13539288	Get rid of configuration in MvTableStorage and related classes	We need to get rid of the configuration in *org.apache.ignite.internal.storage.engine.MvTableStorage* (and related) so that we can more easily migrate to entities from the catalog.	IGNITE	Resolved	3	4	6308	ignite-3
13592241	Page replacement doesn't work sometimes	"Under a sophisticated load, we sometimes see the following exception:
{noformat}
org.apache.ignite.lang.IgniteException: Error while executing addWriteCommitted: [rowId=RowId [partitionId=13, uuid=00000191-eb5c-824c-7a07-fa1210b49ed8], tableId=10, partitionId=13]
	at java.lang.invoke.MethodHandle.invokeWithArguments(MethodHandle.java:710) ~[?:?]
	at org.apache.ignite.internal.util.ExceptionUtils$1.copy(ExceptionUtils.java:789) ~[ignite-core-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.util.ExceptionUtils$ExceptionFactory.createCopy(ExceptionUtils.java:723) ~[ignite-core-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.util.ExceptionUtils.copyExceptionWithCause(ExceptionUtils.java:525) ~[ignite-core-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.util.ViewUtils.copyExceptionWithCauseIfPossible(ViewUtils.java:91) ~[ignite-core-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.util.ViewUtils.ensurePublicException(ViewUtils.java:71) ~[ignite-core-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.util.ViewUtils.sync(ViewUtils.java:54) ~[ignite-core-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.client.table.ClientKeyValueBinaryView.put(ClientKeyValueBinaryView.java:207) ~[ignite-client-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.client.table.ClientKeyValueBinaryView.put(ClientKeyValueBinaryView.java:60) ~[ignite-client-3.0.0-SNAPSHOT.jar:?]
	at site.ycsb.db.ignite3.IgniteClient.insert(IgniteClient.java:49) [ignite3-binding-2024.15.jar:?]
	at site.ycsb.DBWrapper.insert(DBWrapper.java:284) [core-2024.15.jar:?]
	at site.ycsb.workloads.CoreWorkload.doInsert(CoreWorkload.java:657) [core-2024.15.jar:?]
	at site.ycsb.ClientThread.run(ClientThread.java:181) [core-2024.15.jar:?]
	at java.lang.Thread.run(Thread.java:829) [?:?]
Caused by: org.apache.ignite.lang.IgniteException: Error while executing addWriteCommitted: [rowId=RowId [partitionId=13, uuid=00000191-eb5c-824c-7a07-fa1210b49ed8], tableId=10, partitionId=13]
	at java.lang.invoke.MethodHandle.invokeWithArguments(MethodHandle.java:710) ~[?:?]
	at org.apache.ignite.internal.util.ExceptionUtils$1.copy(ExceptionUtils.java:789) ~[ignite-core-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.util.ExceptionUtils$ExceptionFactory.createCopy(ExceptionUtils.java:723) ~[ignite-core-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.util.ExceptionUtils.copyExceptionWithCause(ExceptionUtils.java:525) ~[ignite-core-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.client.TcpClientChannel.readError(TcpClientChannel.java:549) ~[ignite-client-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.client.TcpClientChannel.processNextMessage(TcpClientChannel.java:435) ~[ignite-client-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.client.TcpClientChannel.lambda$onMessage$3(TcpClientChannel.java:277) ~[ignite-client-3.0.0-SNAPSHOT.jar:?]
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1426) ~[?:?]
	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290) ~[?:?]
	at java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1020) ~[?:?]
	at java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1656) ~[?:?]
	at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1594) ~[?:?]
	at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183) ~[?:?]
Caused by: org.apache.ignite.lang.IgniteException: org.apache.ignite.lang.IgniteException: IGN-CMN-65535 TraceId:60b4295a-8c18-4cdb-93e8-266bc9aaed88 Error while executing addWriteCommitted: [rowId=RowId [partitionId=13, uuid=00000191-eb5c-824c-7a07-fa1210b49ed8], tableId=10, partitionId=13]
	at org.apache.ignite.internal.lang.IgniteExceptionMapperUtil.lambda$mapToPublicException$2(IgniteExceptionMapperUtil.java:88)
	at org.apache.ignite.internal.lang.IgniteExceptionMapperUtil.mapCheckingResultIsPublic(IgniteExceptionMapperUtil.java:141)
	at org.apache.ignite.internal.lang.IgniteExceptionMapperUtil.mapToPublicException(IgniteExceptionMapperUtil.java:137)
	at org.apache.ignite.internal.lang.IgniteExceptionMapperUtil.mapToPublicException(IgniteExceptionMapperUtil.java:88)
	at org.apache.ignite.internal.lang.IgniteExceptionMapperUtil.lambda$convertToPublicFuture$3(IgniteExceptionMapperUtil.java:178)
	at java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:930)
	at java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:907)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at org.apache.ignite.internal.replicator.ReplicaService.lambda$sendToReplica$7(ReplicaService.java:249)
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
	at org.apache.ignite.internal.network.DefaultMessagingService.onInvokeResponse(DefaultMessagingService.java:586)
	at org.apache.ignite.internal.network.DefaultMessagingService.send0(DefaultMessagingService.java:272)
	at org.apache.ignite.internal.network.DefaultMessagingService.respond(DefaultMessagingService.java:215)
	at org.apache.ignite.internal.network.DefaultMessagingService.respond(DefaultMessagingService.java:228)
	at org.apache.ignite.internal.network.MessagingService.respond(MessagingService.java:142)
	at org.apache.ignite.internal.replicator.ReplicaManager.lambda$handleReplicaRequest$5(ReplicaManager.java:460)
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$applyCmdWithRetryOnSafeTimeReorderException$117(PartitionReplicaListener.java:2680)
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at org.apache.ignite.internal.raft.RaftGroupServiceImpl.handleSmErrorResponse(RaftGroupServiceImpl.java:749)
	at org.apache.ignite.internal.raft.RaftGroupServiceImpl.lambda$sendWithRetry$40(RaftGroupServiceImpl.java:613)
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
	at org.apache.ignite.internal.network.DefaultMessagingService.onInvokeResponse(DefaultMessagingService.java:586)
	at org.apache.ignite.internal.network.DefaultMessagingService.send0(DefaultMessagingService.java:272)
	at org.apache.ignite.internal.network.DefaultMessagingService.respond(DefaultMessagingService.java:215)
	at org.apache.ignite.internal.network.MessagingService.respond(MessagingService.java:115)
	at org.apache.ignite.raft.jraft.rpc.impl.IgniteRpcServer$NetworkRpcContext.sendResponse(IgniteRpcServer.java:245)
	at org.apache.ignite.raft.jraft.rpc.impl.ActionRequestProcessor.sendSMError(ActionRequestProcessor.java:302)
	at org.apache.ignite.raft.jraft.rpc.impl.ActionRequestProcessor.sendResponse(ActionRequestProcessor.java:257)
	at org.apache.ignite.raft.jraft.rpc.impl.ActionRequestProcessor$1.result(ActionRequestProcessor.java:187)
	at org.apache.ignite.internal.raft.server.impl.JraftServerImpl$DelegatingStateMachine$1$1.result(JraftServerImpl.java:770)
	at org.apache.ignite.internal.table.distributed.raft.PartitionListener.lambda$onWriteBusy$2(PartitionListener.java:280)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
	at org.apache.ignite.internal.table.distributed.raft.PartitionListener.onWriteBusy(PartitionListener.java:199)
	at org.apache.ignite.internal.table.distributed.raft.PartitionListener.onWrite(PartitionListener.java:192)
	at org.apache.ignite.internal.raft.server.impl.JraftServerImpl$DelegatingStateMachine.onApply(JraftServerImpl.java:731)
	at org.apache.ignite.raft.jraft.core.FSMCallerImpl.doApplyTasks(FSMCallerImpl.java:571)
	at org.apache.ignite.raft.jraft.core.FSMCallerImpl.doCommitted(FSMCallerImpl.java:539)
	at org.apache.ignite.raft.jraft.core.FSMCallerImpl.runApplyTask(FSMCallerImpl.java:458)
	at org.apache.ignite.raft.jraft.core.FSMCallerImpl$ApplyTaskHandler.onEvent(FSMCallerImpl.java:131)
	at org.apache.ignite.raft.jraft.core.FSMCallerImpl$ApplyTaskHandler.onEvent(FSMCallerImpl.java:125)
	at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:326)
	at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:283)
	at com.lmax.disruptor.BatchEventProcessor.processEvents(BatchEventProcessor.java:167)
	at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:122)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: org.apache.ignite.internal.storage.StorageException: IGN-STORAGE-1 TraceId:60b4295a-8c18-4cdb-93e8-266bc9aaed88 Error while executing addWriteCommitted: [rowId=RowId [partitionId=13, uuid=00000191-eb5c-824c-7a07-fa1210b49ed8], tableId=10, partitionId=13]
	at org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.lambda$addWriteCommitted$13(AbstractPageMemoryMvPartitionStorage.java:532)
	at org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.busy(AbstractPageMemoryMvPartitionStorage.java:659)
	at org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.addWriteCommitted(AbstractPageMemoryMvPartitionStorage.java:515)
	at org.apache.ignite.internal.table.distributed.raft.snapshot.outgoing.SnapshotAwarePartitionDataStorage.addWriteCommitted(SnapshotAwarePartitionDataStorage.java:135)
	at org.apache.ignite.internal.table.distributed.StorageUpdateHandler.tryProcessRow(StorageUpdateHandler.java:162)
	at org.apache.ignite.internal.table.distributed.StorageUpdateHandler.lambda$handleUpdate$0(StorageUpdateHandler.java:114)
	at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage.lambda$runConsistently$0(PersistentPageMemoryMvPartitionStorage.java:180)
	at org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.busy(AbstractPageMemoryMvPartitionStorage.java:659)
	at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage.runConsistently(PersistentPageMemoryMvPartitionStorage.java:170)
	at org.apache.ignite.internal.table.distributed.raft.snapshot.outgoing.SnapshotAwarePartitionDataStorage.runConsistently(SnapshotAwarePartitionDataStorage.java:76)
	at org.apache.ignite.internal.table.distributed.StorageUpdateHandler.handleUpdate(StorageUpdateHandler.java:109)
	at org.apache.ignite.internal.table.distributed.raft.PartitionListener.handleUpdateCommand(PartitionListener.java:327)
	at org.apache.ignite.internal.table.distributed.raft.PartitionListener.lambda$onWriteBusy$2(PartitionListener.java:242)
	... 14 more
Caused by: org.apache.ignite.internal.pagememory.tree.CorruptedTreeException: IGN-CMN-65535 TraceId:60b4295a-8c18-4cdb-93e8-266bc9aaed88 B+Tree is corrupted [groupId=10, pageIds=[563005788186369], groupName=10, msg=Runtime failure on search row: org.apache.ignite.internal.storage.pagememory.mv.VersionChainKey@7cda74e0]
	at org.apache.ignite.internal.pagememory.tree.BplusTree.corruptedTreeException(BplusTree.java:6670)
	at org.apache.ignite.internal.pagememory.tree.BplusTree.invoke(BplusTree.java:2119)
	at org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.lambda$addWriteCommitted$13(AbstractPageMemoryMvPartitionStorage.java:524)
	... 26 more
Caused by: java.lang.AssertionError: Checkpoint must be in progress
	at org.apache.ignite.internal.pagememory.persistence.checkpoint.CheckpointManager.writePageToDeltaFilePageStore(CheckpointManager.java:312)
	at org.apache.ignite.internal.storage.pagememory.PersistentPageMemoryDataRegion.lambda$start$0(PersistentPageMemoryDataRegion.java:110)
	at org.apache.ignite.internal.pagememory.persistence.replacement.DelayedDirtyPageWrite.finishReplacement(DelayedDirtyPageWrite.java:104)
	at org.apache.ignite.internal.pagememory.persistence.PersistentPageMemory.allocatePageNoReuse(PersistentPageMemory.java:593)
	at org.apache.ignite.internal.pagememory.PageIdAllocator.allocatePage(PageIdAllocator.java:111)
	at org.apache.ignite.internal.pagememory.PageIdAllocator.allocatePage(PageIdAllocator.java:70)
	at org.apache.ignite.internal.pagememory.freelist.FreeListImpl.allocateDataPage(FreeListImpl.java:491)
	at org.apache.ignite.internal.pagememory.freelist.FreeListImpl.writeSinglePage(FreeListImpl.java:621)
	at org.apache.ignite.internal.pagememory.freelist.FreeListImpl.insertDataRow(FreeListImpl.java:500)
	at org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.insertRowVersion(AbstractPageMemoryMvPartitionStorage.java:412)
	at org.apache.ignite.internal.storage.pagememory.mv.AddWriteCommittedInvokeClosure.insertCommittedRowVersion(AddWriteCommittedInvokeClosure.java:137)
	at org.apache.ignite.internal.storage.pagememory.mv.AddWriteCommittedInvokeClosure.call(AddWriteCommittedInvokeClosure.java:99)
	at org.apache.ignite.internal.storage.pagememory.mv.AddWriteCommittedInvokeClosure.call(AddWriteCommittedInvokeClosure.java:43)
	at org.apache.ignite.internal.pagememory.tree.BplusTree$Invoke.invokeClosure(BplusTree.java:4268)
	at org.apache.ignite.internal.pagememory.tree.BplusTree.invokeDown(BplusTree.java:2187)
	at org.apache.ignite.internal.pagememory.tree.BplusTree.invokeDown(BplusTree.java:2171)
	at org.apache.ignite.internal.pagememory.tree.BplusTree.invokeDown(BplusTree.java:2171)
	at org.apache.ignite.internal.pagememory.tree.BplusTree.invokeDown(BplusTree.java:2171)
	at org.apache.ignite.internal.pagememory.tree.BplusTree.invoke(BplusTree.java:2093)
	... 27 more
{noformat}

h2. {color:#DE350B}Update:{color}
The problem is in the incorrect implementation of page replacement, firstly it can be after the completion of the checkpoint, secondly after the fsync of files and thirdly it can disrupt the operation of delta files. It will need to be fixed.

What needs to be done:
# Get rid of delayed page replacement, since the implementation and use can lead to bugs.
# It is necessary to do page replacement only during the checkpoint and before fsync of delta files.
# fsync of delta files should start only after all page replacements are completed and after that prohibit page replacement."	IGNITE	Resolved	3	1	6308	ignite-3
13445569	[Native Persistence 3.0] Add configuration for checkpoint	We need to add a configuration for the checkpoint, you can look at all *TODO*s in *org.apache.ignite.internal.pagememory.persistence.checkpoint*.	IGNITE	Resolved	3	3	6308	ignite-3
13532053	Implement local Low Watermark propagation	"According to the IEP-91, we can delete old data, once it becomes older than the certain threshold. At the moment, we can consider this threshold to be shared between different tables, but be unique on individual nodes. It's called a Low Watermark (LW).

The way the value is chosen is the following:
 * There's the {_}data availability time{_}, that can be configured by the user. This is a cluster configuration. It has a value of, for example, 45 minutes. Valid values - {{{}[0, +INF){}}}.
 * There's a {_}GC frequency{_}, that's also a cluster configuration. For example, 5 minuter. Range of valid values should be more strict.
 * Last LW value is persisted in Vault.
 * Every 5 minutes, we assign a new ""lwCandidate{{{} = now() - 45min - maxClockSkew""{}}}.
 ** If there are no running transactions with timestamp below {{{}lwCandidate{}}}, we promote the candidate into a real LW value.
 ** Otherwise, we trigger GC with timestamp of the transaction with the oldest timestamp (and promoting LW to that timestamp), and raising the bar every time* that transaction is completed. Eventually, we will reach the point where there are no running transactions with timestamp below {{{}lwCandidate{}}}.
 * it's not necessary to do it every time. But, once the timestamp of the oldest RO transaction is above or equal to {{{}lwCandidate{}}}, we must guarantee its promotion. Everything else is optimization.
 * If there's a new RO transaction with timestamp below {{{}lwCandidate{}}}, we fail it.
 * When it comes to running GC - you never delete anything if LW < safeTime. This does not prevent us from propagating new LW value locally, we just don't drop the data until we have the rights to do so.

Promoted LW value cannot become smaller no matter what. All data below LW is considered to be invalid, maybe broken and completely invisible to user."	IGNITE	Resolved	3	4	6308	ignite-3
13569055	Add schema sync before apply BuildIndexCommand	"Now, before applying the *org.apache.ignite.internal.table.distributed.command.BuildIndexCommand* in *org.apache.ignite.internal.table.distributed.raft.PartitionListener#handleBuildIndexCommand*, we wait for the index to appear through the internal mechanism, and it is enough to reuse the existing schema synchronization and inherit from the *org.apache.ignite.internal.table.distributed.command.CatalogVersionAware* and pass into it catalog version in which the index get the *org.apache.ignite.internal.catalog.descriptors.CatalogIndexStatus#BUILDING*.

Also, I think we will need to skip the *BuildIndexCommand* if the index has been removed from the catalog at the time the command is applied."	IGNITE	Resolved	3	4	6308	ignite-3
13586014	Implement the trigger for the metastorage compaction	Metastorage compaction has been implemented, but its trigger is not, we need to invent and implement it.	IGNITE	Resolved	3	4	6308	ignite-3
13481253	Implement BinaryTuple inlining in a sorted index B+Tree	In a simple implementation, instead of a *BinaryTuple*, we store its link from the *FreeList* in the key, this is not optimal and we need to inline the *BinaryTuple* in the key, for starters, you can see how to do this in 2.0.	IGNITE	Resolved	3	3	6308	ignite-3
13397349	[Ignite 3] Switch to Google code style	"As agreed in [1], we need to switch to the Google code style with two changes:
* 140 column limit instead of 100
* 4/8 spaces indentation instead of 2/4

The updated XML file for the Checkstyle Plugin is attached.

Also, 
# Create coding guideline wiki page for Ignite 3 
# Update links to CONTRIBUTING.md

[1] https://lists.apache.org/thread.html/rfa1e775f27b99b1f14c356e25cc52f83eb90c7553db1f1a2aba136c6%40%3Cdev.ignite.apache.org%3E"	IGNITE	Resolved	3	4	6308	ignite-3
13566245	Getting the catalog version in which the index created	To implement ticket IGNITE-21115, we need a way to get the catalog version in which the index of interest was created, it also needs to be safe when invoked outside update metastore/catalog threads.	IGNITE	Resolved	3	4	6308	ignite-3
13562861	Structure for waiting for the completion of RW operations before starting to build an index for partitions	"To implement IGNITE-21111, we need a structure that will allow us to wait for the completion all in-flight operations of RW transactions before the index appears in order to begin building indexes for partition.

The basic idea of this structure is described in IGNITE-21111."	IGNITE	Resolved	3	4	6308	ignite-3
13585599	Get rid of CatalogIndexDescriptor#txWaitCatalogVersion	Get rid of the *org.apache.ignite.internal.catalog.descriptors.CatalogIndexDescriptor#txWaitCatalogVersion* field, we don't need it anymore.	IGNITE	Resolved	3	4	6308	ignite-3
13536703	Must wait for indexes to be created before rebalancing	"Now, to prevent a race between the creation of indexes and the start of the rebalance, an explicit (crutch) wait for the creation of indexes has been added, which looks terrible.

We must organize the code so that at the time the rebalance starts, all previous indexes are created and no new indexes appear during the rebalance.

See TODO."	IGNITE	Resolved	3	4	6308	ignite-3
13545708	Support conditional schema update install	"Currently, the Catalog allows to install a schema update, but it's unconditional.

We'll need a way to install schema updates conditionally, like this: 'if the latest index state is X, install a schema update chaning it to Y, otherwise do nothing and return false'."	IGNITE	Resolved	3	4	6308	ignite-3
13534113	Remove MvPartitionStorage#pollForVacuum	After https://issues.apache.org/jira/browse/IGNITE-19269, old method makes little sense and should be removed. Instead, we should implement proper bathing with try-locks and deadlock prevention.	IGNITE	Resolved	3	4	6308	ignite-3
13547849	Refactoring some tests to make it easier to switch to catalog	"During the implementation of task IGNITE-20114, tests were found that we would like to refactor to simplify their switching to the catalog:
* org.apache.ignite.internal.configuration.storage.ItRebalanceDistributedTest
* org.apache.ignite.internal.distribution.zones.ItIgniteDistributionZoneManagerNodeRestartTest
* org.apache.ignite.internal.table.distributed.TableManagerTest"	IGNITE	Resolved	3	4	6308	ignite-3
13585405	Use IndexMeta in ChangeIndexStatusTask	Use index metadata in *org.apache.ignite.internal.index.ChangeIndexStatusTask* to prevent problems associated with catalog compaction.	IGNITE	Resolved	3	4	6308	ignite-3
13581136	Get rid of CatalogUtils#collectIndexes	Get rid of *org.apache.ignite.internal.catalog.commands.CatalogUtils#collectIndexes*, which is only tested and not used anywhere.	IGNITE	Resolved	4	4	6308	ignite-3
13505587	Implement a peek method for the sorted index cursor 	"The transaction protocol have no possibility to create a range lock. Instead of the range locks, we are using two locks on two consecutive keys. There is a problem: how to determine a next key when we have a current one.
For looking for the next key, we are planing to use a loop:

{code:java}
do {
  nextKey = cursor.peek();
  lock(nextKey);
} while (nextKey != cursor.peek());
{code}

Hence, cursor.peek() should return a next element from the cursor (by sorted index) without movement from current position."	IGNITE	Resolved	3	4	6308	ignite-3
13449245	Support for abstract configuration	"*NOTE*

Description may not be complete.

*Problem*
We need the ability to create a basic configuration schema so that we can define a common configuration schema and inherit from it with additional configuration added.

Let's look at an example:

We need to create two configuration schemes for the PageMemory based storage engine, they should have a common property ""page size in bytes"" and then they should be different, let's sketch an example scheme.
{code:java}
public class BasePageMemoryStorageEngineConfigurationSchema {
    @Value(hasDefault = true)
    public int pageSize = 16 * 1024;
}

@ConfigurationRoot(rootName = ""in-memory-page-memory"", type = DISTRIBUTED) 
public class VolatilePageMemoryStorageEngineConfigurationSchema extends BasePageMemoryStorageEngineConfigurationSchema{
    @ConfigValue
    public VolatilePageMemoryDataRegionConfigurationSchema defaultRegion;

    @NamedConfigValue
    public VolatilePageMemoryDataRegionConfigurationSchema regions;
}

@ConfigurationRoot(rootName = ""persistent-page-memory"", type = DISTRIBUTED)
public class PersistentPageMemoryStorageEngineConfigurationSchema extends BasePageMemoryStorageEngineConfigurationSchema{
    @ConfigValue
    public PersistentPageMemoryDataRegionConfigurationSchema defaultRegion;

    @NamedConfigValue
    public PersistentPageMemoryDataRegionConfigurationSchema regions;

    @ConfigValue
    public PageMemoryCheckpointConfigurationSchema checkpoint;
}{code}
How can we implement this at the moment:
 * internal extension of the configuration: then the user will not be able to see and change it - not suitable;
 * polymorphic configuration:
 ** by design, we cannot create root config schemas for polymorphic config or instances;
 ** by design, we can change the type of polymorphic configuration to any instance, we do not fix its type, which does not suit us;
 ** by design, we cannot expose a polymorphic instance as a configuration schema property;
 ** hocon will display the type of polymorphic configuration, which is not necessary in this case and will look a little strange.

The possible options do not suit us, so I propose to add another solution.

*Proposal*

Add an abstract configuration schema from which we can inherit, add properties, but only its heirs could be used as properties of other configurations schemas or configuration roots. Unlike a polymorphic configuration, it will not store and display the type in hocon, and the type cannot be changed. 
The abstract configuration schema from which will be inherited will contain the annotation {*}@AbstractConfiguration{*}, and any successor must extend it and contain *@Config* or {*}@ConfigurationRoot{*}, consider examples:
{code:java}
@AbstractConfiguration
public class BasePageMemoryStorageEngineConfigurationSchema {
    @Value(hasDefault = true)
    public int pageSize = 16 * 1024;
}

@ConfigurationRoot(rootName = ""in-memory-page-memory"", type = DISTRIBUTED) 
public class VolatilePageMemoryStorageEngineConfigurationSchema extends BasePageMemoryStorageEngineConfigurationSchema{
    @ConfigValue
    public VolatilePageMemoryDataRegionConfigurationSchema defaultRegion;

    @NamedConfigValue
    public VolatilePageMemoryDataRegionConfigurationSchema regions;
}

@Config
public class PersistentPageMemoryStorageEngineConfigurationSchema extends BasePageMemoryStorageEngineConfigurationSchema{
    @ConfigValue
    public PersistentPageMemoryDataRegionConfigurationSchema defaultRegion;

    @NamedConfigValue
    public PersistentPageMemoryDataRegionConfigurationSchema regions;

    @ConfigValue
    public PageMemoryCheckpointConfigurationSchema checkpoint;
}{code}

*Implementation notes*
# Add annotation *org.apache.ignite.configuration.annotation.AbstractConfiguration*;
# Add processing to *org.apache.ignite.internal.configuration.processor.Processor*;
# Add processing to *org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator*;
# Cover with tests.

*Further development*
 * Consider the possibility and necessity of crossing with the annotation *InternalConfiguration* and *PolymorphicConfig* in a separate ticket, at the moment they cannot be used together in the same class (for simplicity)."	IGNITE	Resolved	3	3	6308	iep-55, ignite-3
13558003	Selecting indexes when performing update operations for partition	"To implement IGNITE-20125, we need to correctly select the indexes into which we will insert data during RW transactions update operations for partitions.

It is enough for us to collect all available and registered indexes at the time of the operation, as well as all dropped available indexes that we can know about."	IGNITE	Resolved	3	4	6308	ignite-3
13528846	Handle the case of changing the leader of the raft group when building the index	The process of building the index is carried out by the leader of the raft group (partition), and we are not ready for the fact that the leader can change, we need to fix it.	IGNITE	Resolved	3	4	6308	ignite-3
13559704	Getting rid of double writing of partition meta to a DeltaFilePageStoreIo	After IGNITE-20419 was implemented, we started writing the partition meta page to a *DeltaFilePageStoreIo* twice. We need to fix this.	IGNITE	Resolved	3	1	6308	ignite-3
13547838	Fix validation of autoAdjust, scaleUp and scaleDown when creating a zone in the catalog	"It was found that the default value for creating and modifying a zone in catalog is not quite correct. 

They should be:
* dataNodesAutoAdjust == INFINITE_TIMER_VALUE
* dataNodesAutoAdjustScaleUp == IMMEDIATE_TIMER_VALUE
* dataNodesAutoAdjustScaleDown == INFINITE_TIMER_VALUE

It is necessary to correct the values for the default zone, the parameters for creating / updating the zone and the validation.

Maybe there will be light refactoring in the classes regarding the changes."	IGNITE	Resolved	3	1	6308	ignite-3
13567028	Optimize listener collection update in AbstractEventProducer	I discovered that updating the collection of listeners in *org.apache.ignite.internal.event.AbstractEventProducer* is a little not optimal, I’m optimizing it.	IGNITE	Resolved	4	4	6308	ignite-3
13408227	[Native Persistence 3.0]  Data Structures porting	"h2. Goal

In Ignite 3 we'll reuse basic data structures from Ignite 2 persistence codebase, but need to fix some design flaws and remove dependencies from WAL logging functionality as in Ignite 3 WAL is an external service.
h2. Items to pay attention to

Port data structures classes hierarchy: AbstraceDataStructure, -BPlusTree- and FreeList implementations (some implementations may not be necessary, they should be considered individually).

Port existing unit tests whenever it doesn't require too much effort.

Type parameters clarification in data structures is needed.
h2. More details

I think this issue should be concentrated on porting of Free List rather than BPlusTree. Maybe classes like Storable should be revisited."	IGNITE	Resolved	3	3	6308	ignite-3
13345781	Make GridEncryptionManager#onWalSegmentRemoved async	"When implementing IGNITE-13831 I was faced with deadlock.

When execute *FileWriteAheadLogManager#rollOver*, begin to clean WAL archive since we have reached the *DataStorageConfiguration#maxWalArchiveSize*, after deleting a segment, execute the *GridEncryptionManager#onWalSegmentRemoved* that wants to write to the metastore, but it will not succeed, since it will wait for *FileWriteAheadLogManager#rollOver*.

I suggest making the *GridEncryptionManager#onWalSegmentRemoved* asynchronous in a separate pool, for example, as a *CacheGroupPageScanner#singleExecSvc*."	IGNITE	Resolved	3	4	6308	IEP-18
13538601	Transform IndexManager to internally work against Catalog event types	Part of ticket IGNITE-19483 which will have changes for IndexManager.	IGNITE	Resolved	3	4	6308	ignite-3
13422248	[Native Persistence 3.0] Implement B+Tree-based storage	"Ignite 3 uses byte[] for keys and should add hash/tableId. New PageIO implementations should be added to support such structure.
Then new Storage implementation should be introduced that works with such trees."	IGNITE	Resolved	3	3	6308	ignite-3
13435556	Storage Engine interfaces unification	"Storage Engine interfaces capture the following main concepts:

* StorageEngine itself enables creating DataRegion and TableStorage objects;
* TableStorage provides methods to obtain or create PartitionStorage and SortedIndexStorage objects;
* Two latter objects are the most important as they provide actual data manipulation operations.

We need to unify this hierarchy of interfaces to enable configuration of different storages. Right now the only implementation available is RocksDbStorageEngine which is hardcoded in TableManager constructor. But we should be able to support other types of storages too (like PageMemory-based implementation which will be ported to Ignite 3.0)."	IGNITE	Resolved	3	3	6308	ignite-3
13541523	Get rid of InjectRevisionListenerHolder	"The main problem is described in IGNITE-19801, but due to the fact that we now have code closely related to updating the configuration revision, it is difficult to do everything at once in IGNITE-19801, so it will be divided into parts.

In this ticket, we need to get rid of *InjectRevisionListenerHolder*, but this is not so easy to do because we need to somehow redo the tests that use this annotation for this.

How to do this, I do not know exactly, but there are the following ideas:
* Delete tests.
* Convert them to integration.
* Move interface implementation *ConfigurationStorage* into a separate module, honestly raise the meta storage and configuration registry."	IGNITE	Resolved	3	4	6308	ignite-3
13586673	Make field BplusTree#globalRmvId monotonically increasing to avoid errors after node recovery	"It was discovered that *org.apache.ignite.internal.pagememory.tree.BplusTree#globalRmvId* is reset after a node restart, but should increase monotonically.

If we reset this field after restarting the node, then you can get into a situation where, when executing *org.apache.ignite.internal.pagememory.tree.BplusTree.GetPageHandler#run*, we can return *RETRY_ROOT* and will create an infinity loop from which we will not exit."	IGNITE	Resolved	3	4	6308	ignite-3
13486053	Implement RAFT snapshot streaming receiver	See IGNITE-17262	IGNITE	Resolved	3	4	6308	ignite-3
13557123	Extract integration raft snapshot tests from runner module to table module	We need to extract raft snapshot integration tests from runner module to table module to reduce the load on [Runner suite|https://ci.ignite.apache.org/viewType.html?buildTypeId=ApacheIgnite3xGradle_Test_IntegrationTests_ModuleRunner&branch_ApacheIgnite3xGradle_Test_IntegrationTests=%3Cdefault%3E&tab=buildTypeStatusDiv] which takes more than 29 minutes.	IGNITE	Resolved	3	4	6308	ignite-3
13572782	Error: Partition file page store is either not initialized or deleted	"During looking into log [one of TC run|https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunAllTests/7952341?hideTestsFromDependencies=false&hideProblemsFromDependencies=false&expandBuildTestsSection=true&expandCode+Inspection=true&expandBuildProblemsSection=true&expandBuildChangesSection=true&expandBuildDeploymentsSection=false] I found Error in log, which looks dangerous
{code:java}
®[2024-03-20T11:15:35,893][ERROR][checkpoint-runner-io0][FailureProcessor] Critical system error detected. Will be handled accordingly to configured handler [hnd=NoOpFailureHandler [], failureCtx=FailureContext [type=CRITICAL_ERROR, err=org.apache.ignite.internal.lang.IgniteInternalCheckedException: IGN-CMN-65535 TraceId:64d96aba-9a18-420d-af54-dd3679466403 Partition file page store is either not initialized or deleted: [groupId=81, partitionId=19]]]
org.apache.ignite.internal.lang.IgniteInternalCheckedException: Partition file page store is either not initialized or deleted: [groupId=81, partitionId=19]
    at org.apache.ignite.internal.pagememory.persistence.store.FilePageStoreManager.getStoreWithCheckExists(FilePageStoreManager.java:298) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.persistence.store.FilePageStoreManager.allocatePage(FilePageStoreManager.java:259) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.persistence.PersistentPageMemory.allocatePage(PersistentPageMemory.java:513) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.datastructure.DataStructure.allocatePageNoReuse(DataStructure.java:193) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.datastructure.DataStructure.allocatePage(DataStructure.java:174) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.freelist.PagesList.addStripe(PagesList.java:589) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.freelist.PagesList.getStripeForPut(PagesList.java:711) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.freelist.PagesList.put(PagesList.java:815) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.freelist.PagesList$PutBucket.run(PagesList.java:173) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.freelist.PagesList$PutBucket.run(PagesList.java:147) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.util.PageHandler.writePage(PageHandler.java:298) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.datastructure.DataStructure.write(DataStructure.java:296) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.freelist.PagesList.flushBucketsCache(PagesList.java:387) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.freelist.PagesList.saveMetadata(PagesList.java:332) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.storage.pagememory.mv.RowVersionFreeList.saveMetadata(RowVersionFreeList.java:185) ~[ignite-storage-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage.lambda$syncMetadataOnCheckpoint$13(PersistentPageMemoryMvPartitionStorage.java:367) ~[ignite-storage-page-memory-3.0.0-SNAPSHOT.jar:?]
    at org.apache.ignite.internal.pagememory.persistence.checkpoint.AwaitTasksCompletionExecutor.lambda$execute$1(AwaitTasksCompletionExecutor.java:59) ~[ignite-page-memory-3.0.0-SNAPSHOT.jar:?]
    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) [?:?]
    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) [?:?]
    at java.base/java.lang.Thread.run(Thread.java:834) [?:?]   stderr tc:parseServiceMessagesInside,ãÌ7-  Ž[’à           ‰‰[2024-03-20T11:15:35,912][INFO ][%sqllogic0%JRaft-FSMCaller-Disruptor_stripe_8-0][StateMachineAdapter] onLeaderStart: term=1.
 {code}"	IGNITE	Resolved	1	4	6308	ignite-3
13587417	Improve support for Enum in NetworkMessage	After implementing IGNITE-22711 and discussing with colleagues, we came to the conclusion that in order to improve the experience of working with enumerations, it is better to use a special interface for enumerations so that when changing or adding elements, fewer errors occur. For example, so that new elements are not added in the middle and the order of elements is not violated.	IGNITE	Resolved	3	4	6308	ignite-3
13475081	Remove TableStorage and PartitionStorage implementations	All implementations of *TableStorage* and *PartitionStorage* should be removed, as well as the code associated with them.	IGNITE	Resolved	3	3	6308	ignite-3
13590438	Data race in aipersist partition destruction	"{{CheckpointProgressImpl#onStartPartitionProcessing}} and {{CheckpointProgressImpl#onFinishPartitionProcessing}} don't work as intended for several reasons:
 * There's a race, we could call {{onFinish}} before {{onStart}} is called in a concurrent thread. This might happen if there's only a handful of dirty pages in each partition and there are more than one checkpoint threads. Basically, this protection doesn't work.
 * Even if that particular race wouldn't exits, this code still doesn't work, because some of pages could be added to {{pageIdsToRetry}} map. That map will be processed later, when {{writePages}} is finished, manning that we mark unfinished partitions as finished.
 * Due to aforementioned bugs, I didn't bother including these methods to {{{}drainCheckpointBuffers{}}}. As a result, this method requires a fix too

*Upd:*
The first and second problems can be solved within the IGNITE-23115, when the writing of pages of one partition is made by only one thread, it will be necessary to check.
After a thoughtful analysis, I found out that there is no race. So I renamed some methods and added documentation to them. And also fix *drainCheckpointBuffers*.
"	IGNITE	Resolved	3	1	6308	ignite-3
13550203	Return future metastore event processing from UpdateListener#onUpdate	"When trying to switch from a configuration to catalog, it was discovered that the metastore was not waiting for the catalog listeners to complete notifications, which could lead to races and slightly unpredictable behavior.

For example, we want to create a table, we updated the catalog and started the procedure for creating raft groups and did not wait for it to complete, we release the metastore revison.
Rebalance engine starts the rebalance on a timer, recording this in the metastore, and we immediately begin processing the rebalance and can fall with *NullPointerException* on obtaining a stable topology from the metastore since the raft groups have not yet had time to start.

Briefly need to be fixed here: *org.apache.ignite.internal.catalog.storage.UpdateLogImpl.UpdateListener#onUpdate*.
"	IGNITE	Resolved	3	4	6308	ignite-3
13583449	Exception in IndexBuildController.requireMvTableStorageNonNull	"If you increase the number of replicas in default zone to 5, random integration tests will start to fail with {{org.apache.ignite.internal.lang.IgniteInternalException: Table storage for the specified table cannot be null}}.

To reproduce the issue change {{org.apache.ignite.internal.catalog.commands.CatalogUtils#DEFAULT_REPLICA_COUNT}} and run {{org.apache.ignite.internal.sql.sqllogic.ItSqlLogicTest}}.

Full stack trace:
{code}
[2024-06-21T15:32:39,124][ERROR][%sqllogic1%JRaft-FSMCaller-Disruptormetastorage_stripe_0-0][FailureProcessor] Critical system error detected. Will be handled accordingly to configured handler [hnd=NoOpFailureHandler [], failureCtx=FailureContext [type=CRITICAL_ERROR, err=java.util.concurrent.CompletionException: org.apache.ignite.internal.lang.IgniteInternalException: IGN-CMN-65535 TraceId:6f33fc0c-c8c6-4197-becb-9322397b84b3 Table storage for the specified table cannot be null [tableId = 151]]]
 java.util.concurrent.CompletionException: org.apache.ignite.internal.lang.IgniteInternalException: IGN-CMN-65535 TraceId:6f33fc0c-c8c6-4197-becb-9322397b84b3 Table storage for the specified table cannot be null [tableId = 151]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:314) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:319) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture$UniApply.tryFire(CompletableFuture.java:645) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2079) ~[?:?]
	at org.apache.ignite.internal.util.CompletableFutures.lambda$copyStateTo$2(CompletableFutures.java:160) ~[main/:?]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenCompleteStage(CompletableFuture.java:883) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:2257) ~[?:?]
	at org.apache.ignite.internal.causality.BaseVersionedValue.copyState(BaseVersionedValue.java:315) ~[main/:?]
	at org.apache.ignite.internal.causality.BaseVersionedValue.complete(BaseVersionedValue.java:201) ~[main/:?]
	at org.apache.ignite.internal.causality.IncrementalVersionedValue.lambda$completeInternal$2(IncrementalVersionedValue.java:256) ~[main/:?]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenCompleteStage(CompletableFuture.java:883) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:2257) ~[?:?]
	at org.apache.ignite.internal.causality.IncrementalVersionedValue.completeInternal(IncrementalVersionedValue.java:256) ~[main/:?]
	at org.apache.ignite.internal.causality.IncrementalVersionedValue.lambda$dependingOn$0(IncrementalVersionedValue.java:76) ~[main/:?]
	at org.apache.ignite.internal.causality.BaseVersionedValue.lambda$notifyCompletionListeners$6(BaseVersionedValue.java:337) ~[main/:?]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenCompleteStage(CompletableFuture.java:883) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:2257) ~[?:?]
	at org.apache.ignite.internal.causality.BaseVersionedValue.notifyCompletionListeners(BaseVersionedValue.java:332) ~[main/:?]
	at org.apache.ignite.internal.causality.BaseVersionedValue.complete(BaseVersionedValue.java:210) ~[main/:?]
	at org.apache.ignite.internal.causality.IncrementalVersionedValue.lambda$completeInternal$2(IncrementalVersionedValue.java:256) ~[main/:?]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenCompleteStage(CompletableFuture.java:883) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:2257) ~[?:?]
	at org.apache.ignite.internal.causality.IncrementalVersionedValue.completeInternal(IncrementalVersionedValue.java:256) ~[main/:?]
	at org.apache.ignite.internal.causality.IncrementalVersionedValue.lambda$dependingOn$0(IncrementalVersionedValue.java:76) ~[main/:?]
	at org.apache.ignite.internal.causality.BaseVersionedValue.lambda$notifyCompletionListeners$6(BaseVersionedValue.java:337) ~[main/:?]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenCompleteStage(CompletableFuture.java:883) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:2257) ~[?:?]
	at org.apache.ignite.internal.causality.BaseVersionedValue.notifyCompletionListeners(BaseVersionedValue.java:332) ~[main/:?]
	at org.apache.ignite.internal.causality.BaseVersionedValue.complete(BaseVersionedValue.java:210) ~[main/:?]
	at org.apache.ignite.internal.causality.IncrementalVersionedValue.lambda$completeInternal$2(IncrementalVersionedValue.java:256) ~[main/:?]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.uniWhenCompleteStage(CompletableFuture.java:883) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:2257) ~[?:?]
	at org.apache.ignite.internal.causality.IncrementalVersionedValue.completeInternal(IncrementalVersionedValue.java:256) ~[main/:?]
	at org.apache.ignite.internal.metastorage.server.WatchProcessor.notifyUpdateRevisionListeners(WatchProcessor.java:379) ~[main/:?]
	at org.apache.ignite.internal.metastorage.server.WatchProcessor.lambda$notifyWatches$4(WatchProcessor.java:200) ~[main/:?]
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072) ~[?:?]
	at java.base/java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:478) ~[?:?]
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[?:?]
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[?:?]
	at java.base/java.lang.Thread.run(Thread.java:829) [?:?]
Caused by: org.apache.ignite.internal.lang.IgniteInternalException: Table storage for the specified table cannot be null [tableId = 151]
	at org.apache.ignite.internal.index.IndexBuildController.requireMvTableStorageNonNull(IndexBuildController.java:275) ~[main/:?]
	at org.apache.ignite.internal.index.IndexBuildController.lambda$getMvTableStorageFuture$16(IndexBuildController.java:267) ~[main/:?]
	at java.base/java.util.concurrent.CompletableFuture$UniApply.tryFire(CompletableFuture.java:642) ~[?:?]
	... 44 more
{code}
"	IGNITE	Resolved	3	1	6308	ignite-3
13540931	Refactoring classes associated with the catalog	Now there is a lot of duplicate code in the classes associated with the catalog that I want to clean up, especially *org.apache.ignite.internal.catalog.CatalogServiceImpl* and *org.apache.ignite.internal.catalog.commands.AbstractIndexCommandParams*, maybe some more related to it.	IGNITE	Resolved	3	4	6308	ignite-3
13549379	Create an abstraction for building indexes	"At the moment, two components react to the create index events:
1. IndexManager - creates indexes and other preparations;
2. PartitionReplicaListener - physically creates indexes and starts building them. and also stops building indexes.

It seems that the current implementation looks wrong and should be improved by creating an abstraction that would start and stop building indexes."	IGNITE	Resolved	3	4	6308	ignite-3
13562938	Adding a in-flight RW transaction counter by catalog version on a node	"To implement IGNITE-21112, we need an in-flight transaction counter based on catalog versions. To begin putting the index into backfilling state.

We also need to implement request that can tell whether there are transactions on a node before the index appears.

See IGNITE-21112 for more details."	IGNITE	Resolved	3	4	6308	ignite-3
13393876	Get rid of JSON code in configuration module	"Right now we have a duplicated logic in configuration framework for HOCON and JSON text representations.

Given that HOCON is the extension of JSON format, it can both parse and produce valid JSON representation. This means that classes like JsonConfigurationVisitor and others are not required anymore and can be deleted.

There's only one problem here: REST code that uses JSON conversion is not covered with tests. We have to be sure that it won't be broken after the change. Maybe write our own tests.

 "	IGNITE	Resolved	3	4	6308	iep-55, ignite-3
13531159	Fix NPE on building indexes	"After the implementation of index building, fluky tests appeared:
* *org.apache.ignite.internal.runner.app.ItDataSchemaSyncTest#checkSchemasCorrectUpdate*

Stack traces of errors:
{noformat}
java.util.concurrent.CompletionException: java.lang.NullPointerException: Cannot invoke ""java.util.List.isEmpty()"" because ""batch"" is null
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:315)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:320)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1159)
	at java.base/java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:482)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.NullPointerException: Cannot invoke ""java.util.List.isEmpty()"" because ""batch"" is null
	at org.apache.ignite.internal.index.IndexBuilder$BuildIndexTask.getNextRowIdForNextBatch(IndexBuilder.java:250)
	at org.apache.ignite.internal.index.IndexBuilder$BuildIndexTask.lambda$run$1(IndexBuilder.java:165)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150)
	... 4 more
{noformat}"	IGNITE	Resolved	3	1	6308	ignite-3
13536533	TableManager should listen CatalogService events instead of configuration	"As of now, TableManager listens configuration events to create internal structures.
Let's make TableManager listens CatalogService events instead.

Note: Some tests may fails due to changed guarantees and related ticked incompletion. So, let's do this in a separate feature branch."	IGNITE	Resolved	3	4	6308	ignite-3
13550689	Get rid of unused code in the index module	Unused code was found in the index module and we need to get rid of it.	IGNITE	Resolved	3	4	6308	ignite-3
13520429	Add RaftGroupConfiguration to MvTableStorage#finishRebalancePartition	It was found that at the end of the partition rebalancing (*org.apache.ignite.internal.table.distributed.raft.snapshot.incoming.IncomingSnapshotCopier#updateLastAppliedIndexFromSnapshotMetaForStorages*), along with *lastAppliedIndex* and *lastAppliedTerm*, we also get *RaftGroupConfiguration*, which would also be better to add to *org.apache.ignite.internal.storage.engine.MvTableStorage#finishRebalancePartition*.	IGNITE	Resolved	3	3	6308	ignite-3
13391359	Thin 3.0: Implement createTable	"Implement {{IgniteTables#createTable}} with full configuration support.

Investigate whether {{Consumer<TableChange>}} API should be changed - there were some plans for that on the dev list.

https://lists.apache.org/thread.html/rc8b28cf0ae7988831ea3867793a5ea72dfd062e8769c1d32f371fc16%40%3Cdev.ignite.apache.org%3E"	IGNITE	Resolved	3	4	8306	ignite-3
13473955	SQL API: When cursor is closed, internal exception is thrown from fetchNextPage	"* Introduce error code for closed cursor scenario
* Fix client side to throw the same exception too
* Add shared tests to ItSqlAsynchronousApiTest, ItSqlSynchronousApiTest"	IGNITE	Resolved	3	1	8306	ignite-3
13026623	.NET: Support BinaryFieldsIdentityResolver	"IGNITE-4045 introduced DML API with Binary resolver as the only option.

Field resolver is partially implemented and hidden. It requires GetHashCode implementations with Java algorithms for all basic types:
bool, byte/sbyte, short/ushort, char, int/uint, long/ulong, float, double, string, decimal, Guid, DateTime"	IGNITE	Resolved	3	4	8306	.NET
13525888	.NET: Thin 3.0: Implement client-side metrics	"Implement client-side metrics in .NET client as described in IGNITE-18759
* Use [System.Diagnostics.Metrics|https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics?view=net-7.0]
** https://learn.microsoft.com/en-us/dotnet/core/diagnostics/metrics-instrumentation"	IGNITE	Resolved	3	4	8306	.NET, ignite-3
13501117	.NET: Thin 3.0: LINQ: Distinct support	Add full support for *Distinct*. Some scenarios do not work currently - see *TestSelectOrderDistinct*.	IGNITE	Resolved	3	4	8306	.NET, LINQ, ignite-3
13260553	.NET: Add ContinuousQueryWithTransformer	"ContinuousQueryWithTransformer is a powerful mechanism to improve continuous query performance by sending only relevant data back to listener nodes.
https://apacheignite.readme.io/docs/continuous-queries#section-remote-transformer"	IGNITE	Open	3	4	8306	.NET
13024758	.NET: Use BinaryArrayIdentityResolver by default	"Current legacy behavior calculates hash codes by calling Object.GetHashCode(), but equality comparison is performed by comparing byte arrays in binary form, which is inconsistent and can lead to unexpected behavior with user-defined keys.

In 2.0 we should replace default behavior with ArrayResolver so that Equals and GetHashCode are consistent."	IGNITE	Resolved	3	4	8306	.NET, breaking-api
13537312	Thin 3.0: Data Streamer with Receiver	Implement data streamer with receiver in Java client - see [IEP-121|https://cwiki.apache.org/confluence/display/IGNITE/IEP-121%3A+Data+Streamer+with+Receiver]	IGNITE	Resolved	3	3	8306	iep-102, iep-121, ignite-3
13315210	.NET: Consolidate tests - get rid of Tests.DotNetCore folder	"Right now we have a separate directory for .NET Core tests, and most test files are shared across Apache.Ignite.Core.Tests and Apache.Ignite.Core.Tests.DotNetCore projects.

Move Apache.Ignite.Core.Tests.DotNetCore.csproj to Apache.Ignite.Core.Tests directory, so that all tests are included into DotNetCore project by default.

Incompatible tests should be excluded specifically from the project, or using compiler directives (#if !NETCOREAPP)."	IGNITE	Resolved	4	4	8306	.NET
13458249	.NET: Thin client: Add IgniteSet	Add IgniteSet data structure to .NET thin client.	IGNITE	Resolved	3	2	8306	.NET
13424275	.NET: Thin 3.0: Support value types in the Table API	"Table API is constrained to reference types currently:
{code}
interface IRecordView<T> where T : class
{code}

Remove this constraint. This will require changing all APIs that potentially return null:
* Get
* GetAll
* GetAndUpsert
* GetAndReplace
* GetAndDelete

Single-key APIs can be changed to {{bool TryGet(K, out V)}} format. GetAll - not clear, investigate."	IGNITE	Resolved	3	4	8306	.NET, ignite-3
13572030	Java thin 3.0: DataStreamer partition awareness might break if assignment is not available at the moment	"* *ClientTable.getPartitionAssignment* might return an empty list
* *AbstractClientStreamerPartitionAwarenessProvider* assumes that partition count can't change

Therefore, if some server node lags behind and returns an empty assignment for a given timestamp, streamer partition awareness won't work at all.

*Potential Fixes*
* Wait for assignment on the server, do not return empty/null - might affect performance
* Return correct partition count, but null values - faster and simpler"	IGNITE	Resolved	3	1	8306	ignite-3
13431747	.NET: Missing binary schema when field is removed	"When putting IBinarilizable instance with different field set, schema is not sent to cluster, leading to failure if another node tries to get value from cache.

{code}

Apache.Ignite.Core.Binary.BinaryObjectException : Cannot find schema for object with compact footer [typeId=-1422440667, schemaId=-935090685]
   at Apache.Ignite.Core.Impl.Binary.BinaryObjectSchemaSerializer.GetFieldIds(BinaryObjectHeader hdr, IIgniteInternal ignite) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Binary/BinaryObjectSchemaSerializer.cs:line 307
   at Apache.Ignite.Core.Impl.Binary.BinaryObjectSchemaSerializer.GetFieldIds(BinaryObjectHeader hdr, IIgniteInternal ignite, IBinaryStream stream, Int32 objectPos) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Binary/BinaryObjectSchemaSerializer.cs:line 262
   at Apache.Ignite.Core.Impl.Binary.BinaryReader.SetCurSchema(IBinaryTypeDescriptor desc) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Binary/BinaryReader.cs:line 803
   at Apache.Ignite.Core.Impl.Binary.BinaryReader.ReadFullObject[T](Int32 pos, Type typeOverride) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Binary/BinaryReader.cs:line 751
   at Apache.Ignite.Core.Impl.Binary.BinaryReader.TryDeserialize[T](T& res, Type typeOverride) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Binary/BinaryReader.cs:line 577
   at Apache.Ignite.Core.Impl.Binary.BinaryReader.Deserialize[T](Type typeOverride) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Binary/BinaryReader.cs:line 536
   at Apache.Ignite.Core.Impl.Binary.BinaryReader.ReadBinaryObject[T](Boolean doDetach) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Binary/BinaryReader.cs:line 635
   at Apache.Ignite.Core.Impl.Binary.BinaryReader.TryDeserialize[T](T& res, Type typeOverride) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Binary/BinaryReader.cs:line 582
   at Apache.Ignite.Core.Impl.Binary.BinaryReader.Deserialize[T](Type typeOverride) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Binary/BinaryReader.cs:line 536
   at Apache.Ignite.Core.Impl.Binary.Marshaller.Unmarshal[T](IBinaryStream stream, BinaryMode mode, BinaryObjectBuilder builder) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Binary/Marshaller.cs:line 295
   at Apache.Ignite.Core.Impl.Binary.Marshaller.Unmarshal[T](IBinaryStream stream, Boolean keepBinary) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Binary/Marshaller.cs:line 268
   at Apache.Ignite.Core.Impl.Cache.CacheImpl`2.Unmarshal[T](IBinaryStream stream) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/CacheImpl.cs:line 1750
   at Apache.Ignite.Core.Impl.Cache.CacheImpl`2.<>c__DisplayClass146_0.<DoOutInOpNullable>b__1(IBinaryStream stream, Int64 res) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/CacheImpl.cs:line 1907
   at Apache.Ignite.Core.Impl.PlatformJniTarget.InStreamOutLong[TR](Int32 type, Func`2 outAction, Func`3 inAction, Func`2 readErrorAction) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/PlatformJniTarget.cs:line 214
   at Apache.Ignite.Core.Impl.PlatformTargetAdapter.DoOutInOpX[TR](Int32 type, Action`1 outAction, Func`3 inAction, Func`2 inErrorAction) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/PlatformTargetAdapter.cs:line 236
   at Apache.Ignite.Core.Impl.Cache.CacheImpl`2.DoOutInOpNullable(CacheOp cacheOp, TK x) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/CacheImpl.cs:line 1905
   at Apache.Ignite.Core.Impl.Cache.CacheImpl`2.TryGet(TK key, TV& value) in /home/ivandasch/Job/ignite-pmdk/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/CacheImpl.cs:line 592
{code}"	IGNITE	Resolved	3	1	8306	.NET, ise.lts
13559497	.NET: Thin 3.0: TestMicrosoftConsoleLogger is flaky	"Thread safety issues lead to occasional exceptions:

{code}
System.ArgumentOutOfRangeException : Index was out of range. Must be non-negative and less than the size of the collection. (Parameter 'chunkLength')
   at System.Text.StringBuilder.ToString()
   at Apache.Ignite.Tests.LoggingTests.TestMicrosoftConsoleLogger() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/LoggingTests.cs:line 87
   at NUnit.Framework.Internal.TaskAwaitAdapter.GenericAdapter`1.BlockUntilCompleted()
   at NUnit.Framework.Internal.MessagePumpStrategy.NoMessagePumpStrategy.WaitForCompletion(AwaitAdapter awaiter)
   at NUnit.Framework.Internal.AsyncToSyncAdapter.Await(Func`1 invoke)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.RunTestMethod(TestExecutionContext context)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.Execute(TestExecutionContext context)
   at NUnit.Framework.Internal.Commands.TimeoutCommand.<>c__DisplayClass5_0.<RunTestOnSeparateThread>b__0()
   at System.Threading.Tasks.Task`1.InnerInvoke()
   at System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, Object state)
--- End of stack trace from previous location ---
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task& currentTaskSlot, Thread threadPoolThread)
--- End of stack trace from previous location ---
   at NUnit.Framework.Internal.Commands.TimeoutCommand.Execute(TestExecutionContext context)
{code}

We should synchronize the access to the underlying StringBuilder.

https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunNetTests/7656452?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildTestsSection=true"	IGNITE	Resolved	3	1	8306	ignite-3
13419699	.NET: Thin 3.0: Add RetryPolicy	Implement retryPolicy like in 2.x, see https://cwiki.apache.org/confluence/display/IGNITE/IEP-82+Thin+Client+Retry+Policy	IGNITE	Resolved	3	4	8306	iep-82, ignite-3
13524186	.NET: Thin 3.0: Document LINQ features	Add README.md which describes all supported LINQ features.	IGNITE	Resolved	3	4	8306	LINQ, ignite-3
13586626	.NET: TestMicrosoftConsoleLogger is flaky	"Still flaky, IGNITE-20967 fix was not enough.

{code}
System.ArgumentOutOfRangeException : Index was out of range. Must be non-negative and less than the size of the collection. (Parameter 'chunkLength')
   at System.Text.StringBuilder.ToString()
   at Apache.Ignite.Tests.LoggingTests.TestMicrosoftConsoleLogger() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/LoggingTests.cs:line 101
   at NUnit.Framework.Internal.TaskAwaitAdapter.GenericAdapter`1.BlockUntilCompleted()
   at NUnit.Framework.Internal.MessagePumpStrategy.NoMessagePumpStrategy.WaitForCompletion(AwaitAdapter awaiter)
   at NUnit.Framework.Internal.AsyncToSyncAdapter.Await(Func`1 invoke)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.RunTestMethod(TestExecutionContext context)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.Execute(TestExecutionContext context)
   at NUnit.Framework.Internal.Commands.BeforeAndAfterTestCommand.<>c__DisplayClass1_0.<Execute>b__0()
   at NUnit.Framework.Internal.Commands.DelegatingTestCommand.RunTestMethodInThreadAbortSafeZone(TestExecutionContext context, Action action)
{code}

https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunAllTests/8334607?expandBuildDeploymentsSection=false&hideTestsFromDependencies=false&expandBuildTestsSection=true&hideProblemsFromDependencies=false&expandBuildProblemsSection=true&expandCode+Inspection=true&expandBuildChangesSection=true"	IGNITE	Resolved	3	1	8306	ignite-3
13119240	.NET: Support pointer serialization	"Serializing pointers does not make sense and we already throw on {{IntPtr}} fields.
However, .NET serializer ({{BinaryFormatter}}) supports both {{IntPtr}} and {{void*}}-style pointers.

Our goal is to replace standard serializer and allow seamless transition, so we should do the same."	IGNITE	Resolved	3	4	8306	.NET
13151489	.NET: Invalid cast to CacheEvent	"Subscribed to all events

config.IncludedEventTypes = EventType.All;
ignite = Ignition.Start(config);
 var events = ignite.GetEvents();
 var listener = new CacheEventListener();
 events.LocalListen(listener, EventType.All);

and got exceptions:

[23:56:22 ERR] Failure in Java callback
System.InvalidCastException: Unable to cast object of type 'Apache.Ignite.Core.Events.CacheQueryExecutedEvent' to type 'Apache.Ignite.Core.Events.CacheEvent'.
 at Apache.Ignite.Core.Events.EventReader.Read[T](BinaryReader reader)
 at Apache.Ignite.Core.Impl.Events.Events.InvokeLocalListener[T](IBinaryStream stream, IEventListener`1 listener)
 at Apache.Ignite.Core.Impl.Events.Events.LocalHandledEventFilter.Invoke(IBinaryStream stream)
 at Apache.Ignite.Core.Impl.Unmanaged.UnmanagedCallbacks.EventFilterApply(Int64 ptr, Int64 memPtr, Int64 unused, Void* arg)
 at Apache.Ignite.Core.Impl.Unmanaged.UnmanagedCallbacks.InLongLongLongObjectOutLong(Void* target, Int32 type, Int64 val1, Int64 val2, Int64 val3, Void* arg)
[23:56:22 ERR] Failure in Java callback
System.InvalidCastException: Unable to cast object of type 'Apache.Ignite.Core.Events.CacheQueryExecutedEvent' to type 'Apache.Ignite.Core.Events.CacheEvent'.
 at Apache.Ignite.Core.Events.EventReader.Read[T](BinaryReader reader)
 at Apache.Ignite.Core.Impl.Events.Events.InvokeLocalListener[T](IBinaryStream stream, IEventListener`1 listener)
 at Apache.Ignite.Core.Impl.Events.Events.LocalHandledEventFilter.Invoke(IBinaryStream stream)
 at Apache.Ignite.Core.Impl.Unmanaged.UnmanagedCallbacks.EventFilterApply(Int64 ptr, Int64 memPtr, Int64 unused, Void* arg)
 at Apache.Ignite.Core.Impl.Unmanaged.UnmanagedCallbacks.InLongLongLongObjectOutLong(Void* target, Int32 type, Int64 val1, Int64 val2, Int64 val3, Void* arg)
[23:56:22 ERR] Failure in Java callback
System.InvalidCastException: Unable to cast object of type 'Apache.Ignite.Core.Events.DiscoveryEvent' to type 'Apache.Ignite.Core.Events.CacheEvent'.
 at Apache.Ignite.Core.Events.EventReader.Read[T](BinaryReader reader)
 at Apache.Ignite.Core.Impl.Events.Events.InvokeLocalListener[T](IBinaryStream stream, IEventListener`1 listener)
 at Apache.Ignite.Core.Impl.Events.Events.LocalHandledEventFilter.Invoke(IBinaryStream stream)
 at Apache.Ignite.Core.Impl.Unmanaged.UnmanagedCallbacks.EventFilterApply(Int64 ptr, Int64 memPtr, Int64 unused, Void* arg)
 at Apache.Ignite.Core.Impl.Unmanaged.UnmanagedCallbacks.InLongLongLongObjectOutLong(Void* target, Int32 type, Int64 val1, Int64 val2, Int64 val3, Void* arg)
[23:56:22 ERR] Unexpected exception in listener notification for event: CacheQueryExecutedEvent [qryType=SCAN, cacheName=ignite-sys-cache, clsName=null, clause=null, scanQryFilter=ServiceAssignmentsPredicate [], contQryFilter=null, args=null, subjId=782e4d31-f4c5-4bea-a9fb-0f2e4d6b602f, taskName=null, nodeId8=782e4d31, msg=Scan query executed., type=CACHE_QUERY_EXECUTED, tstamp=1523393782062]
[23:56:23 ERR] Unexpected exception in listener notification for event: CacheQueryExecutedEvent [qryType=CONTINUOUS, cacheName=Authorization, clsName=null, clause=null, scanQryFilter=null, contQryFilter=o.a.i.i.processors.platform.cache.query.PlatformContinuousQueryImpl@1b84f475, args=null, subjId=782e4d31-f4c5-4bea-a9fb-0f2e4d6b602f, taskName=null, nodeId8=782e4d31, msg=Continuous query executed., type=CACHE_QUERY_EXECUTED, tstamp=1523393782095]
[23:56:23 ERR] Unexpected exception in listener notification for event: DiscoveryEvent [evtNode=TcpDiscoveryNode [id=0ee0988a-8364-4560-8215-e1dbe673bcd5, addrs=[0:0:0:0:0:0:0:1, 10.77.6.203, 127.0.0.1, 192.168.2.21], sockAddrs=[WA/192.168.2.21:47500, /10.77.6.203:47500, /0:0:0:0:0:0:0:1:47500, /127.0.0.1:47500], discPort=47500, order=1, intOrder=1, lastExchangeTime=1523393780217, loc=false, ver=2.3.0#20171028-sha1:8add7fd5, isClient=false], topVer=3, nodeId8=782e4d31, msg=Metrics were updated: TcpDiscoveryNode [id=0ee0988a-8364-4560-8215-e1dbe673bcd5, addrs=[0:0:0:0:0:0:0:1, 10.77.6.203, 127.0.0.1, 192.168.2.21], sockAddrs=[WA/192.168.2.21:47500, /10.77.6.203:47500, /0:0:0:0:0:0:0:1:47500, /127.0.0.1:47500], discPort=47500, order=1, intOrder=1, lastExchangeTime=1523393780217, loc=false, ver=2.3.0#20171028-sha1:8add7fd5, isClient=false], type=NODE_METRICS_UPDATED, tstamp=1523393782728]"	IGNITE	Closed	3	1	8306	.NET
13562986	.NET: Thin 3.0: TestExecuteColocatedUpdatesTableCacheOnTableDrop is flaky	"Apache.Ignite.Tests.Compute.ComputeTests.TestExecuteColocatedUpdatesTableCacheOnTableDrop is flaky:

{code}
Apache.Ignite.TableNotFoundException : Table not found: 46
  ----> Apache.Ignite.IgniteException : org.apache.ignite.lang.TableNotFoundException: IGN-TBL-2 TraceId:ee0df118-c9cf-499e-9325-6fe842d5251b Table not found: 46
  at org.apache.ignite.client.handler.ClientPrimaryReplicaTracker.tableNotFoundException(ClientPrimaryReplicaTracker.java:344)
  at org.apache.ignite.client.handler.ClientPrimaryReplicaTracker.partitionsNoWait(ClientPrimaryReplicaTracker.java:231)
  at org.apache.ignite.client.handler.ClientPrimaryReplicaTracker.lambda$partitionsAsync$3(ClientPrimaryReplicaTracker.java:224)
  at java.base/java.util.concurrent.CompletableFuture$UniApply.tryFire(CompletableFuture.java:642)
  at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
  at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
  at org.apache.ignite.internal.util.PendingComparableValuesTracker.lambda$completeWaitersOnUpdate$0(PendingComparableValuesTracker.java:169)
  at java.base/java.util.concurrent.ConcurrentMap.forEach(ConcurrentMap.java:122)
  at org.apache.ignite.internal.util.PendingComparableValuesTracker.completeWaitersOnUpdate(PendingComparableValuesTracker.java:169)
  at org.apache.ignite.internal.util.PendingComparableValuesTracker.update(PendingComparableValuesTracker.java:103)
  at org.apache.ignite.internal.metastorage.server.time.ClusterTimeImpl.updateSafeTime(ClusterTimeImpl.java:146)
  at org.apache.ignite.internal.metastorage.impl.MetaStorageManagerImpl.onSafeTimeAdvanced(MetaStorageManagerImpl.java:849)
  at org.apache.ignite.internal.metastorage.impl.MetaStorageManagerImpl$1.onSafeTimeAdvanced(MetaStorageManagerImpl.java:456)
  at org.apache.ignite.internal.metastorage.server.WatchProcessor.lambda$advanceSafeTime$9(WatchProcessor.java:322)
  at java.base/java.util.concurrent.CompletableFuture$UniRun.tryFire(CompletableFuture.java:783)
  at java.base/java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:478)
  at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
  at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
  at java.base/java.lang.Thread.run(Thread.java:834)
   at Apache.Ignite.Internal.ClientSocket.DoOutInOpAsync(ClientOp clientOp, PooledArrayBuffer request, Boolean expectNotifications) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/ClientSocket.cs:line 304
   at Apache.Ignite.Internal.ClientFailoverSocket.DoOutInOpAndGetSocketAsync(ClientOp clientOp, Transaction tx, PooledArrayBuffer request, PreferredNode preferredNode, IRetryPolicy retryPolicyOverride, Boolean expectNotifications) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/ClientFailoverSocket.cs:line 204
   at Apache.Ignite.Internal.ClientFailoverSocket.DoOutInOpAsync(ClientOp clientOp, PooledArrayBuffer request, PreferredNode preferredNode, Boolean expectNotifications) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/ClientFailoverSocket.cs:line 153
   at Apache.Ignite.Internal.Table.Table.LoadPartitionAssignmentAsync(Int64 timestamp) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/Table/Table.cs:line 404
   at Apache.Ignite.Internal.Table.Table.GetPartitionAssignmentAsync() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/Table/Table.cs:line 239
   at Apache.Ignite.Internal.Table.Table.GetPreferredNode(Int32 colocationHash, ITransaction transaction) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/Table/Table.cs:line 198
   at Apache.Ignite.Internal.Compute.Compute.ExecuteColocatedAsync[T,TKey](String tableName, TKey key, Func`2 serializerHandlerFunc, IEnumerable`1 units, String jobClassName, Object[] args) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/Compute/Compute.cs:line 268
   at Apache.Ignite.Internal.Compute.Compute.ExecuteColocatedAsync[T](String tableName, IIgniteTuple key, IEnumerable`1 units, String jobClassName, Object[] args) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/Compute/Compute.cs:line 82
   at Apache.Ignite.Tests.Compute.ComputeTests.TestExecuteColocatedUpdatesTableCacheOnTableDrop() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/Compute/ComputeTests.cs:line 321
   at Apache.Ignite.Tests.Compute.ComputeTests.TestExecuteColocatedUpdatesTableCacheOnTableDrop() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/Compute/ComputeTests.cs:line 328
   at NUnit.Framework.Internal.TaskAwaitAdapter.GenericAdapter`1.BlockUntilCompleted()
   at NUnit.Framework.Internal.MessagePumpStrategy.NoMessagePumpStrategy.WaitForCompletion(AwaitAdapter awaiter)
   at NUnit.Framework.Internal.AsyncToSyncAdapter.Await(Func`1 invoke)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.RunTestMethod(TestExecutionContext context)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.Execute(TestExecutionContext context)
   at NUnit.Framework.Internal.Commands.BeforeAndAfterTestCommand.<>c__DisplayClass1_0.<Execute>b__0()
   at NUnit.Framework.Internal.Commands.DelegatingTestCommand.RunTestMethodInThreadAbortSafeZone(TestExecutionContext context, Action action)
--IgniteException
{code}


Related to IGNITE-20701 changes."	IGNITE	Resolved	3	1	8306	.NET, ignite-3
13099567	.NET: Thin client: Basic exception handling	Exception handling in thin client: response includes a success flag. Define exception format protocol in case of failure.	IGNITE	Resolved	3	4	8306	.NET
13074120	.NET: MemoryMetrics API improvements to be ported to .NET	Improvements already made for linked ticket need to be ported on .NET side. 	IGNITE	Resolved	3	3	8306	.NET, important
13105511	.NET: PersistentStoreConfiguration.WriteThrottlingEnabled	Add {{PersistentStoreConfiguration.WriteThrottlingEnabled}} to .NET.	IGNITE	Resolved	3	4	8306	.NET
13305851	.NET: SqlFieldsQuery as ContinuousQuery.InitialQuery	"SqlQuery has been deprecated in favor of SqlFieldsQuery, but ContinuousQuery in Ignite.NET does not allow SqlFieldsQuery as InitialQuery. 

Java API allows that, so we have to derive SqlFieldsQuery from QueryBase and make it work.
The problem will arise when SqlFieldsQuery does not return _key & _val - see how Java handles this."	IGNITE	Resolved	2	2	8306	.NET
13271885	.NET: XMLDoc does not work when using Ignite NuGet from .NET Core	"* Create new .NET Core project (2.x or 3.x): dotnet new console
* Install nightly build of 2.8.0: dotnet add package Apache.Ignite -v 2.8.0-alpha20191118
* Open the project in any IDE (VS, VSCode, Rider) and start using Ignite APIs

There is no documentation in IDE tooltips. NuGet package is malformed."	IGNITE	Resolved	2	1	8306	.NET
13076105	.NET: Pure SQL & DDL example	Create an example where all operations are performed via SQL API, not using cache API. See IGNITE-5159.	IGNITE	Resolved	3	4	8306	.NET
13075138	.NET: DML update via LINQ	"Bulk update with LINQ:

{code}
var persons = ignite.GetCache<int, Person>(""persons"").AsCacheQueryable();

int affectedRows = persons.Where(x => x.Key > 10).UpdateAll(x => x.Value.OrgId = 7);
{code}

See bulk delete with {{RemoveAll}}, IGNITE-4904."	IGNITE	Resolved	3	2	8306	.NET, LINQ, important
13494787	.NET: Thin 3.0: LINQ: Joins	Support queries with joins in the LINQ provider.	IGNITE	Resolved	3	4	8306	.NET, LINQ, ignite-3
13538557	.NET: Thin 3.0: Optimize Data Streamer for single connection use case	"Optimize .NET client data streamer for a use case when only one connection exists. In this case we don't need to deal with partition awareness and per-node buffers.

This can be detected automatically or by a flag in DataStreamerOptions."	IGNITE	Open	3	3	8306	.NET, iep-102, ignite-3, performance
13398977	.NET: Thin 3.0: Add support for all native data types	"Add support for all data types in .NET thin client: Date, Time, etc - see -org.apache.ignite.client.proto.ClientDataType- *org.apache.ignite.internal.schema.NativeTypes*.

* We now use *BinaryTuple* format to exchange row data => .NET *BinaryTuple* implementation should be updated to support all missing types.
* Update *IgniteTuple*
* Support those types in object mapper (*IRecordView<T>*)"	IGNITE	Resolved	3	4	8306	.NET, iep-78, ignite-3
13315032	.NET different behavior when using TransactionScope and  ITransactions.Start	"Next code runs fine:

{code:c#}
            var barier = new Barrier(2);
            var cache = Cache();
            cache.Put(1, 1);
            var task = Task.Factory.StartNew(() =>
            {
                var otherCache = Cache();
                barier.SignalAndWait();
                otherCache.Put(1, 10);
                barier.SignalAndWait();
            });
            using (var txscp = new TransactionScope(TransactionScopeOption.Required, new TransactionOptions{IsolationLevel = IsolationLevel.Serializable}))
            {
                var before = cache.Get(1);
                barier.SignalAndWait();
                barier.SignalAndWait();
                txscp.Complete();
            }
            Task.WaitAll(task);
            barier.Dispose();
{code}

When I switch to Ignite transactions I get exception:

{code:c#}
            using (var tx = Transactions.TxStart(TransactionConcurrency.Optimistic, TransactionIsolation.Serializable))
            {
                var before = cache.Get(1);
                barier.SignalAndWait();
                barier.SignalAndWait();
                tx.Commit();
            }
{code}

{noformat}
Apache.Ignite.Core.Transactions.TransactionOptimisticException : Failed to prepare transaction (lock conflict): GridNearTxLocal [mappings=IgniteTxMappingsImpl [], 
{noformat}

_Cache_ is _IIgnite.Cache<int, int>()_  and _Transactions_ is _IIgnite.GetTransactions()_"	IGNITE	Resolved	2	1	8306	.NET, transactions
13422714	.NET: Failed to wait for asynchronous operation permit	"We have an ignite cluster with native storage enabled which we use as a distributed database and compute engine which is embedded in a .net application. 

As we are aware that .NET5 is supported we use that framework. 

When we try to upgrade our cluster to use .NET6 we get the below error. It is hard to tell if it is something else or some minor incompatibility causing an error somewhere. However, reverting to .NET5 makes the issue disappear. So I assume we need .NET6 to be officially supported.
{code:java}
Apache.Ignite.Core.Cache.CacheException: 'class org.apache.ignite.IgniteInterruptedException: Failed to wait for asynchronous operation permit (thread got interrupted).'JavaException: javax.cache.CacheException: class org.apache.ignite.IgniteInterruptedException: Failed to wait for asynchronous operation permit (thread got interrupted).
    at org.apache.ignite.internal.processors.cache.GridCacheUtils.convertToCacheException(GridCacheUtils.java:1266)
    at org.apache.ignite.internal.processors.cache.IgniteCacheProxyImpl.cacheException(IgniteCacheProxyImpl.java:2084)
    at org.apache.ignite.internal.processors.cache.IgniteCacheProxyImpl.get(IgniteCacheProxyImpl.java:1111)
    at org.apache.ignite.internal.processors.cache.GatewayProtectedCacheProxy.get(GatewayProtectedCacheProxy.java:688)
    at org.apache.ignite.internal.processors.platform.cache.PlatformCache.processInStreamOutLong(PlatformCache.java:455)
    at org.apache.ignite.internal.processors.platform.PlatformTargetProxyImpl.inStreamOutLong(PlatformTargetProxyImpl.java:67)
    at org.apache.ignite.internal.processors.platform.callback.PlatformCallbackUtils.inLongLongLongObjectOutLong(Native Method)
    at org.apache.ignite.internal.processors.platform.callback.PlatformCallbackGateway.computeJobExecuteLocal(PlatformCallbackGateway.java:312)
    at org.apache.ignite.internal.processors.platform.compute.PlatformAbstractJob.runLocal(PlatformAbstractJob.java:134)
    at org.apache.ignite.internal.processors.platform.compute.PlatformClosureJob.execute0(PlatformClosureJob.java:94)
    at org.apache.ignite.internal.processors.platform.compute.PlatformAbstractJob.execute(PlatformAbstractJob.java:80)
    at org.apache.ignite.internal.processors.job.GridJobWorker$2.call(GridJobWorker.java:601)
    at org.apache.ignite.internal.util.IgniteUtils.wrapThreadLoader(IgniteUtils.java:7126)
    at org.apache.ignite.internal.processors.job.GridJobWorker.execute0(GridJobWorker.java:595)
    at org.apache.ignite.internal.processors.job.GridJobWorker.body(GridJobWorker.java:522)
    at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:120)
    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
    at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: class org.apache.ignite.IgniteInterruptedException: Failed to wait for asynchronous operation permit (thread got interrupted).
    at org.apache.ignite.internal.util.IgniteUtils$3.apply(IgniteUtils.java:919)
    at org.apache.ignite.internal.util.IgniteUtils$3.apply(IgniteUtils.java:917)
    ... 19 more
Caused by: java.lang.InterruptedException
    at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1047)
    at java.base/java.util.concurrent.Semaphore.acquire(Semaphore.java:318)
    at org.apache.ignite.internal.processors.cache.GridCacheAdapter.asyncOpAcquire(GridCacheAdapter.java:4710)
    at org.apache.ignite.internal.processors.cache.distributed.dht.atomic.GridDhtAtomicCache.asyncOp(GridDhtAtomicCache.java:777)
    at org.apache.ignite.internal.processors.cache.distributed.dht.atomic.GridDhtAtomicCache.getAsync(GridDhtAtomicCache.java:483)
    at org.apache.ignite.internal.processors.cache.GridCacheAdapter.get(GridCacheAdapter.java:4894)
    at org.apache.ignite.internal.processors.cache.GridCacheAdapter.repairableGet(GridCacheAdapter.java:4860)
    at org.apache.ignite.internal.processors.cache.GridCacheAdapter.get(GridCacheAdapter.java:1476)
    at org.apache.ignite.internal.processors.cache.IgniteCacheProxyImpl.get(IgniteCacheProxyImpl.java:1108)
    ... 16 more{code}"	IGNITE	Resolved	3	2	8306	newbie
13268784	.NET: Fix NuGet package warnings	"When uploading a NuGet package, the following warnings are issued:
* {{The <licenseUrl> element is deprecated. Consider using the <license> element instead.}}
* {{The <iconUrl> element is deprecated. Consider using the <icon> element instead.}}"	IGNITE	Resolved	3	4	8306	.NET
13470312	Thin 3.0: Unified exception handling	"Java thin client uses the same public API interfaces as the server side.
Those user-facing APIs should behave in the same way on the server and client sides, including exceptions that may be thrown.

# Remove *IgniteClientException*. 
# Keep *IgniteClientConnectionException* and other client-specific types. Inherit them from *IgniteException*.
# When sending exception details from server to client, include the following:
## Code (group  + error, see IgniteException.code)
## TraceId
## Message
## Fully-qualified class name
## OPTIONALLY: stack trace (Sensitive info. Send only when enabled in server-side ClientConnectorConfig. Disabled by default.)"	IGNITE	Resolved	3	4	8306	ignite-3
13541171	Java thin 3.0: Partition awareness uses wrong node id	"There is a confusion between *Local Node ID* (which we get from protocolContext().clusterNode().id()) and *Consistent Node ID* (which is the same as Node Name, comes from protocolContext().clusterNode().name()). Partition assignment (returned by ClientTablePartitionAssignmentGetRequest on the server) is based on *Consistent Node ID*.

All partition awareness tests use FakeServer, so we never tested that it actually works."	IGNITE	Resolved	1	1	8306	ignite-3
13108943	.NET: Thin client: XML configuration	Provide a way to configure {{IgniteClientConfiguration}} in XML, similar to {{IgniteConfiguration}}.	IGNITE	Resolved	3	4	8306	.NET
13342536	.NET: LINQ provider emits incorrect table alias for queries with JOIN and GROUP BY combined	"See the attached reproducer. Generated SQL is:
{code}
select _T0.MEETINGID, max (_T0.AttachmentDate)  from USERSCHEMA.MEETING as _T0 inner join USERSCHEMA.MEETINGATTACHMENT as _T1 on (_T1.MEETINGID = _T0.MEETINGID) group by (_T0.MEETINGID)
{code}

{{_T0.AttachmentDate}} should be {{_T1.AttachmentDate}} here."	IGNITE	Resolved	3	1	8306	.NET
13268955	.NET: Separate NuGet package for Thin Client	"Right now Thin Client is shipped as part of the same NuGet package as full Ignite.NET.
This package includes jar files, which take a lot of disk space and are not required for Thin Client at all.

We should extract common functionality into a separate assembly, and ship thin client in a separate, lighter package."	IGNITE	Open	3	4	8306	.NET
13355420	.NET Thin Client: Add connection limit configuration property	"With partition awareness enabled, the thin client connects to every server node in the cluster.
Provide a config property to limit the number of connections to limit the resource usage on servers and clients."	IGNITE	Open	3	4	8306	.NET
13538377	Embedded Basic Data Streamer	Implement basic data streamer in Java embedded API (*RecordViewImpl*, *KeyValueViewImpl*, *RecordBinaryViewImpl*, *KeyValueBinaryViewImpl*) without receiver - see Use Case 1 in the [IEP-102|https://cwiki.apache.org/confluence/display/IGNITE/IEP-102%3A+Data+Streamer].	IGNITE	Resolved	3	3	8306	iep-102, ignite-3
13147440	".NET: Add ""authenticationEnabled"" flag to IgniteConfiguration"	Need to pass flag added as a part of IGNITE-7436.	IGNITE	Resolved	3	3	8306	MakeTeamcityGreenAgain
13092447	.NET: Incorrect conflicting type error	"Incorrect conflicting type error can occur when registering the same time from multiple threads simultaneously:

{code}
Conflicting type IDs [type1='Row', type2='Row', typeId=113114]
{code}

{{Marshaller.AddType}} should check if existing type is the same as new one (as we do it in {{AddUserType}}, see other usages of {{ThrowConflictingTypeError}})."	IGNITE	Resolved	2	1	8306	.NET
13595613	testNoResponseFromServerWithinConnectTimeoutThrowsException is flaky	"https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunAllTests/8554366?hideTestsFromDependencies=false&hideProblemsFromDependencies=false&expandBuildDeploymentsSection=false&expandCode+Inspection=true&expandBuildProblemsSection=true&expandBuildTestsSection=true&expandBuildChangesSection=true

{code}
java.lang.AssertionError: Exception has not been thrown.
  at org.apache.ignite.internal.testframework.IgniteTestUtils.assertThrowsWithCause(IgniteTestUtils.java:360)
  at org.apache.ignite.internal.testframework.IgniteTestUtils.assertThrowsWithCause(IgniteTestUtils.java:334)
  at org.apache.ignite.client.ConnectionTest.testNoResponseFromServerWithinConnectTimeoutThrowsException(ConnectionTest.java:107)
  at java.base/java.lang.reflect.Method.invoke(Method.java:566)
  at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
  at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
------- Stdout: -------
[2024-10-15T14:43:35,143][INFO ][Test worker][ConnectionTest] >>> Starting test: ConnectionTest#testNoResponseFromServerWithinConnectTimeoutThrowsException, displayName: testNoResponseFromServerWithinConnectTimeoutThrowsException()
[2024-10-15T14:43:35,698][INFO ][%127.0.0.133363%TcpClientChannel-timeout-worker][TcpClientChannel] The timeout worker was interrupted, probably the worker is stopping.
[2024-10-15T14:43:35,704][INFO ][Test worker][ConnectionTest] >>> Stopping test: ConnectionTest#testNoResponseFromServerWithinConnectTimeoutThrowsException, displayName: testNoResponseFromServerWithinConnectTimeoutThrowsException(), cost: 560ms.
------- Stderr: -------
[2024-10-15T14:43:35,698][WARN ][nioEventLoopGroup-226-1][DefaultChannelPipeline] An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
java.io.IOException: Connection reset by peer
  at java.base/sun.nio.ch.FileDispatcherImpl.read0(Native Method) ~[?:?]
  at java.base/sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:39) ~[?:?]
  at java.base/sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:276) ~[?:?]
  at java.base/sun.nio.ch.IOUtil.read(IOUtil.java:233) ~[?:?]
  at java.base/sun.nio.ch.IOUtil.read(IOUtil.java:223) ~[?:?]
  at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:358) ~[?:?]
  at io.netty.buffer.PooledByteBuf.setBytes(PooledByteBuf.java:255) ~[netty-buffer-4.1.114.Final.jar:4.1.114.Final]
  at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1132) ~[netty-buffer-4.1.114.Final.jar:4.1.114.Final]
  at io.netty.buffer.WrappedByteBuf.writeBytes(WrappedByteBuf.java:821) ~[netty-buffer-4.1.114.Final.jar:4.1.114.Final]
  at io.netty.buffer.AdvancedLeakAwareByteBuf.writeBytes(AdvancedLeakAwareByteBuf.java:636) ~[netty-buffer-4.1.114.Final.jar:4.1.114.Final]
  at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:356) ~[netty-transport-4.1.114.Final.jar:4.1.114.Final]
  at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:151) [netty-transport-4.1.114.Final.jar:4.1.114.Final]
  at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788) [netty-transport-4.1.114.Final.jar:4.1.114.Final]
  at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724) [netty-transport-4.1.114.Final.jar:4.1.114.Final]
  at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650) [netty-transport-4.1.114.Final.jar:4.1.114.Final]
  at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562) [netty-transport-4.1.114.Final.jar:4.1.114.Final]
  at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) [netty-common-4.1.114.Final.jar:4.1.114.Final]
  at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.114.Final.jar:4.1.114.Final]
  at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.114.Final.jar:4.1.114.Final]
  at java.base/java.lang.Thread.run(Thread.java:834) [?:?]
{code}"	IGNITE	Resolved	3	1	8306	ignite-3
13566880	DataStreamer data removal: investigate and design	"* Investigate if we can support data removal in Ignite 3 Data Streamer
* Propose an API
* Create tickets"	IGNITE	Resolved	3	3	8306	ignite-3
13297458	.NET: Rename PlatformNearCache to PlatformCache, mark as Experimental	"PlatformNearCache is not actually ""Near"" - it just mirrors cache entries that are present on current node in CLR heap for faster access. Those entries can be primary, backup, or near.

PlatformCache seems to be a better name.

Rename:

* `PlatformNearCacheConfiguration` -> `PlatformCacheConfiguration`
* `CachePeekMode.PlatformNear` -> `CachePeekMode.Platform`
* `CacheConfiguration.PlatformNearConfiguration` -> `CacheConfiguration.PlatformCacheConfiguration`

Mark all new platform (near) cache APIs with `[IgniteExperimental]`"	IGNITE	Resolved	3	4	8306	.NET
13435511	Thin 3.0: Implement IgniteCompute interface for Java thin client	Need to implement org.apache.ignite.compute.IgniteCompute interface for Java thin client.	IGNITE	Resolved	3	2	8306	iep-100, ignite-3
13320862	.NET: GetJvmDllPathsWindows does not work on .NET Core	"GetJvmDllPathsWindows implementation is hidden with preprocessor directives on .NET Core, because it uses Windows Registry, which is not available by default.

We should use Microsoft.Win32.Registry NuGet package to make it work."	IGNITE	Resolved	3	1	8306	.NET
13380405	.NET: If bash not installed on pod, ignite fails to start	"If bash is not installed, you get the following exception on startup:
{code:c#}
System.TypeInitializationException: The type initializer for 'Apache.Ignite.Core.Impl.Unmanaged.Jni.JvmDll' threw an exception.
 ---> System.TypeInitializationException: The type initializer for 'Apache.Ignite.Core.Impl.Unmanaged.Os' threw an exception.
 ---> System.ComponentModel.Win32Exception (2): No such file or directory
   at System.Diagnostics.Process.ForkAndExecProcess(String filename, String[] argv, String[] envp, String cwd, Boolean redirectStdin, Boolean redirectStdout, Boolean redirectStderr, Boolean setCredentials, UInt32 userId, UInt32 groupId, UInt32[] groups, Int32& stdinFd, Int32& stdoutFd, Int32& stderrFd, Boolean usesTerminal, Boolean throwOnNoExec)
   at System.Diagnostics.Process.StartCore(ProcessStartInfo startInfo)
   at System.Diagnostics.Process.Start()
   at Apache.Ignite.Core.Impl.Shell.Execute(String file, String args)
   at Apache.Ignite.Core.Impl.Shell.BashExecute(String args)
   at Apache.Ignite.Core.Impl.Unmanaged.Os..cctor()
   --- End of inner exception stack trace ---
   at Apache.Ignite.Core.Impl.Unmanaged.Os.get_IsWindows()
   at Apache.Ignite.Core.Impl.Unmanaged.Jni.JvmDll..cctor()
   --- End of inner exception stack trace ---
   at Apache.Ignite.Core.Impl.Unmanaged.Jni.JvmDll.Load(String configJvmDllPath, ILogger log)
   at Apache.Ignite.Core.Ignition.Start(IgniteConfiguration cfg)
{code}
"	IGNITE	Resolved	3	1	8306	.NET
13315416	.NET: Thin Client Compute leaks ClientNotificationHandler instances	"In multithreaded thin client compute scenarios there is a possibility for ClientNotificationHandler leak: handlers remain in ClientSocket._notificationListeners even after corresponding tasks have completed.

To reproduce, add the following code at the end of ComputeClientTests.TestExecuteJavaTaskAsyncMultithreaded:

{code}
            var failoverSocket = TestUtils.GetPrivateField<ClientFailoverSocket>(client, ""_socket"");
            var socket = TestUtils.GetPrivateField<ClientSocket>(failoverSocket, ""_socket"");
            var listeners = TestUtils.GetPrivateField<ICollection>(socket, ""_notificationListeners"");
            Assert.IsEmpty(listeners);
{code}"	IGNITE	Resolved	2	1	8306	.NET
13101255	.NET: Thin client: SQL queries	SQL and Fields queries in thin client.	IGNITE	Resolved	3	4	8306	.NET
13099774	.NET: Verify Java config parity with a unit test	Write a unit test that compares .NET {{IgniteConfiguration}} and Java {{IgniteConfiguration}} and fails if some properties are different.	IGNITE	Resolved	3	4	8306	.NET
13404507	.NET: Flaky ClientSocketTests	"ClientSocketTests are flaky and fail with the following error sometimes:
{code}
OneTimeSetUp: System.InvalidOperationException : Failed to wait for the server to start. Check logs for details.
{code}

We use a Maven command to start the server, and it downloads some artifacts from the internet on the first run, which takes time. Looks like a 15-second timeout is not enough."	IGNITE	Resolved	3	1	8306	.NET, ignite-3
13570497	.NET: Fix method naming in Compute API	"Async methods (returning Task) should have *Async* suffix:
* Task<IJobExecution<T>> Submit<T>
* Task<IJobExecution<T>> SubmitColocated<T>
* Task<IJobExecution<T>> SubmitColocated<T, TKey>"	IGNITE	Resolved	3	4	8306	.NET, ignite-3
13482984	.NET: Thin 3.0: Implement Partition Awareness	Implement partition awareness in .NET client. See reference implementation in Java: IGNITE-17725	IGNITE	Resolved	3	2	8306	.NET, iep-95, ignite-3
13546678	Java thin 3.0: testNonNullTxDisablesPartitionAwareness is flaky	"https://ci.ignite.apache.org/test/-5961865609456060252?currentProjectId=ApacheIgnite3xGradle_Test&expandTestHistoryChartSection=true

{code}
org.opentest4j.AssertionFailedError: Operation get was not executed on expected node ==> expected: <server-1> but was: <server-2>
  at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151)
  at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132)
  at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197)
  at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182)
  at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1153)
  at app//org.apache.ignite.client.PartitionAwarenessTest.assertOpOnNode(PartitionAwarenessTest.java:591)
  at app//org.apache.ignite.client.PartitionAwarenessTest.testNonNullTxDisablesPartitionAwareness(PartitionAwarenessTest.java:157)
{code}

Seems to be caused by IGNITE-20152 fix - random port causes random node ordering."	IGNITE	Resolved	2	4	8306	ignite-3
13354667	.NET: Incorrect table name when query type is generic	"Using a generic type as a QueryEntity value type results in a broken SQL table name:

{code}
            var ignite = Ignition.Start(TestUtils.GetTestConfiguration());

            var cfg = new CacheConfiguration(
                TestUtils.TestName,
                new QueryEntity(typeof(int), typeof(GenericTest<string>)));

            var cache = ignite.GetOrCreateCache<int, GenericTest<string>>(cfg);
            cache[1] = new GenericTest<string> {Prop = ""1""};

            var tables = cache.Query(new SqlFieldsQuery(""SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES""))
                .Select(x => (string) x.Single()).ToArray();
{code}

Resulting table name is *0, CULTURE=NEUTRAL, PUBLICKEYTOKEN=7CEC85D7BEA7798E]]*.
We should add .NET generics support to {{org.apache.ignite.internal.processors.query.QueryUtils.typeName}}.
"	IGNITE	Resolved	4	1	8306	.NET
13538428	.NET: Thin 3.0: Client should provide a list of deployment units on compute	"During work on IGNITE-19565 all org.apache.ignite.compute.IgniteCompute's methods were extended with a list of units used to execute a job.

We need to support those changes in C# Client and update tests as well. "	IGNITE	Resolved	3	2	8306	.NET, ignite-3
13438245	.NET: CancellationToken on Async methods	The .NET ThinClient API has numerous async methods, but none seem to support cancellation. I suspect they could and probably should. Each should accept a CancellationToken parameter.	IGNITE	Open	4	4	8306	.NET
13120211	.NET: Thin client: Remove OP_SQL_QUERY	OP_SQL_QUERY is not necessary and can be implemented on the client side with OP_SQL_FIELDS_QUERY.	IGNITE	Resolved	3	4	8306	.NET
13132941	.NET: Propagate WAL management API	"Add the following methods to .NET:
{code}
ICluster.disableWal member is missing in .NET.
ICluster.enableWal member is missing in .NET.
ICluster.isWalEnabled member is missing in .NET.
{code}"	IGNITE	Resolved	3	3	8306	.NET
13282203	.NET: DotNetCore publish dir is not copied to bin dir	Recent changes in build.ps1 break the release build: publish folder is not present in dotnet/bin.	IGNITE	Resolved	1	1	8306	.NET
13583260	.NET: Thin 3.0: Add parameter object to Data Streamer	Similar to IGNITE-22524 and IGNITE-22441, add parameter object to DataStreamer to simplify the signature.	IGNITE	Resolved	3	4	8306	ignite-3
13286172	.NET: Remove TypeCaster	"TypeCaster class is used in Ignite.NET for non-boxing, faster casts.
Benchmarks on .NET 4.0 displayed clear advantage of this solution.

However, this is no longer true on .NET Core due to improvements in the framework:

{code}
|     Method |       Runtime |      Mean |     Error |    StdDev |
|----------- |-------------- |----------:|----------:|----------:|
| TypeCaster | .NET Core 2.2 | 3.4615 ns | 0.0325 ns | 0.0304 ns |
| ObjectCast | .NET Core 2.2 | 1.0936 ns | 0.0040 ns | 0.0036 ns |
| UnsafeCast | .NET Core 2.2 | 4.1921 ns | 0.0125 ns | 0.0111 ns |
| TypeCaster | .NET Core 3.1 | 1.5306 ns | 0.0042 ns | 0.0037 ns |
| ObjectCast | .NET Core 3.1 | 0.0229 ns | 0.0029 ns | 0.0024 ns |
| UnsafeCast | .NET Core 3.1 | 2.1868 ns | 0.0052 ns | 0.0043 ns |
{code}

(See benchmark code in https://github.com/ptupitsyn/IgniteNetBenchmarks)

Remove TypeCaster class and use regular cast instead.
Run Ignite deserialization benchmarks to confirm the effect."	IGNITE	Closed	3	4	8306	.NET
13055944	Start .NET plugins before OnIgniteStart	"Currently we initialize and start plugins ({{IPluginProvider.Start()}}) in {{OnIgniteStart}} callback. This is not correct. Java plugin part may invoke callbacks from its {{start()}} method, but these callbacks are not registered on .NET side yet.

Instead, we should initialize .NET plugins in {{PluginProcessor}} ctor."	IGNITE	Resolved	3	7	8306	.NET
13083385	.NET: IgniteConfiguration.LocalEventListeners	"Propagate {{IgniteConfiguration.LocalEventListeners}} to .NET. This allows catching all events right from the node start.

* Can we unsubscribe from these events later? Does Java support this?
* What about GetEvents for a cluster group, how do we handle local listeners in this case?"	IGNITE	Resolved	3	4	8306	.NET
13482895	.NET: Upgrade to DocFx 3.x to get rid of Mono dependency	"We use [docfx|https://github.com/dotnet/docfx] to generate .NET docs from source code. Docfx 2.x requires Mono to run on Linux.

Docfx 3.x works on .NET core, but is still in beta. Find out if it is mature enough and we can get rid of Mono dependency to simplify the environment."	IGNITE	Resolved	3	2	8306	.NET
13591309	ClientKeyValueBinaryView.get() operation returns tuple with key column	"The tuple returned by {{ClientKeyValueBinaryView.get()}} method must have only value fields.
But we still can access the key column using the column name.
Reproducer (for ClientKeyValueBinaryViewTest):

{code:java}
    @Test
    public void testGet() {
        KeyValueView<Tuple, Tuple> kvView = defaultTable().keyValueView();

        Tuple key = tupleKey(1);

        // insert tuple (id=1, name=""test)
        kvView.put(null, key, tupleVal(""test""));

        // get value by key
        Tuple val = kvView.get(null, key);

        // correct
        assertEquals(1, val.columnCount());
        assertEquals(""test"", val.value(0));
        assertEquals(""test"", val.value(""name""));

        // incorrect
        assertEquals(1L, val.longValue(""id""));
    }
{code}
"	IGNITE	Resolved	3	1	8306	ignite-3
13131842	.NET: SqlDdlExample fails with standalone node	"Exception on query:

{code}
Caches have distinct sets of data nodes [cache1=dummy_cache, cache2=SQL_PUBLIC_PERSON]
  ----> Apache.Ignite.Core.Common.JavaException : javax.cache.CacheException: Caches have distinct sets of data nodes [cache1=dummy_cache, cache2=SQL_PUBLIC_PERSON]
	at org.apache.ignite.internal.processors.query.h2.twostep.GridReduceQueryExecutor.stableDataNodes(GridReduceQueryExecutor.java:499)
	at org.apache.ignite.internal.processors.query.h2.twostep.GridReduceQueryExecutor.nodesForPartitions(GridReduceQueryExecutor.java:1486)
	at org.apache.ignite.internal.processors.query.h2.twostep.GridReduceQueryExecutor.query(GridReduceQueryExecutor.java:591)
	at org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing$8.iterator(IgniteH2Indexing.java:1283)
	at org.apache.ignite.internal.processors.cache.QueryCursorImpl.iterator(QueryCursorImpl.java:95)
	at org.apache.ignite.internal.processors.platform.cache.query.PlatformAbstractQueryCursor.processInLongOutLong(PlatformAbstractQueryCursor.java:147)
	at org.apache.ignite.internal.processors.platform.PlatformTargetProxyImpl.inLongOutLong(PlatformTargetProxyImpl.java:55)


   at Apache.Ignite.Core.Impl.PlatformJniTarget.InLongOutLong(Int32 type, Int64 val) in C:\w\incubator-ignite\modules\platforms\dotnet\Apache.Ignite.Core\Impl\PlatformJniTarget.cs:line 379
   at Apache.Ignite.Core.Impl.Cache.Query.PlatformQueryQursorBase`1.InitIterator() in C:\w\incubator-ignite\modules\platforms\dotnet\Apache.Ignite.Core\Impl\Cache\Query\PlatformQueryQursorBase.cs:line 74
   at Apache.Ignite.Core.Impl.Cache.Query.QueryCursorBase`1.GetEnumerator() in C:\w\incubator-ignite\modules\platforms\dotnet\Apache.Ignite.Core\Impl\Cache\Query\QueryCursorBase.cs:line 125
   at Apache.Ignite.Examples.Sql.SqlDdlExample.Main() in C:\w\incubator-ignite\modules\platforms\dotnet\examples\Apache.Ignite.Examples\Sql\SqlDdlExample.cs:line 95
   at Apache.Ignite.Core.Tests.Examples.Example.Run() in C:\w\incubator-ignite\modules\platforms\dotnet\Apache.Ignite.Core.Tests\Examples\Example.cs:line 52
   at Apache.Ignite.Core.Tests.Examples.ExamplesTest.TestRemoteNodes(Example example, Boolean clientMode) in C:\w\incubator-ignite\modules\platforms\dotnet\Apache.Ignite.Core.Tests\Examples\ExamplesTest.cs:line 131
   at Apache.Ignite.Core.Tests.Examples.ExamplesTest.TestRemoteNodes(Example example) in C:\w\incubator-ignite\modules\platforms\dotnet\Apache.Ignite.Core.Tests\Examples\ExamplesTest.cs:line 99
{code}"	IGNITE	Resolved	3	1	8306	.NET
13541412	.NET: Thin 3.0: Reload schema when unmapped Tuple or POCO column is detected	See parent epic. Unmapped columns are not allowed; however, we must ensure that the validation is performed against the latest schema, not the cached one.	IGNITE	Resolved	3	4	8306	.NET, ignite-3
13492439	.NET: Thin 3.0: Incorrect colocation hash due to ignored precision for LocalTime, LocalDateTime, Timestamp	"RowAssembler serializes *LocalTime*, *LocalDateTime* and *Timestamp* according to their *TemporalNativeType.precision*. This affects colocation hash.
Client implementation ignores *precision* when calculating colocation hash, resulting in different values when precision is less than maximum."	IGNITE	Resolved	3	1	8306	.NET, ignite-3
13552277	Java thin 3.0: ClientMetricsTest.testConnectionMetrics is flaky	"{code}
org.opentest4j.AssertionFailedError: expected: <1> but was: <0>
  at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151)
  at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132)
  at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197)
  at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:166)
  at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:161)
  at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:629)
  at app//org.apache.ignite.client.ClientMetricsTest.testConnectionMetrics(ClientMetricsTest.java:86)
{code}

https://ci.ignite.apache.org/test/5232970473067276194?currentProjectId=ApacheIgnite3xGradle_Test&expandTestHistoryChartSection=true"	IGNITE	Resolved	3	1	8306	ignite-3
13525886	Java client: Implement client-side metrics	"Implement client-side metrics in Java client as described in IGNITE-18759
* Add reference to ignite-metrics module to the client module
* Add *MetricConfiguration* to *IgniteClientConfiguration*"	IGNITE	Resolved	3	4	8306	ignite-3
13503094	.NET: Thin 3.0: TestExecuteOnRandomNode is flaky	"https://ci.ignite.apache.org/buildConfiguration/ignite3_Test_RunNetTests/6916396?buildTab=overview&hideProblemsFromDependencies=false&hideTestsFromDependencies=false&pluginCoverage=true&expandBuildChangesSection=true&expandBuildTestsSection=true

{code}
 Expected: 1773
  But was:  1774

TearDown : NUnit.Framework.AssertionException :   Expected: 1773
  But was:  1774
   at Apache.Ignite.Tests.IgniteTestsBase.TearDown() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/IgniteTestsBase.cs:line 115
--TearDown
   at NUnit.Framework.Assert.ReportFailure(String message)
   at NUnit.Framework.Assert.ReportFailure(ConstraintResult result, String message, Object[] args)
   at NUnit.Framework.Assert.That[TActual](TActual actual, IResolveConstraint expression, String message, Object[] args)
   at NUnit.Framework.Assert.AreEqual(Object expected, Object actual)
   at Apache.Ignite.Tests.IgniteTestsBase.TearDown() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/IgniteTestsBase.cs:line 115
{code}

Same problem as in IGNITE-17993 - we forgot to fix TearDown check."	IGNITE	Resolved	3	1	8306	.NET, ignite-3
13134557	.NET: Service proxy as dynamic object	"Currently we require user to provide an interface to interact with .NET and Java services.

We could also provide a dynamic API (based on {{dynamic}} keyword) like this:

{code}
IServices services = ignite.GetServices();
dynamic prx = services.GetDynamicServiceProxy(""someService"");
prx.Foo();
prx.Bar = 1;
{code}"	IGNITE	Resolved	3	4	8306	.NET
13576725	Thin 3.0: observableTimestamp is 0 after handshake	We propagate *observableTimestamp* to client with every response (see *ClientInboundMessageHandler#writeResponseHeader*), but not on handshake. As a result, the very first operation from the client has *observableTimestamp=0*, which can lead to causality issues.	IGNITE	Resolved	3	1	8306	ignite-3
13411781	.NET thin: SSL keystore shouldn't be a mandatory parameter	"Currently, SslStreamFactory can't be configured without specifying client-side certificates. 
This shouldn't be the case - SSL can be used without any certificates on the client.

Workaround:

{code}
class SimpleSslStreamFactory : ISslStreamFactory {
    public SslStream Create(Stream stream, string targetHost)
    {
        var sslStream = new SslStream(stream, false, null, null);
        sslStream.AuthenticateAsClient(targetHost);
        return sslStream;
    }
}
{code}"	IGNITE	Resolved	3	1	8306	.NET
13080084	.NET: Persistent Store tests	Configuration is propagated in IGNITE-5341, now add proper tests that persistence works via .NET as expected.	IGNITE	Resolved	3	4	8306	.NET
13551727	.NET: Thin 3.0: Replace IgniteArgumentCheck.NotNull with ArgumentNullException.ThrowIfNull	*ArgumentNullException.ThrowIfNull* is a built-in helper that infers argument name with CallerArgumentExpression. Remove our custom helper.	IGNITE	Resolved	4	4	8306	.NET, ignite-3
13057794	.NET: Support complex type dictionaries in app.config configuration	Only primitive types are supported currently for things like {{IgniteConfiguration.UserAttributes}}, there is no way to specify a user type as a value.	IGNITE	Resolved	3	4	8306	.NET
13202566	.NET: Jars are not copied to target dir under .NET Core	"We use PowerShell script to update post-build event in the target project and copy jar files to target directory during build.

However, this no longer works with .NET Core.
nuspec file should be updated with new format, see example from https://github.com/NuGet/Samples/blob/master/ContentFilesExample/authoring/ContentFilesExample.nuspec:

{code}
<?xml version=""1.0""?>
<package>
  <metadata minClientVersion=""3.3.0"">
    <id>ContentFilesExample</id>
    <version>1.0.0</version>
    <authors>nuget</authors>
    <owners>nuget</owners>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <description>A content v2 example package.</description>
    <tags>contentv2 contentFiles</tags>
    <!-- Build actions for items in the contentFiles folder -->
    <contentFiles>
        <!-- Include Assets as Content -->
        <files include=""**/images/*.*"" buildAction=""Content"" />
        <files include=""**/data.txt"" buildAction=""Content"" />
        <!-- Copy tool scripts to the output folder -->
        <files include=""**/tools/*"" buildAction=""None"" flatten=""false"" copyToOutput=""true"" />
    </contentFiles>
  </metadata>
</package
{code}


*UPDATE: this breaks NuGet package usage completely under .NET Core 3.0*
[NuGet behavior has changed|https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0#build-copies-dependencies] in .NET Core 3.0:

??The dotnet build command now copies NuGet dependencies for your application from the NuGet cache to the build output folder??

In .NET Core 2.x dependencies are used directly from NuGet cache, so JAR files are resolved.
In 3.0 this does not work anymore, we should find a way to copy JAR files to the output folder.

Test cases:
* .NET 4.x
* .NET Core 2.x, 3.x Windows & Linux
* LINQPad
* Binary zip distribution (examples, .NET Core examples)"	IGNITE	Resolved	2	1	8306	.NET
13582707	Remove TopologyService from public API	"Currently, TopologyService, ClusterNodeResolver and TopologyEventListener are in the public API. ClusterNodeResolver and TopologyEventListener are not needed there at all. TopologyService might be needed as a public interface, but only when we decide exactly what methods of it are needed (for example, there are nodes() and nodesAsync() on Ignite itself; and it's not yet clear whether a user needs a way to get a node by its consistentId). Also, now the user doesn't even have any possibility to get an instance of TopologyService via public API.

When we decide what we need to provide and how we'll return TopologyService back to the public API (or make a new public interface for it)."	IGNITE	Resolved	3	4	8784	ignite-3
13591118	Keep initial config after CMG repair	It makes sense to have in cluster state after repair everything we had there before repair.	IGNITE	Resolved	3	4	8784	ignite-3
13418938	Improve the interface of UserObjectMarshaller	"There should be 2 'registries' of class descriptors: local one (which is global and contains descriptors for classes loaded by the local node) and remote one (which is session-bound and contains only descriptors received from a remote node).

marshal() method should only work with the local registry in read-write mode (as it can add descriptors for classes never marshalled before).

unmarshal() method should work with the merge of local and remote registries (remote registry taking precedence), but only in read-only mode (it should not modify the registries)."	IGNITE	Resolved	3	7	8784	ignite-3
13536875	Switch table IDs from UUIDs to integers	"Currently, as tables are stored as named list items in the Configuration, they are internally (to the configuration) identified by UUIDs. The same UUIDs are also used to identify tables in the whole system.

We need to change the latter: that is, in addition to the internal IDs (needed only for configuration), we need to generate integer IDs and use them in the rest of the system to identify tables.

For now, table IDs should be generated using same global counter that will be used to generate index and zone IDs.

Internal IDs will remain until we switch from storing tables/indices/zones in the Configuration to storing them in the Catalog (this is out of scope of this task)."	IGNITE	Resolved	3	4	8784	ignite-3
13550680	Internal IncompatibleSchemaException is thrown from public API	"The following code throws internal exception from public API (add to *ItSqlSynchronousApiTest* and run):

{code:java}
    @Test
    public void schemaMigration() {
        IgniteSql sql = igniteSql();
        Session ses = sql.createSession();

        checkDdl(true, ses, ""CREATE TABLE TEST(ID INT PRIMARY KEY, VAL0 INT)"");
        var view = CLUSTER_NODES.get(0).tables().table(""TEST"").recordView();

        var upsertFut = CompletableFuture.runAsync(() -> {
            for (int i = 0; i < 1000; i++) {
                view.upsert(null, Tuple.create().set(""ID"", i).set(""VAL0"", i));
            }
        });

        checkDdl(true, ses, ""ALTER TABLE TEST ADD COLUMN VAL1 INT DEFAULT -1"");

        upsertFut.join();
    }
{code}

*Result:*
{code}
java.util.concurrent.CompletionException: org.apache.ignite.internal.table.distributed.replicator.IncompatibleSchemaException: IGN-TX-12 TraceId:52bbae8c-4706-4394-8bd3-30bac5747da5 Table schema was updated after the transaction was started [table=1, startSchema=1, operationSchema=2]
	at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:314) ~[?:?]
	at java.util.concurrent.CompletableFuture.uniApplyNow(CompletableFuture.java:683) ~[?:?]
	at java.util.concurrent.CompletableFuture.uniApplyStage(CompletableFuture.java:658) ~[?:?]
	at java.util.concurrent.CompletableFuture.thenApply(CompletableFuture.java:2094) ~[?:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.validateAtTimestampAndBuildUpdateCommand(PartitionReplicaListener.java:2643) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.validateAtTimestampAndBuildUpdateCommand(PartitionReplicaListener.java:2586) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$processSingleEntryAction$109(PartitionReplicaListener.java:2058) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at java.util.concurrent.CompletableFuture.uniComposeStage(CompletableFuture.java:1106) ~[?:?]
	at java.util.concurrent.CompletableFuture.thenCompose(CompletableFuture.java:2235) ~[?:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$processSingleEntryAction$112(PartitionReplicaListener.java:2058) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.continueResolvingByPk(PartitionReplicaListener.java:1448) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$resolveRowByPk$68(PartitionReplicaListener.java:1428) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at java.util.concurrent.CompletableFuture.uniComposeStage(CompletableFuture.java:1106) ~[?:?]
	at java.util.concurrent.CompletableFuture.thenCompose(CompletableFuture.java:2235) ~[?:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.resolveRowByPk(PartitionReplicaListener.java:1419) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.processSingleEntryAction(PartitionReplicaListener.java:2048) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$processRequest$2(PartitionReplicaListener.java:363) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.appendTxCommand(PartitionReplicaListener.java:1494) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.processRequest(PartitionReplicaListener.java:363) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$invoke$0(PartitionReplicaListener.java:347) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072) ~[?:?]
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506) ~[?:?]
	at java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073) ~[?:?]
	at org.apache.ignite.internal.util.PendingComparableValuesTracker.lambda$completeWaitersOnUpdate$0(PendingComparableValuesTracker.java:169) ~[ignite-core-3.0.0-SNAPSHOT.jar:?]
	at java.util.concurrent.ConcurrentMap.forEach(ConcurrentMap.java:122) ~[?:?]
	at org.apache.ignite.internal.util.PendingComparableValuesTracker.completeWaitersOnUpdate(PendingComparableValuesTracker.java:169) ~[ignite-core-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.util.PendingComparableValuesTracker.update(PendingComparableValuesTracker.java:103) ~[ignite-core-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.metastorage.server.time.ClusterTimeImpl.updateSafeTime(ClusterTimeImpl.java:146) ~[ignite-metastorage-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.metastorage.impl.MetaStorageManagerImpl.onSafeTimeAdvanced(MetaStorageManagerImpl.java:849) ~[ignite-metastorage-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.metastorage.impl.MetaStorageManagerImpl$1.onSafeTimeAdvanced(MetaStorageManagerImpl.java:456) ~[ignite-metastorage-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.metastorage.server.WatchProcessor.lambda$advanceSafeTime$7(WatchProcessor.java:269) ~[ignite-metastorage-3.0.0-SNAPSHOT.jar:?]
	at java.util.concurrent.CompletableFuture$UniRun.tryFire(CompletableFuture.java:783) ~[?:?]
	at java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:478) ~[?:?]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[?:?]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[?:?]
	at java.lang.Thread.run(Thread.java:829) ~[?:?]
Caused by: org.apache.ignite.internal.table.distributed.replicator.IncompatibleSchemaException: Table schema was updated after the transaction was started [table=1, startSchema=1, operationSchema=2]
	at org.apache.ignite.internal.table.distributed.replicator.SchemaCompatValidator.failIfSchemaChangedAfterTxStart(SchemaCompatValidator.java:183) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.failIfSchemaChangedSinceTxStart(PartitionReplicaListener.java:2682) ~[ignite-table-3.0.0-SNAPSHOT.jar:?]
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$validateAtTimestampAndBuildUpdateCommand$163(PartitionReplicaListener.java:2644) ~[ignite-table-3.0.0-SN
{code}"	IGNITE	Resolved	2	1	8784	ignite-3
13585150	Add protection against internal thread hijacking to PartitionManager	"User-facing futures are currently completed (in many cases) in Ignite internal threads which means that the user can hijack those threads and do something heavy in them, creating a possibility for a starvation.

We should complete such futures in the async continuation executor."	IGNITE	Resolved	3	4	8784	ignite-3
13591887	Store lease holder node ID as 2 longs in MvPartitionStorage implementations	"Currently, lease holder node ID is stored as a string, which implies the usage of the BlobStorage, which is a bit too complex.

After IGNITE-15119, node IDs will become UUIDs, so we'll need to switch to storing the lease node ID as 2 longs in partition metadata."	IGNITE	Resolved	3	4	8784	ignite-3, important
13422574	Object identity distinction must be preserved after marshalling+unmarshalling	"If we marshal an object graph containing N distinct objects that are all equal, then after unmarshalling we must get N distinct objects and not N references all pointing to just 1 object. It's easy to miss this requirement for primitive wrapper types (like Integer).

Also, when we marshal a graph containing N references to the same object, after the unmarshalling this property must be maintained."	IGNITE	Resolved	3	4	8784	ignite-3
13587701	Initiate MG repair	"An overload of CmgDisasterRecoveryManager#resetCluster() needs to be extended to also accept (apart from newCmgConsistentIds) the following:
 * int metastorageReplicationFactor

It adds the MG replication factor to the created ClusterResetMessage (see IGNITE-22876), also it adds the following to this message:
 * conductor=<consistentId of the current node>
 * nodes=<list of nodes to which the message gets sent>"	IGNITE	Resolved	3	4	8784	iep-128, ignite-3
13567864	ItConnectionManagerTest#sendFuturesCompleteInSendOrder is flaky	java.lang.AssertionError: Expected: not an empty collection but: was <[]> java.lang.AssertionError: Expected: not an empty collection but: was <[]> at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20) at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:6) at org.apache.ignite.internal.network.netty.OutgoingAcknowledgementSilencer.installOn(OutgoingAcknowledgementSilencer.java:56) at org.apache.ignite.internal.network.netty.ItConnectionManagerTest.dropAcksFrom(ItConnectionManagerTest.java:467) at org.apache.ignite.internal.network.netty.ItConnectionManagerTest.sendFuturesCompleteInSendOrder(ItConnectionManagerTest.java:431)	IGNITE	Resolved	3	1	8784	ignite-3
13429082	Add an integration test for unmarshalling an object with changed schema	The idea is to marshal an object send it via our network mechanisms and then unmarshal it (on another node) using a different version of the same class (that is, adding some field and removing some other field).	IGNITE	Open	3	4	8784	ignite-3
13525583	NPE in DumpThreadsOnTimeout breaking resource cleanup	"In test runs from CI founded follow stacktrace:
{code:java}
java.lang.NullPointerException
	at org.apache.ignite.internal.testframework.junit.DumpThreadsOnTimeout.isJunitMethodTimeout(DumpThreadsOnTimeout.java:68)
	at org.apache.ignite.internal.testframework.junit.DumpThreadsOnTimeout.handleThrowable(DumpThreadsOnTimeout.java:53)
	at org.apache.ignite.internal.testframework.junit.DumpThreadsOnTimeout.handleTestExecutionException(DumpThreadsOnTimeout.java:49)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestExecutionExceptionHandlers$8(TestMethodTestDescriptor.java:228)
	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.invokeExecutionExceptionHandlers(JupiterTestDescriptor.java:123)
	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.invokeExecutionExceptionHandlers(JupiterTestDescriptor.java:110)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestExecutionExceptionHandlers(TestMethodTestDescriptor.java:227)
	...
	at org.gradle.api.internal.tasks.testing.worker.TestWorker$3.run(TestWorker.java:193)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60)
	at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56)
	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133)
	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71)
	at worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69)
	at worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74)
{code}

In case any tests failed with TimeoutException *org.apache.ignite.internal.testframework.junit.DumpThreadsOnTimeout*  tried to produce readable message but fail with *NPE * in case when Exception message is null. After this NPE JUnit thread die and *BeforeAll\BeforeEach* methods are not called. As result, we have unkilled AI3 live nodes which holded ports and next tests on the CI Agent where it failed cannot run correctly with reason *Caused by: java.lang.IllegalStateException: No available port in range [3344-3344]*"	IGNITE	Resolved	3	1	8784	ignite-3
13541585	Default zone replica count is not listened by rebalance trigger	As a result, when 'replicas' is changed on a default zone, rebalance is not triggered	IGNITE	Resolved	3	1	8784	ignite-3
13516645	Thread pool for components start	"*Motivation*
The most components are started in asynchronous manner to avoid hold CMG threads too long:
{code}
// using the default executor to avoid blocking the CMG Manager threads
.thenRunAsync(() -> {
    LOG.info(""Join complete, starting the remaining components"");

    // Start all other components after the join request has completed and the node has been validated.
    try {
        lifecycleManager.startComponents(
                metaStorageMgr,
                clusterCfgMgr,
                metricManager,
                distributionZoneManager,
                computeComponent,
                replicaMgr,
                txManager,
                baselineMgr,
                dataStorageMgr,
                schemaManager,
                volatileLogStorageFactoryCreator,
                outgoingSnapshotsManager,
                distributedTblMgr,
                indexManager,
                qryEngine,
                clientHandlerModule
        );
    } catch (NodeStoppingException e) {
        throw new CompletionException(e);
    }
})
{code}
But the default treads pool is not a place for run critical code (the pool can be used by client application).

*Divination of done*
All components start in node internal thread pool."	IGNITE	Resolved	3	4	8784	ignite-3
13587718	Repair MG on node start	"When a node starts and finds a ClusterResetMessage in its Vault, it executes the CMG reset routine described in IGNITE-22807. If the message contains fields related to the Metastorage (which means that MG repair is requested), the following has to be done:
 # Pause node startup before starting Metastorage
 # On the repair conductor (that is, the node whose consistentId is the same as the value of 'conductor' in the message), the following is done:
 ## Wait till all nodes specified in the 'nodes' field of the message pass basic validation on the CMG
 ## Send a MetastorageIndexRequestMessage to those nodes (see IGNITE-22900)
 ## After receiving responses from all the nodes (if a node leaves the ‘basically validated’ node set (or a higher set), the procedure ends with an error and ‘cluster reset’ has to be repeated), the Conductor chooses new MG nodes from those that successfully returned responses [the set of nodes that returned successful responses is U] (by choosing top N ordering them by index+term; N is metastorageReplicationFactor from the ClusterResetMessage)
 ## The Conductor submits CmgChangeMgNodesCommand (containing new MG nodes) to the CMG (see IGNITE-22902)
 ## The Conductor then chooses one of the new MG nodes having the highest index+term as the new leader and sends it a BecomeMetastorageLeaderMessage (see IGNITE-22903)
 ## After getting a successful response to BecomeMetastorageLeaderMessage, the Conductor forms a new Raft configuration including all new MG nodes as the voting set and other nodes from U as learners. It then does changePeers via the new leader to switch to this configuration. After the leader elected on the previous step (the sole leader) gets reelected (or ceases to be a leader), the prohibition for it to send idle safe time commands and manage learners is lifted

 "	IGNITE	Resolved	3	4	8784	iep-128, ignite-3
13483673	Invalid data in network buffers causes message deserialization errors and messages loss	"h3. TL;DR


Message serialization registry behavior is inconsistent, it either throws an AssertionError or NetworkConfigurationException if factory is not found. There should be only one. This will simplify debugging situations where one forgot to register a factory in the registry, as it's the case in the problem below. There's no actual bug in messaging and mentioned exception is impossible to get in normal circumstances.
h3. Original description

In some tests I observe network messages' deserialization errors and timeout exceptions while waiting for response. In some cases there is negative group type of the message, and this causes error:
{code:java}
java.lang.AssertionError: message type must not be negative, messageType=-5376
	at org.apache.ignite.network.MessageSerializationRegistryImpl.getFactory(MessageSerializationRegistryImpl.java:77)
	at org.apache.ignite.network.MessageSerializationRegistryImpl.createDeserializer(MessageSerializationRegistryImpl.java:102)
	at org.apache.ignite.internal.network.serialization.SerializationService.createDeserializer(SerializationService.java:68)
	at org.apache.ignite.internal.network.serialization.PerSessionSerializationService.createMessageDeserializer(PerSessionSerializationService.java:109)
	at org.apache.ignite.internal.network.netty.InboundDecoder.decode(InboundDecoder.java:89)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:507)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:446)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:719)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:655)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:581)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:833)

{code}
When the group or message type is positive but not existing, there should be a NetworkConfigurationException but it's not displayed in logs, however, it causes TimeoutExceptions because of messages loss.

This reproduces in [https://github.com/gridgain/apache-ignite-3/tree/ignite-17523-2] in ItTablesApiTest#testGetTableFromLaggedNode"	IGNITE	Resolved	3	1	8784	ignite-3
13510443	Move LogicalTopologyService to an internal package	This interface (and the dependent types) should not be a part of the public API.	IGNITE	Resolved	3	4	8784	ignite-3
13514889	Full rebalance testing extension	"Scenarios for testing: (current storages: *TxStateStorage* and *MvPartitionStorage*)
* During a full rebalance, the leader changes, what will happen?
I expect the current rebalance to be canceled and a new one to start with empty storages and set initial (equal to 0) *lastAppliedIndex *and *lastAppliedTerm*.
And also what index will be sent to the new leader, if during a full rebalancing on the recipient it will be equal to *-1*.
* What happens if a leader changes during a full rebalance that has enough log to avoid a full rebalance?
I expect the full rebalance to be canceled, clear the storages and set the initial (equal to 0)  *lastAppliedIndex *and *lastAppliedTerm*.
And also what index will be sent to the new leader, if during a full rebalancing on the recipient it will be equal to *-1*.
* Suppose a full rebalancing for one of the storages ended successfully, and it has updated (not equal to -1) *lastAppliedIndex *and *lastAppliedTerm*, while for the other we did not have time to complete the full rebalancing and the node fell. 
What will happen to both storages after the node is powered on?
I expect both stores to be cleared and have initial (equal to 0) *lastAppliedIndex *and *lastAppliedTerm*.

Each scenario can be tested in a separate ticket"	IGNITE	Resolved	3	3	8784	ignite-3
13565761	Handle ClosedChannelException gracefully	"We have a connection recovery mechanism that transparently re-establishes a connection whose Channel was closed. This means that a sender should never see ClosedChannelException as a result of a send. There is a race now that allows a sender to get such an exception.

The same race might also cause a message to not be added to the unacknowledged messages queue, which might offset acknowledgement and put connection restoration logic at risk (some messages might not be resent).

Also, message ordering might be compromised due to the same race on the boundary between the old and new channels in the same logical connection."	IGNITE	Resolved	3	4	8784	ignite-3
13499618	prepareMarshal()/unmarshal() are not relayed for Collection subtypes	"{{@Marshallable}} fields cause prepareMarshal()/unmarshal() methods to be generated; also, these methods need to be called for each message containing a marshallable field. This means that any container that contains messages must relay calls to them (that is, it must contain a snippet in its prepareMarshal()/unmarshal() to iterate its elements and call the corresponding method on them). This is currently implemented for single message fields, for arrays and {{{}Collection{}}}, but not for subtypes of {{Collection}} (like lists).

We should either support subtypes of {{Collection}} fully (and relay the methods calls), or not support them at all (and fail compilation if someone defines such a structure).

The first (support)  seems preferrable, it's easy to implement and does not seem to pose any dangers."	IGNITE	Resolved	3	1	8784	ignite-3
13595452	Do not use ByteUtils#toBytes to persist timestamps in LowWatermark	Currently, Java Serialization is used to persist those objects. We should not use it (see IGNITE-23135 for justification)	IGNITE	Resolved	3	4	8784	ignite-3
13545720	Switch index to STOPPING state as a reaction to DROP INDEX	"DROP INDEX should do the following:
 # If the index is AVAILABLE, move it to STOPPING
 # If it was not yet available (that is, it's REGISTERED or BUILDING), remove it from the Catalog

Also, RemoveIndexCommand should be added that will be used to move a STOPPED index from the Catalog (invocation of the command is out of scope of this issue)."	IGNITE	Resolved	3	4	8784	ignite-3
13531421	DistributedQueryManager#close() fails to complete cancellation future	"var finalStepFut = compoundCancelFut.thenRun(() -> {
    queryManagerMap.remove(ctx.queryId());

    try {
        ctx.cancel().cancel();
    } catch (Exception ex) {
        // NO-OP
    }

    cancelFut.complete(null);
});

The step above must be executed after compoundCancelFut is completed regardless of whether the completion is normal or exceptional; instead, the current code only executes this code on normal completion."	IGNITE	Resolved	3	1	8784	ignite-3
13552388	Use CatalogService in JdbcMetadataCatalog	Currently, {{JdbcMetadataCatalog}} uses {{TableManager}} to get tables' metadata. It is enough to use CatalogService; it is also more suitable as it allows to get a consistent snapshot thanks to timestamps support.	IGNITE	Resolved	3	4	8784	ignite-3
13544791	Validate schema eligibility on each read/write operation in an RW transaction	As per https://cwiki.apache.org/confluence/display/IGNITE/IEP-110%3A+Schema+synchronization%3A+basic+schema+changes#IEP110:Schemasynchronization:basicschemachanges-Whenschemachangesarevalidated (item 2), we must check whether a schema effective at operationTs (for each read/write operation in an RW transaction) is different from the initial schema (at the beginning of the transaction for the table). If it's different, we should throw an exception (that will cause the transaction to be aborted).	IGNITE	Resolved	3	4	8784	iep-110, ignite-3
13540386	Remove a stale TODO	The TODO is about IGNITE-19386	IGNITE	Resolved	3	4	8784	ignite-3
13436866	BigInteger can't be serialized by User Object Serialization	"When trying to pass *BigInteger.TEN* to *IgniteCompute#execute*:

{code}
Caused by: class org.apache.ignite.lang.IgniteException: Failed to marshal message: Cannot invoke writeObject()
	at org.apache.ignite.network.DefaultMessagingService.sendMessage0(DefaultMessagingService.java:250)
	at org.apache.ignite.network.DefaultMessagingService.lambda$sendMessage0$1(DefaultMessagingService.java:241)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1700)
	... 3 more
Caused by: class org.apache.ignite.internal.network.serialization.marshal.MarshalException: Cannot invoke writeObject()
	at org.apache.ignite.internal.network.serialization.marshal.StructuredObjectMarshaller.writeWithWriteObject(StructuredObjectMarshaller.java:106)
	at org.apache.ignite.internal.network.serialization.marshal.StructuredObjectMarshaller.writeStructuredObjectLayer(StructuredObjectMarshaller.java:86)
	at org.apache.ignite.internal.network.serialization.marshal.StructuredObjectMarshaller.writeStructuredObject(StructuredObjectMarshaller.java:79)
	at org.apache.ignite.internal.network.serialization.marshal.DefaultUserObjectMarshaller.writeObject(DefaultUserObjectMarshaller.java:275)
	at org.apache.ignite.internal.network.serialization.marshal.DefaultUserObjectMarshaller.marshalIdentifiable(DefaultUserObjectMarshaller.java:233)
	at org.apache.ignite.internal.network.serialization.marshal.DefaultUserObjectMarshaller.marshalToOutput(DefaultUserObjectMarshaller.java:172)
	at org.apache.ignite.internal.network.serialization.marshal.DefaultUserObjectMarshaller.marshalShared(DefaultUserObjectMarshaller.java:144)
	at org.apache.ignite.internal.network.serialization.marshal.BuiltInContainerMarshallers.writeGenericRefArray(BuiltInContainerMarshallers.java:108)
	at org.apache.ignite.internal.network.serialization.marshal.DefaultUserObjectMarshaller.writeObject(DefaultUserObjectMarshaller.java:268)
	at org.apache.ignite.internal.network.serialization.marshal.DefaultUserObjectMarshaller.marshalIdentifiable(DefaultUserObjectMarshaller.java:233)
	at org.apache.ignite.internal.network.serialization.marshal.DefaultUserObjectMarshaller.marshalToOutput(DefaultUserObjectMarshaller.java:172)
	at org.apache.ignite.internal.network.serialization.marshal.DefaultUserObjectMarshaller.marshalShared(DefaultUserObjectMarshaller.java:144)
	at org.apache.ignite.internal.network.serialization.marshal.DefaultUserObjectMarshaller.marshalShared(DefaultUserObjectMarshaller.java:135)
	at org.apache.ignite.internal.network.serialization.marshal.DefaultUserObjectMarshaller.marshal(DefaultUserObjectMarshaller.java:108)
	at org.apache.ignite.internal.compute.message.ExecuteRequestImpl.prepareMarshal(ExecuteRequestImpl.java:82)
	at org.apache.ignite.internal.network.message.InvokeRequestImpl.prepareMarshal(InvokeRequestImpl.java:72)
	at org.apache.ignite.network.DefaultMessagingService.beforeRead(DefaultMessagingService.java:259)
	at org.apache.ignite.network.DefaultMessagingService.sendMessage0(DefaultMessagingService.java:248)
	... 5 more
Caused by: class org.apache.ignite.internal.network.serialization.SpecialMethodInvocationException: writeObject() invocation failed on 10
	at org.apache.ignite.internal.network.serialization.SpecialSerializationMethodsImpl.writeObject(SpecialSerializationMethodsImpl.java:130)
	at org.apache.ignite.internal.network.serialization.marshal.StructuredObjectMarshaller.writeWithWriteObject(StructuredObjectMarshaller.java:103)
	... 22 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.apache.ignite.internal.network.serialization.SpecialSerializationMethodsImpl.writeObject(SpecialSerializationMethodsImpl.java:128)
	... 23 more
Caused by: java.lang.IllegalStateException: Field java.math.BigInteger#magnitude is missing locally, no accesses to it should be performed, this is a bug
	at org.apache.ignite.internal.network.serialization.BrokenFieldAccessor.brokenException(BrokenFieldAccessor.java:141)
	at org.apache.ignite.internal.network.serialization.BrokenFieldAccessor.getObject(BrokenFieldAccessor.java:35)
	at org.apache.ignite.internal.network.serialization.marshal.StructuredObjectMarshaller.getFieldValue(StructuredObjectMarshaller.java:171)
	at org.apache.ignite.internal.network.serialization.marshal.StructuredObjectMarshaller.writeNullsBitSet(StructuredObjectMarshaller.java:143)
	at org.apache.ignite.internal.network.serialization.marshal.UosObjectOutputStream$UosPutField.write(UosObjectOutputStream.java:322)
	at org.apache.ignite.internal.network.serialization.marshal.UosObjectOutputStream.writeFields(UosObjectOutputStream.java:202)
	at java.base/java.math.BigInteger.writeObject(BigInteger.java:4722)
	... 28 more
{code}

To reproduce, uncomment the last line in *ItThinClientComputeTest#testAllSupportedArgTypes* (IGNITE-16734)."	IGNITE	Resolved	3	1	8784	ignite-3
13533197	Schema synchronization design: schema change types	We need to design how we handle all the possible database schema change types. Index handling is separated to IGNITE-19360.	IGNITE	Resolved	3	4	8784	ignite-3
13470109	RocksDB snapshots might include writes added after snapshot creation start	RaftGroupListener#onSnapshotSave() must take state machine-spacific snapshot coordinates synchronously, but in our implementations this is offloaded to a different thread. As a result, some writes can be applied before the snapshot coordinates are taken, so the resulting snapshot will contain more writes than it should.	IGNITE	Resolved	3	1	8784	ignite-3
13505558	Introduce support code for LogicalTopologyService	"In IGNITE-18085, we will need to have {{LogicalTopologyService}} that will be used to get current topology (with version) and also subscribe to the topology changes.

Currently, {{CmgRaftGroupListener}} uses its package local  {{RaftStorageManager}} to work with CMG-related storage, including operations with logical topology. The {{RaftStorageManager}} is the code that will trigger topology modification events, so it needs to either implement the public interface, or be made available to the public interface implementation.

The idea is to create a new component (a suggested name is {{{}InternalLogicalTopologyService{}}}) instantiated by {{IgniteImpl}} and then injected to both {{ClusterManagementGroupManager}} and an implementation of {{{}LogicalTopologyService{}}}."	IGNITE	Resolved	3	4	8784	ignite-3
13427526	Add an integration test for 'cluster init' CLI command	Currently, 'cluster init' command does not have an end-to-end test because the init functionality is still being developed in IGNITE-16471	IGNITE	Resolved	3	4	8784	ignite-3
13574158	Remove reactive methods from AntiHijackingIgniteSql	They were removed from IgniteSql interface.	IGNITE	Resolved	3	4	8784	ignite-3
13419974	Implement injection of Ignite resources on unmarshalling	"User Object Serialization (IGNITE-15944) might be used to serialize compute tasks and other components supplied by a user, sent via network, unmarshalled and executed on Ignite nodes.

Such serialized components may need access to Ignite resources. It makes sense to inject them to fields annotated with a special-purpose annotation (like it was it Ignite 2).

An example of such annotation in Ignite 2 is @TaskSessionResource."	IGNITE	Open	3	4	8784	ignite-3
13594891	Decrease frequency of Metastorage idle SafeTime propagation in tests	"It's currently 10ms which seems too little, 50ms should be fine (as DelayDuration in tests is 100ms).

The value of 10ms means that we write up to 100 times per second per node to the Metastorage log (and each write causes an fsync) which might create heavy (and unnecessary) load. This might be the cause of some integration tests (which start 5-6 Ignite nodes) failing at TC from time to time."	IGNITE	Resolved	3	4	8784	ignite-3
13590414	VersatileReadWriteLockTest#inWriteLockAsyncSetsPendingWriteLocks() is flaky	"org.apache.ignite.internal.util.VersatileReadWriteLockTest.inWriteLockAsyncSetsPendingWriteLocks()] java.lang.AssertionError
                             at org.apache.ignite.internal.util.VersatileReadWriteLock.writeUnlock(VersatileReadWriteLock.java:351)
                             at org.apache.ignite.internal.util.VersatileReadWriteLockTest.releaseWriteLocks(VersatileReadWriteLockTest.java:105)
                             at org.apache.ignite.internal.util.VersatileReadWriteLockTest.cleanup(VersatileReadWriteLockTest.java:85)
                             at java.base/java.lang.reflect.Method.invoke(Method.java:566)
                             at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
                             at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)"	IGNITE	Resolved	3	1	8784	ignite-3
13544789	Check table existence before executing each operation in an RW transaction	"As per https://cwiki.apache.org/confluence/display/IGNITE/IEP-110%3A+Schema+synchronization%3A+basic+schema+changes#IEP110:Schemasynchronization:basicschemachanges-Checkingtheexistenceofatablewhenreading/writing , table existence must be checked before executing an operation (read/write/commit) in a transaction. The table existence must be checked for the operationTs.
This requires IGNITE-19770 to be implemented."	IGNITE	Resolved	3	4	8784	iep-110, ignite-3
13485874	OrderingFuture should notify dependents asynchronously	"Currently, there are the following problems:
 # Callbacks, when invoked, will see the future as incompleted if they directly call its getNow() or get() methods
 # If callbacks invoke long or blocking operations, this impedes completion"	IGNITE	Resolved	3	1	8784	ignite-3
13595984	Do not use ByteUtils#toBytes to serialize assignments	Currently, Java Serialization is used to persist data in DistributionZonesManager. We should not use it (see IGNITE-23135 for justification).	IGNITE	Resolved	3	4	8784	ignite-3
13571485	Prevent threads from being hijacked via async cursors in KV/Record view APIs	query() methods return AsyncCursors. AsyncCursor has methods returning CompletableFutures. We need to prevent thread hijacking via these futures.	IGNITE	Resolved	3	4	8784	ignite-3
13548829	Make a network message handler that would be able to accept ClusterNode as a sender	"*Motivation*

With {{MessagingService}} we have an ability to send message using {{ClusterNode}} to specify a recipient. But in {{NetworkMessageHandler}} we have only ability to receive consistent id of a sender. However, in some cases we need node id (for example, knowing that there is no node we the given id in a cluster, allows us to not send message there at all, because this node has left the topology at least once since it had sent this message and therefore this node lost its volatile state)

Also, the node id should go along with consistent id, so {color:#172b4d}{{ClusterNode}} {color}as the argument type is preferred.

*Definition of done*

The following interface is available:
{code:java}
public interface NetworkMessageHandler {
    /**
     * Method that gets invoked when a network message is received.
     *
     * @param message Message, which was received from the cluster.
     * @param sender Sender node.
     * @param correlationId Correlation id. Used to track correspondence between requests and responses. Can be {@code null} if the received
     *     message is not a request from a {@link MessagingService#invoke} method from another node.
     */
    void onReceived(NetworkMessage message, ClusterNode sender, @Nullable Long correlationId);
} {code}
Also, the {{MessagingService}} is able to accept an object implementing this interface as a message handler.

*Implementation notes*

The ClusterNode passed as a sender should have a node id which the sender node had at the moment the message was sent."	IGNITE	Resolved	3	4	8784	ignite-3
13589055	IgniteSql transparency with respect to node restart	IgniteSql obtained in embedded mode via IgniteServer.api() should remain functional even after the node gets restarted (using in-process restart). This should work analogously to how it's done for IgniteTables (see RestartProofIgniteTables).	IGNITE	Resolved	3	4	8784	ignite-3, inprocess-restart
13579039	IgniteImpl leaks in tests due to unclosed DBOptions in SharedRocksDbInstance	DBOptions used in SharedRocksDbInstance is not closed when SharedRocksDbInstance gets closed, so RocksDbFlushListener (held inside DBOptions) serves as a JNI GC root for IgniteImpl instances. Test suites that start and stop many IgniteImpl instances cause a lot of heap memory being hogged.	IGNITE	Resolved	3	1	8784	ignite-3
13558512	Add thenCompose to OrderingFuture	Needed for IGNITE-20852	IGNITE	Resolved	3	4	8784	ignite-3
13586118	Do not do partition SafeTime sync if previous attempt is not finished	"There is a scheduled task that, periodically, does 'partition SafeTime sync' on each primary replicas living on the node. For each such a replica, we do the following:
 # Take current time from the  node clock ('now')
 # Wait till the Metastorage SafeTime reaches 'now'
 # Make sure the replica is still primary
 # Execute the partition SafeTime sync logic

Step 2 is implemented by installing a future to a PendingComparableValuesTracker representing the Metastorage SafeTime. If, for some reason, Metastorage SafeTime lags behind the node clock, a few (or many) futures might be installed at the same time for the same partition. When there are many partitions, this leads to huge number of futures, most of which are useless (just one [the most recent] of them makes sense for each partition). This increases the amount of garbage. If the node is already struggling to chew the load, this will finish the node off as it will increase the GC pressure drastically. The node will choke itself to OutOfMemory situation.

It is suggested to only execute steps 1-4 if previous future has already finished. We might lose one partition SafeTime update, but in a situation when the node is already struggling (as Metastorage SafeTime lags) this will probably not be noticed."	IGNITE	Patch Available	3	4	8784	ignite-3
13572371	Unconditionally update storage with proper raft index within PartitionListener	"Despite the fact that it's reasonable to skip data update if it was already executed on collocated primary replica storage, it's required to unconditionally update storage with proper raft index within PartitionListener. For more details please see:
{code:java}
synchronized (safeTime) {
    if (cmd.safeTime().compareTo(safeTime.current()) > 0) {
        storageUpdateHandler.handleUpdate( {code}"	IGNITE	Resolved	3	1	8784	ignite-3
13594624	Create revision in Metastorage even if removal has no effect	"Currently, remove() behaves differently from removeAll():
 # If remove() argument (key) corresponds to an entry that did not exist or was already removed, the command does NOT create a new Metastorage revision (so it behaves like a NO_OP command)
 # On the other hand, if all removeAll() keys correspond to non-existing entries, it DOES create a new Metastorage revision
 # In the code of invoke() methods, it can be seen that earlier the same optimization was also applied to remove-only invokes (no revision would be created for a no-op remove-only invoke), but now the optimization can never happen (as we always add a PUT with a key related to idempotency, and PUTs always cause a new revision to be created)

This looks inconsistently. We should simplify the logic and always create a Metastorage revision as a result of executing a command that might potentially change it, even if the Metastorage is not changed at all."	IGNITE	Resolved	3	4	8784	ignite-3
13536404	Add a method to InternalTransaction for getting initial schema timestamp	The method must return readTs for an RO transaction and beginTs for an RW transaction.	IGNITE	Resolved	3	4	8784	ignite-3
13505911	Fix REST API version in the generated openapi.yaml	{{openapi.yaml}} is generated during build. It must contain version 3.0.0-SNAPSHOT, but in reality version 3.0.0-alpha is generated.	IGNITE	Resolved	3	1	8784	ignite-3
13573702	Prevent thread hijacking via IgniteSql	Methods of IgniteSql that return CompletableFutures must wrap their return value with PublicApiThreading#preventThreadHijack(). Also, tests need to be created (similar to ItKvRecordApiThreadingTest).	IGNITE	Resolved	3	4	8784	ignite-3, threading
13469674	Fix Netty buffer leak in MarshallableTest	"[https://ci.ignite.apache.org/viewLog.html?tab=buildLog&logTab=tree&expand=all&buildId=6659100&filter=all&_focus=3590]

 
[org.apache.ignite:ignite-network] 2022-07-01 13:34:40:579 +0300 [ERROR][main][ResourceLeakDetector] LEAK: ByteBuf.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records:
Created at:
io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:96)
io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:188)
io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:174)
io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:108)
org.apache.ignite.internal.network.serialization.MarshallableTest.read(MarshallableTest.java:150)
org.apache.ignite.internal.network.serialization.MarshallableTest.testMarshallable(MarshallableTest.java:84)"	IGNITE	Resolved	3	1	8784	ignite-3
13562985	Deserialization of Instant field in a Marshallable fails	"Instant is a final class, so we assume that an Instant field will always contain an instance of Instant (so 'the type is known upfront'), so we apply an optimization of not writing the descriptor ID for this field's content.

But at the same time, Instant defines writeReplace() which replaces it with an instance of another type (Ser) when serializing, so the type can actually change during serialization, so we cannot apply the optimization in such cases."	IGNITE	Resolved	3	1	8784	ignite-3
13567601	ItConnectionManagerTest.sendFutureOfMessageNeedingAckCompletesWhenMessageGetsAcknowledged() is flaky	There is a race between appearance of a sender for the open channel in manager2 senders' map and the installation of an acknowledgement silencer. Sometimes the sender appears in the map too late, so the silencer does not see it and does not install itself, which causes the test to fail.	IGNITE	Resolved	3	1	8784	ignite-3
13543638	Increase stability of inMemoryNodeRestartNotLeader in ItIgniteInMemoryNodeRestartTest	The test sometimes fails because restart of a node happens before all nodes get table data through replication. As a result, when the restarted node starts, it does not see a 'majority with data' and fails.	IGNITE	Resolved	3	1	8784	ignite-3
13587587	Send all cluster IDs to thin client on connection	"After IGNITE-22807 and IGNITE-22882 are implemented, we should start sending all cluster IDs (all previous ones and the current one) to a thin client when it connects a server node.

Also, a test has to be added for the following scenario:
 # A cluster is initialized
 # A thin client is connected to the cluster (and does something like making a put)
 # CMG is reset on the cluster
 # The thin client should still work (a get should succeed) without a restart"	IGNITE	Resolved	3	4	8784	iep-128, ignite-3
13587741	Validate Metastorage for divergency during join	"A joining node will take <revision, checksum> for the latest command it has applied on Metastorage recovery as <nodeRevision, nodeChecksum> and will use it when validating against the MG leader. It will ask the MG leader to provide its current history in the form of <revision, checksum> pairs. Let’s denote min and max revisions in the leader’s history as minRevision and maxRevision and leader’s checksum for revision R as leaderChecksum(R). Outcomes:
 # minRevision <= nodeRevision <= maxRevision and leaderChecksum(nodeRevision) = nodeChecksum -> node is allowed to join
 # minRevision <= nodeRevision <= maxRevision and leaderChecksum(nodeRevision) <> nodeChecksum -> the node is not allowed to join
 # nodeRevision > maxRevision -> disallow join (maybe it actually diverged and the leader is going to grow its history in another direction while the current node is joining)
 # nodeRevision < minRevision (some history is removed due to compaction) -> we don’t know if it diverged -> the node is not allowed to join"	IGNITE	Resolved	3	4	8784	iep-128, ignite-3
13471531	ItNodeTest.changePeersAsyncResponses test is flaky	"[https://ci.ignite.apache.org/viewLog.html?buildId=6681607&tab=buildResultsDiv&buildTypeId=ignite3_Test_IntegrationTests_ModuleRaft]
org.opentest4j.AssertionFailedError: expected: <Status[EBUSY<1009>: Doing another configuration change.]> but was: <Status[OK]>
	at org.apache.ignite.raft.jraft.core.ItNodeTest.changePeersAsyncResponses(ItNodeTest.java:3245)
 "	IGNITE	Resolved	3	1	8784	ignite-3
13507485	.NET: Enable Java assertions in test Ignite nodes	Currently, Ignite nodes are run without {{-ea}} flag which should be used in test environments.	IGNITE	Resolved	3	4	8784	.NET, ignite-3
13429899	[Compute Grid] Implement execute method of IgniteCompute interface	"The following method should be implemented:

{code}
<R> CompletableFuture<R> execute(Set<ClusterNode> nodes, Class<? Extends ComputeJob<R>> cls, Object … args);
{code}

On the first phase implementation doesn't need to support failover or load balancing.

Execution should be implemented using this simple algorithm:
* Randomly choose a target node from the given set of nodes if applicable.
* Transfer a job class name and arguments to the target node.
* Instantiate job’s instance on the target node. Deserialize arguments.
* Execute job.
* Return the result or error to the node that initiated the job execution. 
"	IGNITE	Resolved	3	3	8784	iep-100, ignite-3
13517591	Destroy indices when destroying VolatilePageMemoryMvPartitionStorage	Currently, only MV data is destroyed. Indices should be destroyed, as well.	IGNITE	Resolved	3	4	8784	ignite-3
13538879	Retry more frequently in ItTableRaftSnapshotsTest	It looks like due to https://issues.apache.org/jira/browse/IGNITE-19655 the tests sometimes fail because it's not too improbable to get randomly mapped to the same node 5 times in a row. As a workaround, we can increase the number (and the frequency) of the retries so that the probability to get mapped to the same node for the whole series becomes much lower.	IGNITE	Resolved	3	4	8784	ignite-3
13433086	[Compute Grid] Implement executeColocated method of IgniteCompute interface	"The following method should be implemented:
{code:java}
<R> CompletableFuture<R> executeColocated(String table, K key, Class<? extends ComputeJob<R>> cls, Object … args);
{code}

To implement colocation we need to integrate compute with affinity calculation mechanism.

On the first phase implementation doesn't need to support failover or load balancing.

Also on the first phase there is no requirements for pinning partition to chosen node for the whole time of compute execution. Possibility for rebalancing to start during compute execution should be ignored."	IGNITE	Resolved	3	3	8784	iep-100, ignite-3
13565665	nodeCannotCommunicateAfterLeavingPhysicalTopology is flaky	"ItScaleCubeNetworkMessagingTest#nodeCannotCommunicateAfterLeavingPhysicalTopology() is flaky, it fails with

 
java.lang.AssertionError: Expected: a future that completes with an exception that is an instance of org.apache.ignite.internal.network.handshake.HandshakeException but: was completed exceptionally with <java.nio.channels.ClosedChannelException>
java.lang.AssertionError:
Expected: a future that completes with an exception that is an instance of org.apache.ignite.internal.network.handshake.HandshakeException
but: was completed exceptionally with <java.nio.channels.ClosedChannelException>
  at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
  at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:6)
  at org.apache.ignite.network.scalecube.ItScaleCubeNetworkMessagingTest.nodeCannotCommunicateAfterLeavingPhysicalTopology(ItScaleCubeNetworkMessagingTest.java:550)
 
The problem seems to be that there is a race between closing channels when a node is removed from the physical topology and trying to send a message in the test. We should expect not just HandshakeException, but also ClosedChannelException."	IGNITE	Resolved	3	1	8784	ignite-3
13421956	Implement readUnshared()/writeUnshared() for User Object Serialization	"ObjectOutputStream has writeUnshared() and ObjectInputStream has readUnshared() methods that differ from writeObject() and readObject() methods in some aspects (see their javadocs).

We probably need to support this difference."	IGNITE	Resolved	3	4	8784	ignite-3
13554921	LeaseUpdaterTest causes a NullPointerException	"In [https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunUnitTests/7577194?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildProblemsSection=true&expandBuildChangesSection=true] the following can be seen in the logs:

 
LeaseUpdaterTest > testActiveDeactivateMultiThread() > repetition 10 of 20 STANDARD_ERROR
[2023-10-20T10:35:45,058][WARN ][%test-node%lease-updater-25][LeaseUpdater] Lease updater is interrupted
Exception in thread ""%test-node%lease-updater-26"" java.lang.NullPointerException
  at org.apache.ignite.internal.placementdriver.LeaseUpdaterTest.lambda$setUp$0(LeaseUpdaterTest.java:130)
  at org.mockito.internal.stubbing.StubbedInvocationMatcher.answer(StubbedInvocationMatcher.java:42)
  at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:103)
  at org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)
  at org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:34)
  at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)
  at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:56)
  at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:161)
  at org.apache.ignite.internal.metastorage.MetaStorageManager$MockitoMock$XTQ2X5zi.invoke(Unknown Source)
 
The NPE does not fail the test itself, but our CI sees it in the logs and fails a build."	IGNITE	Resolved	3	1	8784	ignite-3
13429689	Add a mechanism for registering SchemaMismatchHandlers	"SchemaMismatchHandlers are being added in IGNITE-15948

If User Object Serialization will be used by someone except Ignite Core, we'll need a mechanism to register such handlers with UserObjectMarshaller instances."	IGNITE	Open	3	4	8784	ignite-3
13531544	Fetch table schema by timestamp	"Currently, when obtaining a schema, its latest (from the local point of view) version is returned.
 # Table schema must always be obtained using a timestamp
 # This might require a wait (until MetaStorage's SafeTime >= schemaTs-DD, see [https://cwiki.apache.org/confluence/display/IGNITE/IEP-98%3A+Schema+Synchronization#IEP98:SchemaSynchronization-Waitingforsafetimeinthepast] )

This includes the mechanisms that allow clients obtain 'current' schema (like 'DESCRIBE <table>', 'list tables', etc)."	IGNITE	Resolved	3	4	8784	iep-98, ignite-3
13522791	Destruction of logs and meta at partition raft group destruction	When evicting a partition from a node and when destoroying the table, we need to destroy the raft log and meta.	IGNITE	Open	3	4	8784	ignite-3, important
13521086	Make RAFT snapshot streaming resistant to network glitches	"Network is inherently unreliable (see IGNITE-18605). RAFT snapshot streaming might take dozens of minutes. Current implementation breaks on the first lost/improperly handled message, so  If we get a glitch in the middle of a long snapshot installation, we'll waste a lot of resources.

The idea is to:
 # Make requests idempotent (so that we can repeat a lost request). {{SnapshotMetaRequest}} is already idempotent. {{SnapshotMvDataRequest}} and {{SnapshotTxDataRequest}} can be provided with a sequenceNo (increased at the receiving side for each next request, but not increased for a retry of a previous request). As there is only one receiver, and it always works sequentially, on the sending side we'll have to only additionally remember the previous response and its sequenceNo to support idempotent retries that do not cause excessive cursor advancement.
 # On the receiving side, specify a sane timeout (like a few seconds) per request and retry requests that error or timeout (using the correct sequenceNo)
 # If an error happens while processing a request on the sending side, return an indication of an error to the receiver instead of just dropping the message (so that the receiver gets informed about the necessity  to make a retry faster, AND the receiver can see whether it should stop retrying if the failure is fatal)."	IGNITE	Resolved	3	4	8784	ignite-3
13520210	Network serialization of arrays of NetworkMessage objects doesn't work	"Consider the following class hierarchy:

{code:java}
@Transferable
interface A extends NetworkMessage {}

@Transferable
interface B extends NetworkMessage {
    A[] arrayField();
}
{code}

When sending a message of type {{B}} from one node to another, the following exception occurs: 

{{java.lang.IllegalStateException: Cannot merge descriptors in the correct order; a cycle?}}

This happens, because a descriptor of type {{A}} can't be found on the receiving node.

This problem also appears if we change {{B}}'s field type to {{Collection<A>}}, but provide {{Arrays.asList(new AImpl())}}, because the wrapper contains an array inside.
 
"	IGNITE	Open	3	1	8784	ignite-3
13445667	Add protection against arbitrary page memory links in LinkRowId	"It's theoretically possible to pass an arbitrary page memory link (via LinkRowId) which might cause troubles:
 # If pageId exceeds page memory limit, the JVM might crash
 # If the page with this pageId was never initialized, an attempt to read will fail with an internal assertion (because lock state will be 0)

A possibility for item ID to be invalid is already handled."	IGNITE	Resolved	3	4	8784	ignite-3
13525531	Introduce thread types to thread pools	"Like in Ignite 2.x, we need to have custom classes for threads, with custom properties.

Currently, I can only say that we use custom thread types in network, for event loops I guess. That's not enough, here's why.

Given the wide adoption of async code, developers struggle to understand, what thread executes the actual operation. For example, ""thenCompose"" or ""whenComplete"" closure is being executed in whatever thread that completes the future, and quite often it's not the thread that we want.

Also, we shouldn't use default fork-join pool, for example. We should force most operations to our own pools.

To make everything more clear, we have to mark threads with at least following categories:
 * can perform storage reads
 * can perform storage writes
 * can perform network IO operations
 * can be safely blocked
 * etc.

Once we know for sure that the thread fits the operation, we can execute it. Ideally, that should be an assertion and not a runtime logic.

This will also help us finding existing bugs and bottlenecks."	IGNITE	Resolved	3	4	8784	ignite-3, storage-threading, threading
13443802	Make the project build on Java 18	It's interesting to see whether Ignite 3 can be built on Java 18 and, if not, fix the issues.	IGNITE	Resolved	3	4	8784	ignite-3
13581412	Improve handling of small network messages on send	"Currently, each message send produces a flush meaning a channel.write() call per message (if the message is small).

We need to consolidate writes so that small messages are grouped in batches and channel.write() writes a lot of small messages at once."	IGNITE	Resolved	3	4	8784	ignite-3
13575131	Fix double-checked locking in ReadWriteTransactionImpl	{{finishFuture}} needs to be made volatile	IGNITE	Resolved	3	4	8784	ignite-3
13550027	Remove CatalogTables	CatalogTables interface and its implementations must be removed after the switch to the Catalog is finiahed (IGNITE-19499, IGNITE-19502) and there are no more configuration-defined table IDs; invocations of its methods should be replaced with directly invoking the corresponding methods of CatalogService.	IGNITE	Resolved	3	4	8784	ignite-3, tech-debt
13592342	Avoid concurrent Catalog writes to Metastorage on the same node	Each DDL tries to make a write to the Metastorage. Each write is assigned a sequential number (version); if a few DDLs try to write to the Metastorage, they will all compete for the same version, and only one of them can succeed. This competition is wasteful. We need to avoid such concurrency on the same node by explicitly linearizing writes to the Metastorage from the Catalog before doing them.	IGNITE	Resolved	3	4	8784	ignite-3
13445695	Support fragmented RowVersions	RowVersionDataIo#writeFragmentData() needs to be properly implemented	IGNITE	Resolved	3	4	8784	ignite-3
13536535	SchemaManager should use CatalogService for building BinaryRow descriptors	"As of now, SchemaManager uses configuration data to create BinaryRow/BinaryTuple descriptors.
Let's make SchemaManager and SchemaRegistry using Catalog data instead."	IGNITE	Resolved	3	4	8784	ignite-3
13539212	Treat Scalecube's LEAVING event as 'node left' in the physical topology	"When a Scalecube's Cluster instance shuts down, the local member tells everyone that it is LEAVING (it's the only reason a member might end up in this state). Other nodes do not treat the member as REMOVED immediately as they see it LEAVING; instead, a whole suspicion interval must pass before the member is considered to be REMOVED.

As we know that the LEAVING member has already left (and will not be back with the same ID), we should treat the LEAVING event as 'Node left' (in the physical topology)."	IGNITE	Resolved	3	4	8784	ignite-3
13568278	ItNodeRestartsTest.testRestarts is flaky	"After running the test repeatedly, the following happened: after a restart of 2 clusterServices, one of the restarted cluster services (port 3344) and one of not restarted cluster services (port 3345) could not 'see' each other due to metadata obtaining timeout:

[2024-02-12T14:16:54,968][WARN ][sc-cluster-3345-1409][MetadataStore] [default:inrt_tr_3345:13b7bdae21a14c86@127.0.1.1:3345][56ad9288-7ce4-4f67-b11c-8e1eaf6d6612] Timeout getting GetMetadataResp from 127.0.1.1:3344 within 1000 ms, cause: java.util.concurrent.TimeoutException: Did not observe any item or terminal signal within 1000ms in 'source(MonoDefer)' (and no fallback has been configured)
[2024-02-12T14:16:54,968][WARN ][sc-cluster-3345-1409][MembershipProtocol] [default:inrt_tr_3345:13b7bdae21a14c86@127.0.1.1:3345][updateMembership][SYNC] Skipping to add/update member: \{m: default:inrt_tr_3344:788fea0a8f9b4251@127.0.1.1:3344, s: ALIVE, inc: 0}, due to failed fetchMetadata call (cause: java.util.concurrent.TimeoutException: Did not observe any item or terminal signal within 1000ms in 'source(MonoDefer)' (and no fallback has been configured))

 "	IGNITE	Resolved	3	1	8784	ignite-3
